<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>fudge.core.math.linearAlgebra &#8212; Fudge and GND 4.2.2 beta documentation</title>
    
    <link rel="stylesheet" href="../../../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../',
        VERSION:     '4.2.2 beta',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../../../_static/gnd-20121206-favicon.ico"/>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">Fudge and GND 4.2.2 beta documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for fudge.core.math.linearAlgebra</h1><div class="highlight"><pre>
<span></span><span class="c1">#~/usr/bin/env python</span>

<span class="c1"># &lt;&lt;BEGIN-copyright&gt;&gt;</span>
<span class="c1"># &lt;&lt;END-copyright&gt;&gt;</span>


<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>
<span class="kn">import</span> <span class="nn">argparse</span><span class="o">,</span> <span class="nn">numpy</span><span class="o">,</span> <span class="nn">copy</span><span class="o">,</span> <span class="nn">math</span>


<span class="c1"># ------------ safer matrix and inverse construction tools, &quot;by hand&quot; -----------</span>
<span class="c1"># ------------------------- these are the core routines -------------------------</span>
<div class="viewcode-block" id="eigenvectors_from_orthoganal_matrix"><a class="viewcode-back" href="../../../../fudge/fudge.core.math.html#fudge.core.math.linearAlgebra.eigenvectors_from_orthoganal_matrix">[docs]</a><span class="k">def</span> <span class="nf">eigenvectors_from_orthoganal_matrix</span><span class="p">(</span> <span class="n">O</span> <span class="p">):</span>
    <span class="n">v</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">O</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">):</span> <span class="n">v</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">O</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">v</span></div>

<div class="viewcode-block" id="matrix_from_eigendecomposition"><a class="viewcode-back" href="../../../../fudge/fudge.core.math.html#fudge.core.math.linearAlgebra.matrix_from_eigendecomposition">[docs]</a><span class="k">def</span> <span class="nf">matrix_from_eigendecomposition</span><span class="p">(</span> <span class="n">e</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">ndim</span><span class="p">,</span> <span class="n">doInverse</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">onlyLargeEVs</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">onlyPositiveEV</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">smallEVAbsTol</span> <span class="o">=</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="n">smallEVRelTol</span> <span class="o">=</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">6</span> <span class="p">):</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span> <span class="n">ndim</span><span class="p">,</span> <span class="n">ndim</span> <span class="p">)</span> <span class="p">)</span>
    <span class="n">evTol</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span> <span class="n">smallEVAbsTol</span><span class="p">,</span> <span class="n">smallEVRelTol</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">max</span><span class="p">())</span> <span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">ndim</span> <span class="p">):</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span> <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span> <span class="o">&lt;</span> <span class="n">evTol</span> <span class="ow">and</span> <span class="n">onlyLargeEVs</span><span class="p">:</span> <span class="k">continue</span>
        <span class="k">if</span> <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.0</span> <span class="ow">and</span> <span class="n">onlyPositiveEV</span><span class="p">:</span> <span class="k">continue</span>
        <span class="k">if</span> <span class="n">doInverse</span><span class="p">:</span> <span class="n">x</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span> <span class="n">x</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">B</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span> <span class="n">x</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">T</span> <span class="p">)</span> <span class="c1"># += operator causes casting exception for obscure numpy reasons</span>
    <span class="k">return</span> <span class="n">B</span></div>
    
<div class="viewcode-block" id="pruned_matrix_inverse"><a class="viewcode-back" href="../../../../fudge/fudge.core.math.html#fudge.core.math.linearAlgebra.pruned_matrix_inverse">[docs]</a><span class="k">def</span> <span class="nf">pruned_matrix_inverse</span><span class="p">(</span> <span class="n">A</span><span class="p">,</span> <span class="n">onlyLargeEVs</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">onlyPositiveEV</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">smallEVAbsTol</span> <span class="o">=</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="n">smallEVRelTol</span> <span class="o">=</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">6</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Build inverse of :math:`A` \&quot;by hand\&quot;, the safe way.   :math:`A` must admit an eigenvalue decomposition.&quot;&quot;&quot;</span>
    <span class="n">e</span><span class="p">,</span> <span class="n">O</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span> <span class="n">A</span> <span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">eigenvectors_from_orthoganal_matrix</span><span class="p">(</span> <span class="n">O</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">matrix_from_eigendecomposition</span><span class="p">(</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">e</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">doInverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">onlyLargeEVs</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">onlyPositiveEV</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">smallEVAbsTol</span> <span class="o">=</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="n">smallEVRelTol</span> <span class="o">=</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">6</span> <span class="p">)</span></div>
            
<div class="viewcode-block" id="pruned_matrix"><a class="viewcode-back" href="../../../../fudge/fudge.core.math.html#fudge.core.math.linearAlgebra.pruned_matrix">[docs]</a><span class="k">def</span> <span class="nf">pruned_matrix</span><span class="p">(</span> <span class="n">A</span><span class="p">,</span> <span class="n">onlyLargeEVs</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">onlyPositiveEV</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">smallEVAbsTol</span> <span class="o">=</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="n">smallEVRelTol</span> <span class="o">=</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">6</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Rebuild :math:`A` \&quot;by hand\&quot;, the safe way.   :math:`A` must admit an eigenvalue decomposition.&quot;&quot;&quot;</span>
    <span class="n">e</span><span class="p">,</span> <span class="n">O</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span> <span class="n">A</span> <span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">eigenvectors_from_orthoganal_matrix</span><span class="p">(</span> <span class="n">O</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">matrix_from_eigendecomposition</span><span class="p">(</span> <span class="n">e</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">onlyLargeEVs</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">onlyPositiveEV</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">smallEVAbsTol</span> <span class="o">=</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="n">smallEVRelTol</span> <span class="o">=</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">6</span> <span class="p">)</span>            </div>

<div class="viewcode-block" id="scale_off_diagonals"><a class="viewcode-back" href="../../../../fudge/fudge.core.math.html#fudge.core.math.linearAlgebra.scale_off_diagonals">[docs]</a><span class="k">def</span> <span class="nf">scale_off_diagonals</span><span class="p">(</span> <span class="n">A</span><span class="p">,</span> <span class="n">onlyScaleThese</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">scaleFactor</span> <span class="o">=</span> <span class="mf">0.999999</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Sam&#39;s trick for getting UNCOR to cooperate: shrink off diagonal elements by some (small) factor&quot;&quot;&quot;</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span> <span class="n">A</span> <span class="p">)</span>
    <span class="n">ndim</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">ndim</span> <span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">i</span> <span class="p">):</span> 
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span> <span class="k">continue</span>
            <span class="k">if</span> <span class="n">onlyScaleThese</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="p">(</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="p">)</span> <span class="ow">in</span> <span class="n">onlyScaleThese</span> <span class="ow">or</span> <span class="p">(</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span> <span class="p">)</span> <span class="ow">in</span> <span class="n">onlyScaleThese</span><span class="p">:</span> 
                <span class="n">B</span><span class="p">[</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="p">]</span> <span class="o">=</span> <span class="n">scaleFactor</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="p">]</span>
                <span class="n">B</span><span class="p">[</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span> <span class="p">]</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="p">]</span>
    <span class="k">return</span> <span class="n">B</span></div>

<div class="viewcode-block" id="reduce_off_diagonals"><a class="viewcode-back" href="../../../../fudge/fudge.core.math.html#fudge.core.math.linearAlgebra.reduce_off_diagonals">[docs]</a><span class="k">def</span> <span class="nf">reduce_off_diagonals</span><span class="p">(</span> <span class="n">corr_mat</span><span class="p">,</span> <span class="n">thresh</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sometimes easiest way to eliminate negative eigenvalues is to </span>
<span class="sd">    reduce off-diagonal portion of the correlation matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">corr_mat_new</span> <span class="o">=</span> <span class="n">corr_mat</span><span class="p">[:,:]</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">corr_mat</span><span class="p">[</span> <span class="n">offdiag</span><span class="p">(</span><span class="n">corr_mat</span><span class="p">)</span> <span class="p">]</span>
    <span class="n">tmp</span><span class="p">[</span> <span class="n">tmp</span><span class="o">&gt;</span><span class="n">thresh</span> <span class="p">]</span> <span class="o">=</span> <span class="n">thresh</span>
    <span class="n">corr_mat_new</span><span class="p">[</span> <span class="n">off_diagonals</span><span class="p">(</span><span class="n">corr_mat_new</span><span class="p">)</span> <span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
    <span class="k">return</span> <span class="n">corr_mat_new</span></div>
  
<div class="viewcode-block" id="off_diagonals"><a class="viewcode-back" href="../../../../fudge/fudge.core.math.html#fudge.core.math.linearAlgebra.off_diagonals">[docs]</a><span class="k">def</span> <span class="nf">off_diagonals</span><span class="p">(</span> <span class="n">matrix</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return indices for all off-diagonal elements.</span>
<span class="sd">    </span>
<span class="sd">        &gt;&gt;&gt; mat[ offdiag( mat ) ] *= -1</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ilen</span><span class="p">,</span> <span class="n">jlen</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ilen</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">jlen</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span><span class="o">!=</span><span class="n">j</span><span class="p">]</span>
    <span class="n">jdx</span> <span class="o">=</span> <span class="p">[</span><span class="n">j</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ilen</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">jlen</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span><span class="o">!=</span><span class="n">j</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">idx</span><span class="p">,</span><span class="n">jdx</span></div>
  
<div class="viewcode-block" id="dot_product"><a class="viewcode-back" href="../../../../fudge/fudge.core.math.html#fudge.core.math.linearAlgebra.dot_product">[docs]</a><span class="k">def</span> <span class="nf">dot_product</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Matrix multiplication (dot product) of all arguments:</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; dotproduct(V.T, A, V)   # returns V.T * A * V</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># py3000 has no built-in reduce function:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    res = args[0]</span>
<span class="sd">    for arr in args[1:]:</span>
<span class="sd">        res = numpy.dot(res,arr)</span>
<span class="sd">    return res</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">reduce</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">,</span><span class="n">args</span> <span class="p">)</span></div>

<span class="c1"># ------------------------- rebinning for ENDF matrices ------------------------- </span>
<div class="viewcode-block" id="rebin_matrix"><a class="viewcode-back" href="../../../../fudge/fudge.core.math.html#fudge.core.math.linearAlgebra.rebin_matrix">[docs]</a><span class="k">def</span> <span class="nf">rebin_matrix</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Rebin array by factor of N (not necessarily multiple of 2)&quot;&quot;&quot;</span>
    <span class="n">d</span><span class="p">,</span><span class="n">r</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span><span class="n">N</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">r</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="p">[</span><span class="nb">sum</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">N</span><span class="o">*</span><span class="n">i</span><span class="p">:</span><span class="n">N</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="n">N</span><span class="p">])</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">)]</span></div>

<div class="viewcode-block" id="hist_interp_of_matrix"><a class="viewcode-back" href="../../../../fudge/fudge.core.math.html#fudge.core.math.linearAlgebra.hist_interp_of_matrix">[docs]</a><span class="k">def</span> <span class="nf">hist_interp_of_matrix</span><span class="p">(</span><span class="n">supergrid</span><span class="p">,</span> <span class="n">mat</span><span class="p">,</span> <span class="n">erows</span><span class="p">,</span> <span class="n">ecols</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Put &#39;histogram&#39; interpolation of matrix onto a new `supergrid`:</span>
<span class="sd">    </span>
<span class="sd">    :param supergrid: energy list to use for new matrix</span>
<span class="sd">    :param mat: original matrix to be interpolated</span>
<span class="sd">    :param erows: energy bins for rows/x-axis of original matrix</span>
<span class="sd">    :param ecols: energy bins for columns/y-axis, same as ex by default</span>
<span class="sd">    </span>
<span class="sd">    all points in `erows` and `ecols` must also be in supergrid, </span>
<span class="sd">    or ValueError is raised</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ecols</span><span class="p">:</span>
        <span class="n">ecols</span> <span class="o">=</span> <span class="n">erows</span><span class="p">[:]</span>
    
    <span class="n">nvals</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">supergrid</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
    <span class="n">ret_mat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="n">nvals</span><span class="p">,</span> <span class="n">nvals</span><span class="p">)</span> <span class="p">)</span>
    <span class="n">xidx</span> <span class="o">=</span> <span class="p">[</span> <span class="n">supergrid</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">en</span><span class="p">)</span> <span class="k">for</span> <span class="n">en</span> <span class="ow">in</span> <span class="n">erows</span> <span class="p">]</span>
    <span class="n">yidx</span> <span class="o">=</span> <span class="p">[</span> <span class="n">supergrid</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">en</span><span class="p">)</span> <span class="k">for</span> <span class="n">en</span> <span class="ow">in</span> <span class="n">ecols</span> <span class="p">]</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">xidx</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">yidx</span><span class="p">)):</span>
            <span class="n">ret_mat</span><span class="p">[</span><span class="n">xidx</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span><span class="n">xidx</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">yidx</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span><span class="n">yidx</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">ret_mat</span></div>

<span class="c1"># ------------------------- symmetric matrix tools ------------------------------</span>
<div class="viewcode-block" id="switchSymmetry"><a class="viewcode-back" href="../../../../fudge/fudge.core.math.html#fudge.core.math.linearAlgebra.switchSymmetry">[docs]</a><span class="k">def</span> <span class="nf">switchSymmetry</span><span class="p">(</span> <span class="n">mlist</span><span class="p">,</span> <span class="n">upperToLower</span> <span class="o">=</span> <span class="kc">True</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A symmetric 2-d NxN array can be stored in memory as a list of (N*(N+1)/2) numbers. The order depends</span>
<span class="sd">    on whether the upper-diagonal or lower-diagonal portion of the array is being stored.  This method switches</span>
<span class="sd">    between the two representations.</span>
<span class="sd">    Note that switching from upper to lower is the same as switching the memory order from &#39;column-major&#39; to &#39;row-major&#39;</span>

<span class="sd">    :param mlist: list, tuple or 1d array representing input matrix</span>
<span class="sd">    :param upperToLower: boolean, True = convert upper- to lower-symmetric, False = convert lower- to upper-symmetric</span>
<span class="sd">    :return: list with output matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">mlist</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
    <span class="n">arrays</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">shape</span><span class="p">)]</span>
    <span class="n">matiter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">mlist</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">upperToLower</span><span class="p">:</span> <span class="n">lbound</span><span class="p">,</span><span class="n">ubound</span><span class="o">=</span><span class="n">idx</span><span class="p">,</span><span class="n">shape</span>
        <span class="k">else</span><span class="p">:</span> <span class="n">lbound</span><span class="p">,</span><span class="n">ubound</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">jdx</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">lbound</span><span class="p">,</span><span class="n">ubound</span><span class="p">):</span>
            <span class="n">arrays</span><span class="p">[</span><span class="n">jdx</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">matiter</span><span class="o">.</span><span class="n">next</span><span class="p">()</span> <span class="p">)</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">val</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">arrays</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">]</span></div>

<span class="c1"># ------------------------- covariance matrix checks ------------------------- </span>
<div class="viewcode-block" id="check_real_and_finite"><a class="viewcode-back" href="../../../../fudge/fudge.core.math.html#fudge.core.math.linearAlgebra.check_real_and_finite">[docs]</a><span class="k">def</span> <span class="nf">check_real_and_finite</span><span class="p">(</span> <span class="n">A</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Checks that all elements in a matrix are read and finite&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="p">)</span> <span class="ow">and</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="p">)</span></div>

<div class="viewcode-block" id="check_positive_semidefinite"><a class="viewcode-back" href="../../../../fudge/fudge.core.math.html#fudge.core.math.linearAlgebra.check_positive_semidefinite">[docs]</a><span class="k">def</span> <span class="nf">check_positive_semidefinite</span><span class="p">(</span> <span class="n">A</span><span class="p">,</span> <span class="n">warnAll</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Checks that all elements in a matrix are :math:`\leq 0`&quot;&quot;&quot;</span>
    <span class="n">success</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">e</span><span class="p">,</span> <span class="n">O</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span> <span class="n">A</span> <span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span> <span class="n">e</span> <span class="p">):</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span> 
            <span class="k">if</span> <span class="n">warnAll</span><span class="p">:</span> 
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;FAIL  </span><span class="si">{i}</span><span class="s2">th eigenvalue &lt; 0.0: </span><span class="si">{x}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span> <span class="n">i</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">x</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
                <span class="n">success</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span> <span class="n">x</span><span class="p">,</span> <span class="mf">0.0</span> <span class="p">):</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;FAIL  </span><span class="si">{i}</span><span class="s2">th eigenvalue &lt; 0.0: </span><span class="si">{x}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span> <span class="n">i</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">x</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
                <span class="n">success</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="n">success</span></div>
        
<div class="viewcode-block" id="check_symmetric"><a class="viewcode-back" href="../../../../fudge/fudge.core.math.html#fudge.core.math.linearAlgebra.check_symmetric">[docs]</a><span class="k">def</span> <span class="nf">check_symmetric</span><span class="p">(</span> <span class="n">A</span><span class="p">,</span> <span class="n">warnAll</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Checks whether a matrix is symmetric, i.e. :math:`A_{ij} = A_{ji}`&quot;&quot;&quot;</span>
    <span class="n">success</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">ndim</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">ndim</span> <span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">i</span> <span class="p">):</span>
            <span class="k">if</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]:</span> 
                <span class="k">if</span> <span class="n">warnAll</span><span class="p">:</span> 
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;FAIL  A[</span><span class="si">{i}</span><span class="s2">,</span><span class="si">{j}</span><span class="s2">] != A[</span><span class="si">{j}</span><span class="s2">,</span><span class="si">{i}</span><span class="s2">]: </span><span class="si">{val1}</span><span class="s2"> vs. </span><span class="si">{val2}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span> <span class="n">i</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">j</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">),</span> <span class="n">val1</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]),</span> <span class="n">val2</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">])</span> <span class="p">)</span> <span class="p">)</span>
                    <span class="n">success</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">])</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">],</span> <span class="mf">0.0</span> <span class="p">):</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;FAIL  A[</span><span class="si">{i}</span><span class="s2">,</span><span class="si">{j}</span><span class="s2">] != A[</span><span class="si">{j}</span><span class="s2">,</span><span class="si">{i}</span><span class="s2">]: </span><span class="si">{val1}</span><span class="s2"> vs. </span><span class="si">{val2}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span> <span class="n">i</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">j</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">),</span> <span class="n">val1</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]),</span> <span class="n">val2</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">])</span> <span class="p">)</span> <span class="p">)</span>
                    <span class="n">success</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="n">success</span></div>

<div class="viewcode-block" id="check_covariance_element_bounds"><a class="viewcode-back" href="../../../../fudge/fudge.core.math.html#fudge.core.math.linearAlgebra.check_covariance_element_bounds">[docs]</a><span class="k">def</span> <span class="nf">check_covariance_element_bounds</span><span class="p">(</span> <span class="n">A</span><span class="p">,</span> <span class="n">warnAll</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span> <span class="p">):</span>
    <span class="n">success</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">ndim</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">ndim</span> <span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">i</span> <span class="p">):</span>
            <span class="k">if</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mf">0.0</span> <span class="ow">and</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mf">0.0</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="p">)</span> <span class="o">&gt;</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="p">):</span> 
                <span class="k">if</span> <span class="n">warnAll</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;FAIL  abs( A[</span><span class="si">{i}</span><span class="s2">,</span><span class="si">{j}</span><span class="s2">] ) &gt; sqrt( A[</span><span class="si">{i}</span><span class="s2">,</span><span class="si">{i}</span><span class="s2">] * A[</span><span class="si">{j}</span><span class="s2">,</span><span class="si">{j}</span><span class="s2">] ): </span><span class="si">{val1}</span><span class="s2"> vs. </span><span class="si">{val2}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span> <span class="n">i</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">j</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">),</span> <span class="n">val1</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="p">)),</span> <span class="n">val2</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="p">))</span> <span class="p">)</span> <span class="p">)</span>
                    <span class="n">success</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span> <span class="nb">abs</span><span class="p">(</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="p">),</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="p">)</span> <span class="p">):</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;FAIL  abs( A[</span><span class="si">{i}</span><span class="s2">,</span><span class="si">{j}</span><span class="s2">] ) &gt; sqrt( A[</span><span class="si">{i}</span><span class="s2">,</span><span class="si">{i}</span><span class="s2">] * A[</span><span class="si">{j}</span><span class="s2">,</span><span class="si">{j}</span><span class="s2">] ): </span><span class="si">{val1}</span><span class="s2"> vs. </span><span class="si">{val2}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span> <span class="n">i</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">j</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">),</span> <span class="n">val1</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="p">)),</span> <span class="n">val2</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="p">))</span> <span class="p">)</span> <span class="p">)</span>
                    <span class="n">success</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mf">0.0</span> <span class="ow">and</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mf">0.0</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="p">):</span> 
                <span class="k">if</span> <span class="n">warnAll</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;FAIL  abs( A[</span><span class="si">{i}</span><span class="s2">,</span><span class="si">{j}</span><span class="s2">] ) &gt; 0.5 * ( A[</span><span class="si">{i}</span><span class="s2">,</span><span class="si">{i}</span><span class="s2">] + A[</span><span class="si">{j}</span><span class="s2">,</span><span class="si">{j}</span><span class="s2">] ): </span><span class="si">{val1}</span><span class="s2"> vs. </span><span class="si">{val2}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span> <span class="n">i</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">j</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">),</span> <span class="n">val1</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="p">)),</span> <span class="n">val2</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="p">))</span> <span class="p">)</span> <span class="p">)</span>
                    <span class="n">success</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span> <span class="nb">abs</span><span class="p">(</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="p">),</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="p">)):</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;FAIL  abs( A[</span><span class="si">{i}</span><span class="s2">,</span><span class="si">{j}</span><span class="s2">] ) &gt; 0.5 * ( A[</span><span class="si">{i}</span><span class="s2">,</span><span class="si">{i}</span><span class="s2">] + A[</span><span class="si">{j}</span><span class="s2">,</span><span class="si">{j}</span><span class="s2">] ): </span><span class="si">{val1}</span><span class="s2"> vs. </span><span class="si">{val2}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span> <span class="n">i</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">j</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">),</span> <span class="n">val1</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="p">)),</span> <span class="n">val2</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="p">))</span> <span class="p">)</span> <span class="p">)</span>
                    <span class="n">success</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mf">0.0</span> <span class="ow">and</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mf">0.0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span> <span class="nb">abs</span><span class="p">(</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="p">),</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="p">)</span> <span class="p">):</span> 
                <span class="k">if</span> <span class="n">warnAll</span> <span class="ow">and</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;WARNING  abs( A[</span><span class="si">{i}</span><span class="s2">,</span><span class="si">{j}</span><span class="s2">] ) approx. sqrt( A[</span><span class="si">{i}</span><span class="s2">,</span><span class="si">{i}</span><span class="s2">] * A[</span><span class="si">{j}</span><span class="s2">,</span><span class="si">{j}</span><span class="s2">] ): </span><span class="si">{val1}</span><span class="s2"> vs. </span><span class="si">{val2}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span> <span class="n">i</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">j</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">),</span> <span class="n">val1</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="p">)),</span> <span class="n">val2</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="p">))</span> <span class="p">)</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">success</span></div>


<span class="c1"># ------------------------- covariance matrix utilities ------------------------- </span>
<div class="viewcode-block" id="covariance_to_correlation"><a class="viewcode-back" href="../../../../fudge/fudge.core.math.html#fudge.core.math.linearAlgebra.covariance_to_correlation">[docs]</a><span class="k">def</span> <span class="nf">covariance_to_correlation</span><span class="p">(</span> <span class="n">matrix</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert a covariance matrix to a correlation matrix&quot;&quot;&quot;</span>
    <span class="n">diag</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="n">matrix</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span> <span class="p">)</span>
    <span class="n">corr</span> <span class="o">=</span> <span class="n">matrix</span> <span class="o">/</span> <span class="n">diag</span> <span class="o">/</span> <span class="n">diag</span><span class="p">[:,</span><span class="n">numpy</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    <span class="c1"># now fix diagonal + remove any NaN (from div/0):</span>
    <span class="n">corr</span><span class="p">[</span> <span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">corr</span><span class="p">)),</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">corr</span><span class="p">))]</span> <span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="c1"># must be exactly 1</span>
    <span class="n">corr</span><span class="p">[</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">corr</span><span class="p">)</span> <span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">corr</span></div>

<div class="viewcode-block" id="correlation_to_covariance"><a class="viewcode-back" href="../../../../fudge/fudge.core.math.html#fudge.core.math.linearAlgebra.correlation_to_covariance">[docs]</a><span class="k">def</span> <span class="nf">correlation_to_covariance</span><span class="p">(</span> <span class="n">correlationMatrix</span><span class="p">,</span> <span class="n">variance</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a correlation matrix to a covariance matrix</span>

<span class="sd">    .. warning:: </span>
<span class="sd">        not implemented</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="covariance_to_relative"><a class="viewcode-back" href="../../../../fudge/fudge.core.math.html#fudge.core.math.linearAlgebra.covariance_to_relative">[docs]</a><span class="k">def</span> <span class="nf">covariance_to_relative</span><span class="p">(</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">rsd</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert an absolute covariance matrix to a relative covariance matrix&quot;&quot;&quot;</span>
    <span class="n">rsd</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">rsd</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">matrix</span> <span class="o">*</span> <span class="n">rsd</span> <span class="o">*</span> <span class="n">rsd</span><span class="p">[:,</span><span class="n">numpy</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span></div>

<div class="viewcode-block" id="relative_to_covariance"><a class="viewcode-back" href="../../../../fudge/fudge.core.math.html#fudge.core.math.linearAlgebra.relative_to_covariance">[docs]</a><span class="k">def</span> <span class="nf">relative_to_covariance</span><span class="p">(</span> <span class="n">relativeMatrix</span><span class="p">,</span> <span class="n">variance</span> <span class="p">):</span>  
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a relative covariance matrix to an absolute covariance matrix</span>

<span class="sd">    .. warning:: </span>
<span class="sd">        not implemented</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="relative_to_correlation"><a class="viewcode-back" href="../../../../fudge/fudge.core.math.html#fudge.core.math.linearAlgebra.relative_to_correlation">[docs]</a><span class="k">def</span> <span class="nf">relative_to_correlation</span><span class="p">(</span> <span class="n">relativeMatrix</span><span class="p">,</span> <span class="n">data</span> <span class="p">):</span>  
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a relative covariance matrix to a correlation matrix</span>

<span class="sd">    .. warning:: </span>
<span class="sd">        not implemented</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="correlation_to_relative"><a class="viewcode-back" href="../../../../fudge/fudge.core.math.html#fudge.core.math.linearAlgebra.correlation_to_relative">[docs]</a><span class="k">def</span> <span class="nf">correlation_to_relative</span><span class="p">(</span> <span class="n">correlationMatrix</span><span class="p">,</span> <span class="n">data</span> <span class="p">):</span>  
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a correlation matrix to a relative covariance matrix</span>

<span class="sd">    .. warning:: </span>
<span class="sd">        not implemented</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="affine_transform_covariance"><a class="viewcode-back" href="../../../../fudge/fudge.core.math.html#fudge.core.math.linearAlgebra.affine_transform_covariance">[docs]</a><span class="k">def</span> <span class="nf">affine_transform_covariance</span><span class="p">(</span> <span class="n">covarianceMatrix</span><span class="p">,</span> <span class="n">transformMatrix</span> <span class="p">):</span> 
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform an affine transformation to a covariance matrix, namely </span>
<span class="sd">    :math:`new = A^T \cdot old \cdot A`, where :math:`A` is a orthogonal matrix.</span>

<span class="sd">    .. warning:: </span>
<span class="sd">        not implemented</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="extract_uncertainty"><a class="viewcode-back" href="../../../../fudge/fudge.core.math.html#fudge.core.math.linearAlgebra.extract_uncertainty">[docs]</a><span class="k">def</span> <span class="nf">extract_uncertainty</span><span class="p">(</span> <span class="n">covarianceMatrix</span> <span class="p">):</span> 
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="n">extract_variance</span><span class="p">(</span> <span class="n">covarianceMatrix</span> <span class="p">)</span> <span class="p">)</span></div>

<div class="viewcode-block" id="extract_variance"><a class="viewcode-back" href="../../../../fudge/fudge.core.math.html#fudge.core.math.linearAlgebra.extract_variance">[docs]</a><span class="k">def</span> <span class="nf">extract_variance</span><span class="p">(</span> <span class="n">covarianceMatrix</span> <span class="p">):</span> 
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span> <span class="n">covarianceMatrix</span> <span class="p">)</span></div>

<span class="c1"># ------------------------- matrix diff ------------------------- </span>
<div class="viewcode-block" id="diff_matrices"><a class="viewcode-back" href="../../../../fudge/fudge.core.math.html#fudge.core.math.linearAlgebra.diff_matrices">[docs]</a><span class="k">def</span> <span class="nf">diff_matrices</span><span class="p">(</span> <span class="n">matrixOne</span><span class="p">,</span> <span class="n">matrixTwo</span><span class="p">,</span> <span class="n">printDiagnostics</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">quiet</span> <span class="o">=</span> <span class="kc">True</span> <span class="p">):</span>
    <span class="k">if</span> <span class="n">matrixOne</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">matrixTwo</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span> <span class="s1">&#39;matrices have different shapes: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">matrixOne</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; vs. &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">matrixTwo</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="p">)</span>
    <span class="n">varianceOne</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span> <span class="n">matrixOne</span> <span class="p">)</span>
    <span class="n">varianceTwo</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span> <span class="n">matrixTwo</span> <span class="p">)</span>
    <span class="n">minVariance</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span> <span class="n">varianceOne</span><span class="p">[</span> <span class="n">varianceOne</span><span class="o">&gt;</span><span class="mf">0.0</span> <span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">varianceTwo</span><span class="p">[</span> <span class="n">varianceOne</span><span class="o">&gt;</span><span class="mf">0.0</span> <span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="p">)</span>
    
    <span class="c1"># do the diffs</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="n">matrixOne</span> <span class="o">-</span> <span class="n">matrixTwo</span>
    <span class="n">reldiff</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span> <span class="n">diff</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span> <span class="n">matrixOne</span> <span class="p">)</span> <span class="p">)</span> 
    <span class="n">perdiff</span> <span class="o">=</span> <span class="mf">100.0</span> <span class="o">*</span> <span class="n">reldiff</span>
    
    <span class="c1"># stats on diff</span>
    <span class="n">maxPerVal</span> <span class="o">=</span> <span class="n">perdiff</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">minPerVal</span> <span class="o">=</span> <span class="n">perdiff</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
    <span class="n">maxAbsVal</span> <span class="o">=</span> <span class="n">diff</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">minAbsVal</span> <span class="o">=</span> <span class="n">diff</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
    <span class="n">absMaxAbsVal</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span> <span class="nb">map</span><span class="p">(</span> <span class="nb">abs</span><span class="p">,</span> <span class="p">(</span><span class="n">maxAbsVal</span><span class="p">,</span><span class="n">minAbsVal</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
    <span class="n">absMaxPerVal</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span> <span class="nb">map</span><span class="p">(</span> <span class="nb">abs</span><span class="p">,</span> <span class="p">(</span><span class="n">maxPerVal</span><span class="p">,</span><span class="n">minPerVal</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
    <span class="n">flawCount</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">printDiagnostics</span><span class="p">:</span> 
        <span class="nb">print</span><span class="p">(</span> <span class="s1">&#39;Matrix diff diagnostics:&#39;</span> <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span> <span class="s1">&#39;    * min non-zero variance in raw covariance matrices = &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span> <span class="n">minVariance</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">absMaxPerVal</span> <span class="o">&gt;</span> <span class="mf">1.0</span><span class="p">:</span>                  
            <span class="n">flawCount</span> <span class="o">+=</span><span class="mi">1</span> 
            <span class="nb">print</span> <span class="p">(</span> <span class="s1">&#39;    * max relative difference = &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span> <span class="n">absMaxPerVal</span> <span class="p">)</span> <span class="o">+</span><span class="s1">&#39;% &gt; 1.0%&#39;</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>    
            <span class="nb">print</span> <span class="p">(</span> <span class="s1">&#39;    * max relative difference = &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span> <span class="n">absMaxPerVal</span> <span class="p">)</span> <span class="o">+</span><span class="s1">&#39;%&#39;</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">absMaxAbsVal</span> <span class="o">&gt;</span> <span class="mf">0.01</span> <span class="o">*</span> <span class="n">minVariance</span><span class="p">:</span>   
            <span class="n">flawCount</span> <span class="o">+=</span><span class="mi">1</span> 
            <span class="nb">print</span> <span class="p">(</span> <span class="s1">&#39;    * max absolute difference = &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span> <span class="n">absMaxAbsVal</span> <span class="p">)</span> <span class="o">+</span><span class="s1">&#39; &gt; 1.0% * &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span> <span class="n">minVariance</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>    
            <span class="nb">print</span> <span class="p">(</span> <span class="s1">&#39;    * max absolute difference = &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span> <span class="n">absMaxAbsVal</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">flawCount</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> 
            <span class="nb">print</span> <span class="p">(</span> <span class="s1">&#39;    **** check this one ****&#39;</span> <span class="p">)</span>
            <span class="k">try</span><span class="p">:</span> 
                <span class="k">if</span> <span class="ow">not</span> <span class="n">quiet</span><span class="p">:</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">check_call</span><span class="p">(</span> <span class="p">[</span><span class="s1">&#39;say&#39;</span><span class="p">,</span> <span class="s1">&#39;holy&#39;</span><span class="p">,</span> <span class="s1">&#39;guacamole&#39;</span><span class="p">]</span> <span class="p">)</span>
            <span class="k">except</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">CallProcessError</span><span class="p">:</span> <span class="k">pass</span>
        
    <span class="c1"># return the numerical diffs</span>
    <span class="k">return</span> <span class="n">diff</span><span class="p">,</span> <span class="n">perdiff</span></div>

<span class="c1"># ------------------------- print/plot matrix ------------------------- </span>
<div class="viewcode-block" id="print_matrix"><a class="viewcode-back" href="../../../../fudge/fudge.core.math.html#fudge.core.math.linearAlgebra.print_matrix">[docs]</a><span class="k">def</span> <span class="nf">print_matrix</span><span class="p">(</span> <span class="n">M</span><span class="p">,</span> <span class="n">pretty</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">elementSize</span><span class="o">=</span><span class="mi">8</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Simple matrix printer, makes little attempt to be pretty, but does print huge matrices&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">):</span>
            <span class="k">if</span> <span class="n">pretty</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span> <span class="s1">&#39;</span><span class="si">{:.2g}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span> <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="p">)</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">elementSize</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span> <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">],</span><span class="s1">&#39;  &#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">()</span></div>

<div class="viewcode-block" id="print_vector"><a class="viewcode-back" href="../../../../fudge/fudge.core.math.html#fudge.core.math.linearAlgebra.print_vector">[docs]</a><span class="k">def</span> <span class="nf">print_vector</span><span class="p">(</span> <span class="n">v</span> <span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="n">v</span> <span class="p">)</span> <span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="s1">&#39;  &#39;</span><span class="p">,</span> <span class="p">)</span>
    <span class="nb">print</span><span class="p">()</span></div>

<div class="viewcode-block" id="print_eigenvalues"><a class="viewcode-back" href="../../../../fudge/fudge.core.math.html#fudge.core.math.linearAlgebra.print_eigenvalues">[docs]</a><span class="k">def</span> <span class="nf">print_eigenvalues</span><span class="p">(</span> <span class="n">A</span> <span class="p">):</span>
    <span class="n">e</span><span class="p">,</span> <span class="n">O</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span> <span class="n">A</span> <span class="p">)</span>
    <span class="n">myEVs</span> <span class="o">=</span> <span class="p">[</span> <span class="n">x</span><span class="o">.</span><span class="n">real</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="p">]</span>
    <span class="n">myEVs</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">myEVs</span><span class="p">]</span> <span class="p">)</span> <span class="p">)</span></div>

<div class="viewcode-block" id="plot_matrix"><a class="viewcode-back" href="../../../../fudge/fudge.core.math.html#fudge.core.math.linearAlgebra.plot_matrix">[docs]</a><span class="k">def</span> <span class="nf">plot_matrix</span><span class="p">(</span> <span class="n">m</span><span class="p">,</span> <span class="n">title</span> <span class="o">=</span> <span class="s2">&quot;a matrix&quot;</span><span class="p">,</span> <span class="n">scaling</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scalingFloor</span><span class="o">=</span><span class="mf">0.0</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :param m: a numpy.mat instance</span>
<span class="sd">    :param title: a string to use as the plot title</span>
<span class="sd">    :param scaling: either None, &#39;log&#39;, or &#39;asinh&#39;</span>
<span class="sd">                    this scales the value of the matrix plotted in the following ways ::</span>
<span class="sd">                        </span>
<span class="sd">                        * None : no scaling</span>
<span class="sd">                        * &#39;log&#39; : each element is plotted as ln(x) -- good for covariances</span>
<span class="sd">                          which must always be positive semidefinite.  If scalingFloor &gt; 0.0, </span>
<span class="sd">                          than we do ln(max(x, scalingFloor)).</span>
<span class="sd">                        * &#39;asinh&#39; : each element is scaled as asinh(x).  This exaggerates </span>
<span class="sd">                          scale for values of abs(x)&lt;1.0.</span>
<span class="sd">    :param scalingFloor: the minimum value of each element that gets plotted.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
    <span class="c1"># Make plot with vertical (default) colorbar</span>
    <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">scaling</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">mm</span> <span class="o">=</span> <span class="n">m</span>
    <span class="k">elif</span> <span class="n">scaling</span> <span class="o">==</span> <span class="s1">&#39;asinh&#39;</span><span class="p">:</span> <span class="n">mm</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asinh</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">scaling</span> <span class="o">==</span> <span class="s1">&#39;log&#39;</span><span class="p">:</span> 
        <span class="n">mm</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span> <span class="n">m</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">scalingFloor</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span> <span class="n">mm</span><span class="p">[</span> <span class="n">mm</span> <span class="o">&lt;</span> <span class="n">scalingFloor</span> <span class="p">]</span> <span class="o">=</span> <span class="n">scalingFloor</span>
        <span class="n">mm</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span> <span class="n">mm</span> <span class="p">)</span>
    <span class="n">maxAbsVal</span> <span class="o">=</span> <span class="n">mm</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">minAbsVal</span> <span class="o">=</span> <span class="n">mm</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
    <span class="n">cax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">scaling</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">ticks</span> <span class="o">=</span> <span class="p">[</span><span class="n">minAbsVal</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">maxAbsVal</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">maxAbsVal</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">scaling</span> <span class="o">==</span> <span class="s1">&#39;asinh&#39;</span><span class="p">:</span> <span class="n">ticks</span> <span class="o">=</span> <span class="p">[</span> <span class="n">minAbsVal</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="p">(</span> <span class="n">maxAbsVal</span><span class="o">-</span><span class="n">minAbsVal</span> <span class="p">)</span><span class="o">/</span><span class="mi">9</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> <span class="p">]</span> <span class="o">+</span> <span class="p">[</span> <span class="n">maxAbsVal</span> <span class="p">]</span>
    <span class="k">elif</span> <span class="n">scaling</span> <span class="o">==</span> <span class="s1">&#39;log&#39;</span><span class="p">:</span> <span class="n">ticks</span> <span class="o">=</span> <span class="p">[</span> <span class="n">minAbsVal</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="p">(</span> <span class="n">maxAbsVal</span><span class="o">-</span><span class="n">minAbsVal</span> <span class="p">)</span><span class="o">/</span><span class="mi">9</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> <span class="p">]</span> <span class="o">+</span> <span class="p">[</span> <span class="n">maxAbsVal</span> <span class="p">]</span>
    <span class="c1"># Add colorbar, make sure to specify tick locations to match desired ticklabels</span>
    <span class="n">cbar</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">cax</span><span class="p">,</span> <span class="n">ticks</span><span class="o">=</span><span class="n">ticks</span><span class="p">)</span>
    <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">(</span> <span class="p">[</span> <span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">ticks</span> <span class="p">]</span> <span class="p">)</span><span class="c1"># vertically oriented colorbar          </span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>

<div class="viewcode-block" id="plot_bad_eigenspaces"><a class="viewcode-back" href="../../../../fudge/fudge.core.math.html#fudge.core.math.linearAlgebra.plot_bad_eigenspaces">[docs]</a><span class="k">def</span> <span class="nf">plot_bad_eigenspaces</span><span class="p">(</span> <span class="n">A</span> <span class="p">):</span>
    <span class="n">e</span><span class="p">,</span> <span class="n">O</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span> <span class="n">A</span> <span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">eigenvectors_from_orthoganal_matrix</span><span class="p">(</span> <span class="n">O</span> <span class="p">)</span>
    <span class="n">ndim</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span> <span class="n">ndim</span><span class="p">,</span> <span class="n">ndim</span> <span class="p">)</span> <span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">ndim</span> <span class="p">):</span>
        <span class="k">if</span> <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mf">0.0</span><span class="p">:</span> <span class="k">continue</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">B</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">T</span> <span class="p">)</span> <span class="c1"># += operator causes casting exception for obscure numpy reasons</span>
    <span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;Num of elements in original:&quot;</span><span class="p">,</span> <span class="nb">pow</span><span class="p">(</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span> <span class="p">)</span> <span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;Num of elements in bad-space:&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span> <span class="n">B</span><span class="p">[</span> <span class="n">B</span><span class="o">&gt;</span><span class="mf">0.0</span> <span class="p">]</span> <span class="p">)</span> <span class="p">)</span>
    <span class="n">plot_matrix</span><span class="p">(</span> <span class="n">B</span> <span class="p">)</span></div>
    

<span class="c1"># ------------------------- matrix composition through stacking ------------------------- </span>
<div class="viewcode-block" id="stackVertical"><a class="viewcode-back" href="../../../../fudge/fudge.core.math.html#fudge.core.math.linearAlgebra.stackVertical">[docs]</a><span class="k">def</span> <span class="nf">stackVertical</span><span class="p">(</span> <span class="n">l</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :param l: a list of numpy matrices, each with same `shape[1]` (i.e. same number of columns).  Elements equal to None are ignored</span>
<span class="sd">    </span>
<span class="sd">    :returns: a matrix packed as follows ::</span>

<span class="sd">            [  l[0]  ]</span>
<span class="sd">            [ ------ ]</span>
<span class="sd">            [  l[1]  ]</span>
<span class="sd">            [ ------ ]</span>
<span class="sd">            [    :   ]</span>
<span class="sd">            [ ------ ]</span>
<span class="sd">            [ l[n-1] ]</span>

<span class="sd">        where n is the number of non-None elements in l</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span> <span class="nb">filter</span><span class="p">(</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="n">l</span> <span class="p">)</span> <span class="p">)</span></div>
        
<div class="viewcode-block" id="stackHorizontal"><a class="viewcode-back" href="../../../../fudge/fudge.core.math.html#fudge.core.math.linearAlgebra.stackHorizontal">[docs]</a><span class="k">def</span> <span class="nf">stackHorizontal</span><span class="p">(</span> <span class="n">l</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :param l: a list of numpy matrices, each with same shape[0] (i.e. same number of rows).  Elements equal to None are ignored</span>
<span class="sd">    </span>
<span class="sd">    A note about numpy.matrix shapes and indexing ::</span>
<span class="sd">    </span>
<span class="sd">        a.shape = [ nRows, nCols ]</span>
<span class="sd">    </span>
<span class="sd">    So, we index through ``a[ iRow, iCol ]``</span>
<span class="sd">    </span>
<span class="sd">    :returns: a matrix packed as follows ::</span>
<span class="sd">        </span>
<span class="sd">            [  l[0]  | l[1]  | ... | l[n-1] ]</span>

<span class="sd">        where n is the number of non-None elements in l</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span> <span class="nb">filter</span><span class="p">(</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="n">l</span> <span class="p">)</span> <span class="p">)</span></div>

<div class="viewcode-block" id="stackDiagonal"><a class="viewcode-back" href="../../../../fudge/fudge.core.math.html#fudge.core.math.linearAlgebra.stackDiagonal">[docs]</a><span class="k">def</span> <span class="nf">stackDiagonal</span><span class="p">(</span> <span class="n">l</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :param l: a list of numpy matrices, elements equal to None are ignored</span>
<span class="sd">        </span>
<span class="sd">    A note about numpy.matrix shapes and indexing ::</span>

<span class="sd">        a.shape = [ nRows, nCols ]</span>

<span class="sd">    So, we index through ``a[ iRow, iCol ]``</span>
<span class="sd">        </span>
<span class="sd">    :returns: a matrix packed as follows ::</span>
<span class="sd">    </span>
<span class="sd">            [  l[0]  |  0.0  |  0.0 | ... |   0.0  ]</span>
<span class="sd">            [ ------ | ----- | ---- | ... | ------ ]</span>
<span class="sd">            [   0.0  | l[1]  |  0.0 | ... |   0.0  ]</span>
<span class="sd">            [ ------ | ----- | ---- | ... | ------ ]</span>
<span class="sd">            [   0.0  |  0.0  | l[2] | ... |   0.0  ]</span>
<span class="sd">            [ ------ | ----- | ---- | ... | ------ ]</span>
<span class="sd">            [    :   |   :   |  :   |     |    :   ]</span>
<span class="sd">            [ ------ | ----- | ---- | ... | ------ ]</span>
<span class="sd">            [   0.0  |  0.0  |  0.0 | ... | l[n-1] ]</span>

<span class="sd">        where n is the number of non-None elements in l</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Determine the size of the final results matrix</span>
    <span class="n">newShape</span> <span class="o">=</span> <span class="p">[</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">]</span>
    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span> 
        <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">continue</span>
        <span class="n">newShape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">m</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>       <span class="c1"># Keep adding to the number of rows</span>
        <span class="n">newShape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">m</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>       <span class="c1"># Keep adding to the number of columns</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="n">newShape</span> <span class="p">)</span>

    <span class="c1"># Add matrix to results </span>
    <span class="n">iStart</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">jStart</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span> 
        <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">continue</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">m</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">):</span>     <span class="c1"># Loop over rows</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">m</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">):</span> <span class="c1"># Loop over columns</span>
                <span class="n">result</span><span class="p">[</span> <span class="n">iStart</span><span class="o">+</span><span class="n">i</span><span class="p">,</span> <span class="n">jStart</span><span class="o">+</span><span class="n">j</span> <span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="p">]</span>
        <span class="n">iStart</span> <span class="o">+=</span> <span class="n">m</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>              <span class="c1"># Compute new start row for next matrix</span>
        <span class="n">jStart</span> <span class="o">+=</span> <span class="n">m</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>              <span class="c1"># Compute new start column for next matrix</span>
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span> <span class="n">result</span> <span class="p">)</span></div>

        
<span class="c1"># ------------------------- constrainted generalized least-squares ------------------------- </span>
<div class="viewcode-block" id="cglsqrSolve"><a class="viewcode-back" href="../../../../fudge/fudge.core.math.html#fudge.core.math.linearAlgebra.cglsqrSolve">[docs]</a><span class="k">def</span> <span class="nf">cglsqrSolve</span><span class="p">(</span> <span class="n">data</span><span class="p">,</span> <span class="n">dataUnc</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dataCov</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> \
                 <span class="n">kernel</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> \
                 <span class="n">prior</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">priorCov</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> \
                 <span class="n">constraintVector</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">constraintMatrix</span> <span class="o">=</span> <span class="kc">None</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Constrainted Generalized Least-Squares Solver, based on CorAL routines.</span>
<span class="sd">    We are minimizing the following ``chi^2`` (assuming Gaussian statistics) ::</span>
<span class="sd">    </span>
<span class="sd">        chi^2 = ( data - kernel * model ) * ( dataCov )^-1 * ( data - kernel * model )^T +</span>
<span class="sd">                ( prior - model ) * ( priorCov )^2 * ( prior - model )^T</span>
<span class="sd">    </span>
<span class="sd">    subject to the constraint ::</span>

<span class="sd">        constraintVector = constraintMatrix * model</span>

<span class="sd">    Here, ``^T`` means matrix transpose and ``^-1`` means a (generalized) matrix inverse.</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    :returns: a tuple: ``(model, modelCovariance)``:</span>
<span class="sd">    </span>
<span class="sd">        - ``model`` : a M x 1 numpy.mat containing the extracted model parameter</span>
<span class="sd">        </span>
<span class="sd">        - ``modelCovariance`` : a M x M numpy.mat containing the covariance on the extracted model paremeters</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    **Manditory arguments:**</span>
<span class="sd">    </span>
<span class="sd">        - **data** : a N x 1 ``numpy.mat`` (a vector!) containing the data to fit</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    **Optional arguments:**</span>
<span class="sd">    </span>
<span class="sd">        - **kernel** : a N x M ``numpy.mat`` that maps the model parameters into the data space.  If this </span>
<span class="sd">                   is not given, it is assumed that ``kernel`` = the identity matrix and N == M.</span>
<span class="sd">                   </span>
<span class="sd">        - either</span>
<span class="sd">        </span>
<span class="sd">            -- **dataUnc** : a N x 1 ``numpy.mat`` (a vector) of uncertianties on the data vector.</span>
<span class="sd">                         This will be converted to the ``dataCov`` if the ``dataCov`` is not specified.</span>
<span class="sd">                         </span>
<span class="sd">            -- **dataCov** : a N x N ``numpy.mat`` containing the data&#39;s covariance</span>
<span class="sd">                         If this is specified, the ``dataUnc`` will be ignored.</span>
<span class="sd">                         </span>
<span class="sd">            If neither the ``dataUnc`` or ``dataCov`` are specified, we will set the covariance to the </span>
<span class="sd">            identity matrix. Instead of minimizing the ``chi^2``, you will minimize ::</span>
<span class="sd">            </span>
<span class="sd">                | data - kernel * model |^2</span>
<span class="sd">                </span>
<span class="sd">        - both of</span>
<span class="sd">        </span>
<span class="sd">            -- **prior**    : a M x 1 ``numpy.mat`` containing the fitting model&#39;s apriori values</span>
<span class="sd">            </span>
<span class="sd">            -- **priorCov** : a M x M ``numpy.mat`` containing the fitting model&#39;s apriori covariance</span>
<span class="sd">            </span>
<span class="sd">            If either one is not included, the second term in the ``chi^2`` will be ignored.</span>
<span class="sd">            </span>
<span class="sd">        - both of</span>
<span class="sd">        </span>
<span class="sd">            -- **constraintVector** : a L x 1 ``numpy.mat`` containing values to constrain the model to match</span>
<span class="sd">            </span>
<span class="sd">            -- **constraintMatrix** : a L x M ``numpy.mat`` relating the model parameters to the ``constraintVector`` values </span>
<span class="sd">            </span>
<span class="sd">            If either one is not included, the constraint equation will be ignored.</span>
<span class="sd">            </span>
<span class="sd">        </span>
<span class="sd">    .. rubric:: HOW IT WORKS</span>
<span class="sd">        </span>
<span class="sd">    Because the data and the prior are independent and not correlated, we will solve the minimization problem by</span>
<span class="sd">    stacking the prior part and the data part to construct a new ``chi^2`` to minimize ::</span>
<span class="sd">    </span>
<span class="sd">                  [ data  ]             [ dataCov |     0    ]                [ kernel ]</span>
<span class="sd">        newData = [ ----- ],   newCov = [ --------|--------- ],   newKernel = [ ------ ]</span>
<span class="sd">                  [ prior ]             [    0    | priorCov ]                [    1   ]</span>
<span class="sd">    </span>
<span class="sd">    With these, the ``chi^2`` may be rewritten as ::</span>
<span class="sd">    </span>
<span class="sd">        chi^2 = ( newData - newKernel * model )^T * newCov^-1 * ( newData - newKernel * model )</span>

<span class="sd">    The solution to the minimization problem is the well known normal equation ::</span>
<span class="sd">    </span>
<span class="sd">        modelCov = ( newKernel * newCov^-1 * newKernel^T )^-1</span>
<span class="sd">    </span>
<span class="sd">        model = modelCov * newKernel^T * newCov^-1 * newData</span>
<span class="sd">        </span>
<span class="sd">    Implementing this case where no uncertainty or covariance is given on the data vector is straightforward.</span>
<span class="sd">    In this case, we are solving the simple least-squares problem ::</span>
<span class="sd">        </span>
<span class="sd">        minimize:   | data - kernel * model |^2 + ( model - prior )*( priorCov )^-1*( model - prior )^T</span>
<span class="sd">    </span>
<span class="sd">    In other words, we use a ``dataCov = 1``, the identity matrix.</span>
<span class="sd">    </span>
<span class="sd">    We comment that the equality constraints can be added in much this same way by adding the constraint </span>
<span class="sd">    vector as a fake data set, with infinitesimal uncertainties ::</span>
<span class="sd">    </span>
<span class="sd">        chi^2 += lambda * ( constraintVector - constraintMatrix * model )^2    </span>
<span class="sd">    </span>
<span class="sd">    with lambda :math:`\\rightarrow\\infty`.  This approach works, but can lead to numerical instabilities by </span>
<span class="sd">    adding big number to the original covariances, then taking inverses.  </span>
<span class="sd">    </span>
<span class="sd">        </span>
<span class="sd">    So, rather than doing this, we will do something different (using Lagrange multipliers).  </span>
<span class="sd">    We use the &quot;newData&quot; etc. above and the corresponding ``chi^2`` ::</span>
<span class="sd">    </span>
<span class="sd">        chi^2 = ( newData - newKernel * model )^T * newCov^-1 * ( newData - newKernel * model )</span>
<span class="sd">    </span>
<span class="sd">    subject to the constraint ::</span>
<span class="sd">    </span>
<span class="sd">        constraintMatrix * model = constraintVector</span>

<span class="sd">    Here we are really solving the quadratic optimization problem here and the way to solve it is with </span>
<span class="sd">    Lagrange multipliers.  So, extend the model thusly ::</span>

<span class="sd">                   [   model  ]</span>
<span class="sd">        newModel = [ ---------]</span>
<span class="sd">                   [  lambda  ]</span>

<span class="sd">    Here lambda is the vector of Lagrange multipliers ( there are L of them ).  </span>
<span class="sd">    Minimizing the chi^2, we find the usual normal equation ::</span>
<span class="sd">    </span>
<span class="sd">        ( newKernel * newCov^-1 * newKernel^T ) * model = newKernel^T * newCov^-1 * newData</span>

<span class="sd">    So, we&#39;ll stack the normal and constraint equations::</span>

<span class="sd">            [ newKernel * newCov^-1 * newKernel^T | constraintMatrix^T ]</span>
<span class="sd">        A = [ ------------------------------------|------------------- ]</span>
<span class="sd">            [          constraintMatrix           |         0          ]</span>

<span class="sd">        and</span>

<span class="sd">            [ newKernel^T * newCov^-1 * newData ]</span>
<span class="sd">        y = [ --------------------------------- ]</span>
<span class="sd">            [         constraintVector          ]</span>

<span class="sd">        giving,</span>
<span class="sd">    </span>
<span class="sd">        A * newModel = y</span>

<span class="sd">    We can solve this a few ways:</span>
<span class="sd">    </span>
<span class="sd">        1.  Performing a QR decomposition on :math:`A` gives :math:`A = QR` (using ``numpy.linalg.qr``) and ::</span>
<span class="sd">        </span>
<span class="sd">                R * newModel = Q^T * y</span>
<span class="sd">        </span>
<span class="sd">            We can then use the ``numpy.linalg.tensorsolve`` for the ``newModel`` ::</span>
<span class="sd">            </span>
<span class="sd">                newModel = numpy.linalg.tensorsolve( R, Q^T * y )</span>
<span class="sd">                </span>
<span class="sd">        2.  Just doing a Moore-Penrose inversion (uses SVD) ::</span>
<span class="sd">        </span>
<span class="sd">                newModel = A^-1 * y</span>

<span class="sd">    But now the meaning of A is clear: it is an &quot;extended&quot; covariance where the first </span>
<span class="sd">    M x M block is the covariance of the model and the rest are the covariance of the </span>
<span class="sd">    Lagrange multipliers (which are disposable).</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">    .. rubric:: TESTING</span>
<span class="sd">        </span>
<span class="sd">    Note on construction of dataCov with uncertainty:</span>
<span class="sd">        &gt;&gt;&gt; unc = numpy.mat( [ [ 1.0, 1.0, 2.0 ] ] )</span>
<span class="sd">        &gt;&gt;&gt; diagCov = numpy.diag( [ unc[0,i]*unc[0,i] for i in range( unc.shape[1] ) ] )</span>
<span class="sd">        &gt;&gt;&gt; diagCov</span>
<span class="sd">        array([ [ 1.,  0.,  0.],</span>
<span class="sd">                [ 0.,  1.,  0.],</span>
<span class="sd">                [ 0.,  0.,  4.]])</span>
<span class="sd">                </span>
<span class="sd">    Also, without specifying an uncertainty or covariance, one finds:</span>
<span class="sd">        &gt;&gt;&gt; dataCov = numpy.identity( data.shape[1] )</span>
<span class="sd">        &gt;&gt;&gt; dataCov</span>
<span class="sd">        array([ [ 1.,  0.,  0.],</span>
<span class="sd">                [ 0.,  1.,  0.],</span>
<span class="sd">                [ 0.,  0.,  1.]])</span>
<span class="sd">                </span>
<span class="sd">    So, both alternate methods of defining the data covariance function correctly.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">    **Define the problem**</span>

<span class="sd">    Define a test problem:</span>
<span class="sd">        &gt;&gt;&gt; answer = numpy.matrix([[ 1.34883721,-0.69767442, 0.34883721, 0.1, 42.0]])</span>
<span class="sd">        &gt;&gt;&gt; kernel = numpy.matrix( [ [ 1.0, 2.0, 3.0, 0.0, 0.0 ], [ 2.0, 3.0, 4.0, 0.0, 0.0 ], [ 4.5, 5.4, 2.0, 0.0, 0.0 ] ] ) # Note: lower two subspaces map to 0</span>
<span class="sd">        &gt;&gt;&gt; kernel * answer.T </span>
<span class="sd">            matrix([[ 1.],</span>
<span class="sd">                    [ 2.],</span>
<span class="sd">                    [ 3.]])</span>
<span class="sd">        </span>
<span class="sd">    Test data:</span>
<span class="sd">        &gt;&gt;&gt; data = numpy.mat([ [ 1.1, 1.89, 3.05 ] ] )</span>
<span class="sd">        &gt;&gt;&gt; dataCov = numpy.mat([ [ 1.0, 0.1, 0.1 ], [ 0.1, 1.0, 0.1 ] , [ 0.1, 0.1, 1.0 ] ] )</span>
<span class="sd">        </span>
<span class="sd">    Constrain the last two elements of the model to add to 42.1:</span>
<span class="sd">        &gt;&gt;&gt; constraintVector = numpy.matrix( [[ 42.1 ]] )</span>
<span class="sd">        &gt;&gt;&gt; constraintMatrix = numpy.matrix( [[ 0.0, 0.0, 0.0, 1.0, 1.0 ]] )</span>
<span class="sd">        </span>
<span class="sd">    A apriori guess to the result (good to &lt; 5% in all 4 dimensions):</span>
<span class="sd">        &gt;&gt;&gt; prior = numpy.matrix([[ 1.3, -0.7, 0.3, 0.11, 42.2 ]])</span>
<span class="sd">        &gt;&gt;&gt; priorCov = numpy.matrix([</span>
<span class="sd">            [  0.07      ,   0.        ,   0.        ,   0.        ,   0.        ],</span>
<span class="sd">            [  0.        ,   0.5       ,   0.        ,   0.        ,   0.        ],</span>
<span class="sd">            [  0.        ,   0.        ,   0.4       ,   0.        ,   0.        ],</span>
<span class="sd">            [  0.        ,   0.        ,   0.        ,   0.1       ,   0.        ],</span>
<span class="sd">            [  0.        ,   0.        ,   0.        ,   0.        ,  20.        ]])</span>
<span class="sd">            </span>
<span class="sd">    This might be a little too good...</span>
<span class="sd">        </span>

<span class="sd">    **A data only solution**</span>

<span class="sd">    Using data only, we get:</span>
<span class="sd">        &gt;&gt;&gt; modelCov = numpy.linalg.pinv( kernel.T * numpy.linalg.pinv( dataCov ) * kernel )</span>
<span class="sd">        &gt;&gt;&gt; modelCov</span>
<span class="sd">        matrix([[ 19.2436993 , -17.66414278,   4.23904813,   0.        ,   0.        ],</span>
<span class="sd">                [-17.66414278,  16.28177393,  -3.95484045,   0.        ,   0.        ],</span>
<span class="sd">                [  4.23904813,  -3.95484045,   1.03439697,   0.        ,   0.        ],</span>
<span class="sd">                [  0.        ,   0.        ,   0.        ,   0.        ,   0.        ],</span>
<span class="sd">                [  0.        ,   0.        ,   0.        ,   0.        ,   0.        ]])</span>
<span class="sd">        &gt;&gt;&gt; model = modelCov * kernel.T * numpy.linalg.pinv( dataCov ) * data.T</span>
<span class="sd">        &gt;&gt;&gt; model</span>
<span class="sd">        matrix([[ 0.66232558],</span>
<span class="sd">                [-0.05465116],</span>
<span class="sd">                [ 0.18232558],</span>
<span class="sd">                [ 0.        ],</span>
<span class="sd">                [ 0.        ]])</span>
<span class="sd">    </span>
<span class="sd">    Note: the last to elements in the model are zero because there was no way to control them given the kernel in play.  </span>
<span class="sd">    Without a handle on the last two elements, the fitting cannot do better than this.</span>
<span class="sd">        </span>

<span class="sd">    **A data+prior solution**</span>

<span class="sd">    With data+prior, we first repack things:</span>
<span class="sd">        &gt;&gt;&gt; newData = stackHorizontal( [ data, prior ] )</span>
<span class="sd">        &gt;&gt;&gt; newData</span>
<span class="sd">        matrix([[  1.1 ,   1.89,   3.05,   1.3 ,  -0.7 ,   0.3 ,   0.11,  42.2 ]])</span>
<span class="sd">        &gt;&gt;&gt; newKernel = stackVertical( [ kernel, numpy.identity( prior.shape[1] ) ] )</span>
<span class="sd">        &gt;&gt;&gt; newKernel</span>
<span class="sd">        matrix([[ 1. ,  2. ,  3. ,  0. ,  0. ],</span>
<span class="sd">                [ 2. ,  3. ,  4. ,  0. ,  0. ],</span>
<span class="sd">                [ 4.5,  5.4,  2. ,  0. ,  0. ],</span>
<span class="sd">                [ 1. ,  0. ,  0. ,  0. ,  0. ],</span>
<span class="sd">                [ 0. ,  1. ,  0. ,  0. ,  0. ],</span>
<span class="sd">                [ 0. ,  0. ,  1. ,  0. ,  0. ],</span>
<span class="sd">                [ 0. ,  0. ,  0. ,  1. ,  0. ],</span>
<span class="sd">                [ 0. ,  0. ,  0. ,  0. ,  1. ]])</span>
<span class="sd">                </span>
<span class="sd">    Now, we can rework the algorithm above:</span>
<span class="sd">        &gt;&gt;&gt; newCov = stackVertical( [ stackHorizontal( [ dataCov, numpy.zeros( ( dataCov.shape[0], priorCov.shape[1] ) ) ] ), stackHorizontal( [ numpy.zeros( ( priorCov.shape[0], dataCov.shape[1] ) ), priorCov ] ) ] )</span>
<span class="sd">        &gt;&gt;&gt; newCov</span>
<span class="sd">        matrix([[  1.  ,   0.1 ,   0.1 ,   0.  ,   0.  ,   0.  ,   0.  ,   0.  ],</span>
<span class="sd">                [  0.1 ,   1.  ,   0.1 ,   0.  ,   0.  ,   0.  ,   0.  ,   0.  ],</span>
<span class="sd">                [  0.1 ,   0.1 ,   1.  ,   0.  ,   0.  ,   0.  ,   0.  ,   0.  ],</span>
<span class="sd">                [  0.  ,   0.  ,   0.  ,   0.07,   0.  ,   0.  ,   0.  ,   0.  ],</span>
<span class="sd">                [  0.  ,   0.  ,   0.  ,   0.  ,   0.5 ,   0.  ,   0.  ,   0.  ],</span>
<span class="sd">                [  0.  ,   0.  ,   0.  ,   0.  ,   0.  ,   0.4 ,   0.  ,   0.  ],</span>
<span class="sd">                [  0.  ,   0.  ,   0.  ,   0.  ,   0.  ,   0.  ,   0.1 ,   0.  ],</span>
<span class="sd">                [  0.  ,   0.  ,   0.  ,   0.  ,   0.  ,   0.  ,   0.  ,  20.  ]])</span>
<span class="sd">        &gt;&gt;&gt; modelCov = numpy.linalg.pinv( newKernel.T * numpy.linalg.pinv( newCov ) * newKernel ) # use Moore-Penrose generalized inverse (ie SVD inversion)</span>
<span class="sd">        &gt;&gt;&gt; modelCov</span>
<span class="sd">        matrix([[  6.30909610e-02,  -5.01795451e-02,   5.99338297e-03,  0.00000000e+00,   0.00000000e+00],</span>
<span class="sd">                [ -5.01795451e-02,   9.30182090e-02,  -5.02878134e-02,  0.00000000e+00,   0.00000000e+00],</span>
<span class="sd">                [  5.99338297e-03,  -5.02878134e-02,   7.63220083e-02,  0.00000000e+00,   0.00000000e+00],</span>
<span class="sd">                [  0.00000000e+00,   0.00000000e+00,   0.00000000e+00,  1.00000000e-01,   0.00000000e+00],</span>
<span class="sd">                [  0.00000000e+00,   0.00000000e+00,   0.00000000e+00,  0.00000000e+00,   2.00000000e+01]])</span>
<span class="sd">        &gt;&gt;&gt; model = modelCov * newKernel.T * numpy.linalg.pinv( newCov ) * newData.T</span>
<span class="sd">        &gt;&gt;&gt; model</span>
<span class="sd">        matrix([[  1.30359097],</span>
<span class="sd">                [ -0.64662084],</span>
<span class="sd">                [  0.32428234],</span>
<span class="sd">                [  0.11      ],</span>
<span class="sd">                [ 42.2       ]])</span>
<span class="sd">                </span>
<span class="sd">    A good prior gives a good result:</span>
<span class="sd">        &gt;&gt;&gt; residual = data.T - kernel * model</span>
<span class="sd">        &gt;&gt;&gt; residual</span>
<span class="sd">        matrix([[ 0.11680368],</span>
<span class="sd">                [-0.0744488 ],</span>
<span class="sd">                [ 0.02702848]])</span>
<span class="sd">        &gt;&gt;&gt; error = answer.T - model</span>
<span class="sd">        &gt;&gt;&gt; error</span>
<span class="sd">        matrix([[ 0.04524624],</span>
<span class="sd">                [-0.05105358],</span>
<span class="sd">                [ 0.02455487],</span>
<span class="sd">                [-0.01      ],</span>
<span class="sd">                [-0.2       ]])</span>
<span class="sd">                </span>
<span class="sd">    The final uncertainty is not bad:</span>
<span class="sd">        &gt;&gt;&gt; uncertainty = [ sqrt(modelCov[i,i]) for i in range( modelCov.shape[0] ) ]</span>
<span class="sd">        &gt;&gt;&gt; uncertainty</span>
<span class="sd">            [0.25117914115531315, 0.30498886706247513, 0.2762643810785747, 0.31622776601683794, 4.47213595499958]</span>
<span class="sd">        </span>

<span class="sd">    **A data+constraint+prior solution**</span>

<span class="sd">    Next, with everything (data+constraint+prior)...  First we stack the normal equation and the constraint equation:</span>
<span class="sd">        &gt;&gt;&gt; reallyNewData = stackHorizontal( [ ( newKernel.T * numpy.linalg.pinv( newCov ) * newData.T ).T, constraintVector ] )</span>
<span class="sd">        &gt;&gt;&gt; reallyNewData</span>
<span class="sd">        matrix([[ 35.04920635,  19.82814815,  14.56111111, 1.1, 2.11,  42.1 ]])</span>
<span class="sd">        &gt;&gt;&gt; reallyNewKernel = stackVertical( [ newKernel.T*numpy.linalg.pinv( newCov )*newKernel, constraintMatrix ] )</span>
<span class="sd">        &gt;&gt;&gt; reallyNewKernel</span>
<span class="sd">        matrix([[ 37.13293651,  28.66666667,  15.97222222,   0.        ,   0.        ],</span>
<span class="sd">                [ 28.66666667,  38.82962963,  23.33333333,   0.        ,   0.        ],</span>
<span class="sd">                [ 15.97222222,  23.33333333,  27.22222222,   0.        ,   0.        ],</span>
<span class="sd">                [  0.        ,   0.        ,   0.        ,  10.        ,   0.        ],</span>
<span class="sd">                [  0.        ,   0.        ,   0.        ,   0.        ,   0.05      ],</span>
<span class="sd">                [  0.        ,   0.        ,   0.        ,   1.        ,   1.        ]])</span>
<span class="sd">                </span>
<span class="sd">    Now we just invert the reallyNewKernel </span>
<span class="sd">        &gt;&gt;&gt; model = numpy.linalg.pinv( reallyNewKernel ) * reallyNewData.T</span>
<span class="sd">        matrix([[  1.30359097],</span>
<span class="sd">                [ -0.64662084],</span>
<span class="sd">                [  0.32428234],</span>
<span class="sd">                [  0.10999476],</span>
<span class="sd">                [ 41.99052891]])</span>
<span class="sd">                </span>
<span class="sd">    The fit is just a little better than with the prior alone -- but now the last element is nailed down:</span>
<span class="sd">        &gt;&gt;&gt; residual = data.T - kernel*model</span>
<span class="sd">        matrix([[ 0.11680368],</span>
<span class="sd">                [-0.0744488 ],</span>
<span class="sd">                [ 0.02702848]])</span>
<span class="sd">        &gt;&gt;&gt; error = answer.T - model</span>
<span class="sd">        &gt;&gt;&gt; error</span>
<span class="sd">        matrix([[ 0.04524624],</span>
<span class="sd">                [-0.05105358],</span>
<span class="sd">                [ 0.02455487],</span>
<span class="sd">                [-0.00999476],</span>
<span class="sd">                [ 0.00947109]])</span>
<span class="sd">        &gt;&gt;&gt; constraintMatrix*model</span>
<span class="sd">        matrix([[ 42.10052368]])</span>
<span class="sd">        </span>
<span class="sd">    We compute the covariance as the inverse of the reallyNewKernel:</span>
<span class="sd">        &gt;&gt;&gt; modelCov = numpy.linalg.pinv( reallyNewKernel )</span>
<span class="sd">        &gt;&gt;&gt; modelCov</span>
<span class="sd">        matrix([[  6.30909610e-02,  -5.01795451e-02,   5.99338297e-03,  0.00000000e+00,   0.00000000e+00,   0.00000000e+00],</span>
<span class="sd">                [ -5.01795451e-02,   9.30182090e-02,  -5.02878134e-02,  0.00000000e+00,   0.00000000e+00,   0.00000000e+00],</span>
<span class="sd">                [  5.99338297e-03,  -5.02878134e-02,   7.63220083e-02,  0.00000000e+00,   0.00000000e+00,   0.00000000e+00],</span>
<span class="sd">                [  0.00000000e+00,   0.00000000e+00,   0.00000000e+00,  9.99975063e-02,  -4.98740680e-04,   2.49370340e-05],</span>
<span class="sd">                [  0.00000000e+00,   0.00000000e+00,   0.00000000e+00, -9.97481360e-02,   5.03728087e-02,   9.97481360e-01]])</span>
<span class="sd">                </span>
<span class="sd">    The new uncertainties are much reduced:</span>
<span class="sd">        &gt;&gt;&gt; uncertainty = [ sqrt(modelCov[i,i]) for i in range( modelCov.shape[0] ) ]</span>
<span class="sd">        &gt;&gt;&gt; uncertainty</span>
<span class="sd">        [0.25117914115531315, 0.30498886706247513, 0.2762643810785747, 0.316223823100982, 0.22443887510442173]</span>
<span class="sd">        </span>

<span class="sd">    **A data+constraint solution**</span>

<span class="sd">    Let&#39;s see how well we do using just the constraints and the data fitting.  As before, we stack the </span>
<span class="sd">    normal and constraint equation, but this time use the old kernel and old data (that is, without the prior):</span>
<span class="sd">        &gt;&gt;&gt; reallyNewData = stackHorizontal( [ ( kernel.T * numpy.linalg.pinv( dataCov ) * data.T ).T, constraintVector ] )</span>
<span class="sd">        &gt;&gt;&gt; reallyNewData</span>
<span class="sd">        matrix([[ 16.47777778,  21.22814815,  13.81111111,   0.        , 0.        ,  42.1       ]])</span>
<span class="sd">        &gt;&gt;&gt; reallyNewKernel = stackVertical( [ kernel.T*numpy.linalg.pinv( dataCov )*kernel, constraintMatrix ] )</span>
<span class="sd">        &gt;&gt;&gt; reallyNewKernel</span>
<span class="sd">        matrix([[ 22.84722222,  28.66666667,  15.97222222,   0.        ,   0.        ],</span>
<span class="sd">                [ 28.66666667,  36.82962963,  23.33333333,   0.        ,   0.        ],</span>
<span class="sd">                [ 15.97222222,  23.33333333,  24.72222222,   0.        ,   0.        ],</span>
<span class="sd">                [  0.        ,   0.        ,   0.        ,   0.        ,   0.        ],</span>
<span class="sd">                [  0.        ,   0.        ,   0.        ,   0.        ,   0.        ],</span>
<span class="sd">                [  0.        ,   0.        ,   0.        ,   1.        ,   1.        ]])</span>
<span class="sd">                </span>
<span class="sd">    Now we just invert the reallyNewKernel </span>
<span class="sd">        &gt;&gt;&gt; model = numpy.linalg.pinv( reallyNewKernel ) * reallyNewData.T</span>
<span class="sd">        &gt;&gt;&gt; model</span>
<span class="sd">        matrix([[  0.66232558],</span>
<span class="sd">                [ -0.05465116],</span>
<span class="sd">                [  0.18232558],</span>
<span class="sd">                [ 21.05      ],</span>
<span class="sd">                [ 21.05      ]])</span>
<span class="sd">                </span>
<span class="sd">    Ack!  it made sure the constraint is obeyed, by divying up the 42.1 among the two uncontrolled model parameters!</span>
<span class="sd">        &gt;&gt;&gt; residual = data.T - kernel*model</span>
<span class="sd">        &gt;&gt;&gt; residual </span>
<span class="sd">        matrix([[ -1.07913678e-13],</span>
<span class="sd">                [ -2.13828955e-13],</span>
<span class="sd">                [ -4.26325641e-13]])</span>
<span class="sd">        &gt;&gt;&gt; error = answer.T-model</span>
<span class="sd">        &gt;&gt;&gt; error</span>
<span class="sd">        matrix([[  0.68651163],</span>
<span class="sd">                [ -0.64302326],</span>
<span class="sd">                [  0.16651163],</span>
<span class="sd">                [-20.95      ],</span>
<span class="sd">                [ 20.95      ]])</span>
<span class="sd">                </span>
<span class="sd">    What is telling is that, to accomodate the constraint, all the uncertainty had to be shifted to the first </span>
<span class="sd">    three components of the model:</span>
<span class="sd">        &gt;&gt;&gt; modelCov = numpy.linalg.pinv( reallyNewKernel ) # use Moore-Penrose generalized inverse (ie SVD inversion)</span>
<span class="sd">        &gt;&gt;&gt; modelCov</span>
<span class="sd">        matrix([[ 19.2436993 , -17.66414278,   4.23904813,   0.        ,0.        ,   0.        ],</span>
<span class="sd">                [-17.66414278,  16.28177393,  -3.95484045,   0.        ,0.        ,   0.        ],</span>
<span class="sd">                [  4.23904813,  -3.95484045,   1.03439697,   0.        ,0.        ,   0.        ],</span>
<span class="sd">                [  0.        ,   0.        ,   0.        ,   0.        ,0.        ,   0.5       ],</span>
<span class="sd">                [  0.        ,   0.        ,   0.        ,   0.        ,0.        ,   0.5       ]])</span>
<span class="sd">        &gt;&gt;&gt; uncertainty = [ sqrt(modelCov[i,i]) for i in range( modelCov.shape[0] ) ]</span>
<span class="sd">        &gt;&gt;&gt; uncertainty </span>
<span class="sd">        [4.386764103176406, 4.035068020722195, 1.0170530818673396, 0.0, 0.0]</span>
<span class="sd">            </span>
<span class="sd">    The moral is that we&#39;d better know what spaces are constrainted by data and which ones are not!!!</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check types of all arguments</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span> <span class="n">data</span><span class="p">,</span> <span class="n">dataUnc</span><span class="p">,</span> <span class="n">dataCov</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">prior</span><span class="p">,</span> <span class="n">priorCov</span><span class="p">,</span> <span class="n">constraintVector</span><span class="p">,</span> <span class="n">constraintMatrix</span> <span class="p">]:</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">x</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">matrixlib</span><span class="o">.</span><span class="n">defmatrix</span><span class="o">.</span><span class="n">matrix</span> <span class="p">):</span> <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span> <span class="s2">&quot;all arguments must be None or a numpy.mat, got &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
    
    <span class="c1"># Make sure the vector arguments are actually vectors</span>
    <span class="k">if</span> <span class="mi">1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span> <span class="s2">&quot;data argument has wrong shape &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;, it should be a vector&#39;</span> <span class="p">)</span>
    <span class="k">if</span> <span class="n">constraintVector</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="mi">1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">constraintVector</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span> <span class="s2">&quot;constraintVector argument has wrong shape &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">constraintVector</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;, it should be a vector&#39;</span> <span class="p">)</span>
    <span class="k">if</span> <span class="n">prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="mi">1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">prior</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span> <span class="s2">&quot;prior argument has wrong shape &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">prior</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;, it should be a vector&#39;</span> <span class="p">)</span>
    
    <span class="c1"># Make sure all vectors are column vectors</span>
    <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span> 
        <span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;WARNING: data vector not a column vector, transposing it&quot;</span> <span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">T</span>
    <span class="k">if</span> <span class="n">constraintVector</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">constraintVector</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span> 
        <span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;WARNING: constraintVector vector not a column vector, transposing it&quot;</span> <span class="p">)</span>
        <span class="n">constraintVector</span> <span class="o">=</span> <span class="n">constraintVector</span><span class="o">.</span><span class="n">T</span>
    <span class="k">if</span> <span class="n">prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">prior</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span> 
        <span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;WARNING: prior vector not a column vector, transposing it&quot;</span> <span class="p">)</span>
        <span class="n">prior</span> <span class="o">=</span> <span class="n">prior</span><span class="o">.</span><span class="n">T</span>

    <span class="c1"># Construct a data covariance if we don&#39;t have one or if we have only uncertainties</span>
    <span class="k">if</span> <span class="n">dataCov</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">dataUnc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">dataCov</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span> <span class="p">[</span> <span class="n">dataUnc</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">dataUnc</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">dataUnc</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span> <span class="p">]</span> <span class="p">)</span>
    <span class="k">if</span> <span class="n">dataCov</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">dataCov</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span>

    <span class="c1"># Stack things to accomodate any possible prior for the model</span>
    <span class="k">if</span> <span class="n">prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">priorCov</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">newData</span> <span class="o">=</span> <span class="n">stackHorizontal</span><span class="p">(</span> <span class="p">[</span> <span class="n">data</span><span class="p">,</span> <span class="n">prior</span> <span class="p">]</span> <span class="p">)</span>
        <span class="n">newKernel</span> <span class="o">=</span> <span class="n">stackVertical</span><span class="p">(</span> <span class="p">[</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span> <span class="n">prior</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span> <span class="p">]</span> <span class="p">)</span>
        <span class="n">newCov</span> <span class="o">=</span> <span class="n">stackVertical</span><span class="p">(</span> <span class="p">[</span> <span class="n">stackHorizontal</span><span class="p">(</span> <span class="p">[</span> <span class="n">dataCov</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span> <span class="n">dataCov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">priorCov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span> <span class="p">)</span> <span class="p">]</span> <span class="p">),</span> <span class="n">stackHorizontal</span><span class="p">(</span> <span class="p">[</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span> <span class="n">priorCov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dataCov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span> <span class="p">),</span> <span class="n">priorCov</span> <span class="p">]</span> <span class="p">)</span> <span class="p">]</span> <span class="p">)</span> <span class="c1"># incorrect -- 0 should be zeros() </span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">newData</span> <span class="o">=</span> <span class="n">data</span>
        <span class="n">newKernel</span> <span class="o">=</span> <span class="n">kernel</span>
        <span class="n">newCov</span> <span class="o">=</span> <span class="n">dataCov</span>
        
    <span class="c1"># No constraints, so perform the inversion using standard approach</span>
    <span class="k">if</span> <span class="n">constraintVector</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">constraintMatrix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">modelCov</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span> <span class="n">newKernel</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span> <span class="n">newCov</span> <span class="p">)</span> <span class="o">*</span> <span class="n">newKernel</span> <span class="p">)</span> <span class="c1"># use Moore-Penrose generalized inverse (ie SVD inversion)</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">modelCov</span> <span class="o">*</span> <span class="n">newKernel</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span> <span class="n">newCov</span> <span class="p">)</span> <span class="o">*</span> <span class="n">newData</span><span class="o">.</span><span class="n">T</span>

    <span class="c1"># OK, there are constraints so perform the inversion using the Lagrange multiplier approach</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nConstraints</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span> <span class="n">constraintVector</span><span class="o">.</span><span class="n">shape</span> <span class="p">)</span>
        <span class="n">invNewCov</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span> <span class="n">newCov</span> <span class="p">)</span>
        <span class="n">reallyNewData</span> <span class="o">=</span> <span class="n">stackHorizontal</span><span class="p">(</span> <span class="p">[</span> <span class="p">(</span> <span class="n">newKernel</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">invNewCov</span> <span class="o">*</span> <span class="n">newData</span><span class="o">.</span><span class="n">T</span> <span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">constraintVector</span> <span class="p">]</span> <span class="p">)</span>
        <span class="n">reallyNewKernel</span> <span class="o">=</span> <span class="n">stackHorizontal</span><span class="p">(</span> <span class="p">[</span> <span class="n">stackVertical</span><span class="p">(</span> <span class="p">[</span> <span class="n">newKernel</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">invNewCov</span> <span class="o">*</span> <span class="n">newKernel</span><span class="p">,</span> <span class="n">constraintMatrix</span> <span class="p">]</span> <span class="p">),</span> <span class="n">stackVertical</span><span class="p">(</span> <span class="p">[</span> <span class="n">constraintMatrix</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span> <span class="n">nConstraints</span><span class="p">,</span> <span class="n">nConstraints</span> <span class="p">)</span> <span class="p">)</span> <span class="p">]</span> <span class="p">)</span> <span class="p">]</span> <span class="p">)</span> 
        <span class="n">modelCov</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span> <span class="n">reallyNewKernel</span> <span class="p">)</span> <span class="c1"># use Moore-Penrose generalized inverse (ie SVD inversion)</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">modelCov</span> <span class="o">*</span> <span class="n">reallyNewData</span><span class="o">.</span><span class="n">T</span>
        <span class="c1"># Note: extra dimensions are the fits of the Lagrange multipliers.  We don&#39;t need or want them.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">nConstraints</span> <span class="p">):</span> 
            <span class="n">model</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span> <span class="n">model</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span> <span class="p">)</span>
            <span class="n">modelCov</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span> <span class="n">modelCov</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span> <span class="p">)</span>
            <span class="n">modelCov</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span> <span class="n">modelCov</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span> <span class="p">)</span>
    
    <span class="c1"># How good was our inversion?</span>
    <span class="n">fs</span> <span class="o">=</span> <span class="n">fit_statistics</span><span class="p">(</span> <span class="n">data</span><span class="p">,</span> <span class="n">dataCov</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">model</span> <span class="p">)</span>
    
    <span class="k">return</span> <span class="p">(</span> <span class="n">model</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">modelCov</span><span class="p">,</span> <span class="n">fs</span><span class="p">[</span><span class="s1">&#39;residual&#39;</span><span class="p">],</span> <span class="n">fs</span><span class="p">[</span><span class="s1">&#39;chi2&#39;</span><span class="p">]</span> <span class="p">)</span></div>

  
<div class="viewcode-block" id="fit_statistics"><a class="viewcode-back" href="../../../../fudge/fudge.core.math.html#fudge.core.math.linearAlgebra.fit_statistics">[docs]</a><span class="k">def</span> <span class="nf">fit_statistics</span><span class="p">(</span> <span class="n">data</span><span class="p">,</span> <span class="n">dataCov</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">model</span> <span class="p">):</span>
    <span class="n">modelData</span> <span class="o">=</span> <span class="p">(</span> <span class="n">kernel</span> <span class="o">*</span> <span class="n">model</span> <span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">modelData</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span> <span class="s1">&#39;dimension mis-match:&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="s1">&#39;!=&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">modelData</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="p">)</span>
    <span class="n">residual</span> <span class="o">=</span> <span class="n">data</span> <span class="o">-</span> <span class="n">modelData</span>
    <span class="n">chi2</span> <span class="o">=</span> <span class="n">residual</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span> <span class="n">dataCov</span> <span class="p">)</span> <span class="o">*</span> <span class="n">residual</span><span class="o">.</span><span class="n">T</span>
    <span class="n">ndf</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span> <span class="p">)</span> <span class="o">-</span> <span class="nb">max</span><span class="p">(</span> <span class="n">model</span><span class="o">.</span><span class="n">shape</span> <span class="p">)</span> <span class="c1"># an estimate, crude?</span>
    <span class="k">return</span> <span class="p">{</span> <span class="s1">&#39;chi2&#39;</span><span class="p">:</span><span class="n">chi2</span><span class="p">,</span> <span class="s1">&#39;residual&#39;</span><span class="p">:</span><span class="n">residual</span><span class="p">,</span> <span class="s1">&#39;chi2/ndf&#39;</span><span class="p">:</span><span class="n">chi2</span><span class="o">/</span><span class="n">ndf</span><span class="p">,</span> <span class="s1">&#39;ndf&#39;</span><span class="p">:</span><span class="n">ndf</span> <span class="p">}</span></div>
    
          
<span class="c1"># ------------------------- create test matrix ------------------------- </span>
<div class="viewcode-block" id="get_test_matrix"><a class="viewcode-back" href="../../../../fudge/fudge.core.math.html#fudge.core.math.linearAlgebra.get_test_matrix">[docs]</a><span class="k">def</span> <span class="nf">get_test_matrix</span><span class="p">(</span> <span class="n">endfFile</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">MT</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">MF</span> <span class="o">=</span> <span class="kc">None</span> <span class="p">):</span>
    <span class="k">if</span> <span class="n">endfFile</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">endfFile</span> <span class="o">=</span> <span class="s1">&#39;n-099_Es_254m1.endf&#39;</span>
        <span class="n">ENDF_MFMT</span> <span class="o">=</span> <span class="s2">&quot;33,52&quot;</span>
        <span class="n">dimensions</span> <span class="o">=</span> <span class="s2">&quot;36,36&quot;</span>
        <span class="n">ndim</span> <span class="o">=</span> <span class="mi">36</span>
        <span class="n">the_data</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span> <span class="nb">float</span><span class="p">,</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="s1">         0.000000e+00</span>
<span class="s1">         0.000000e+00  0.000000e+00</span>
<span class="s1">         0.000000e+00  0.000000e+00  0.000000e+00</span>
<span class="s1">         0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00</span>
<span class="s1">         0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00  1.690124e+00</span>
<span class="s1">         0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00  1.701406e+00  1.716205e+00</span>
<span class="s1">         0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00  1.727325e+00  1.740627e+00  1.768993e+00</span>
<span class="s1">         0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00  1.766112e+00  1.779705e+00  1.806902e+00  1.849737e+00</span>
<span class="s1">         0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00  1.805003e+00  1.818895e+00  1.846707e+00  1.888721e+00  1.932443e+00</span>
<span class="s1">         0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00  2.633234e+00  2.656310e+00  2.702535e+00  2.769406e+00  2.839445e+00  4.537071e+00</span>
<span class="s1">         0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00  2.633419e+00  2.656453e+00  2.702643e+00  2.772146e+00  2.842112e+00  4.532265e+00  4.536993e+00</span>
<span class="s1">         0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00  2.621032e+00  2.643952e+00  2.689979e+00  2.759142e+00  2.828787e+00  4.510953e+00  4.511160e+00  4.494515e+00</span>
<span class="s1">         0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00  2.294322e+00  2.314437e+00  2.354731e+00  2.415354e+00  2.476366e+00  3.932745e+00  3.936493e+00  3.918021e+00  3.422690e+00</span>
<span class="s1">         0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00  1.925894e+00  1.942689e+00  1.976455e+00  2.025372e+00  2.076478e+00  3.270196e+00  3.270376e+00  3.255084e+00  2.845935e+00  2.371981e+00</span>
<span class="s1">         0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00  1.560602e+00  1.574192e+00  1.601433e+00  1.641092e+00  1.680763e+00  2.588509e+00  2.591054e+00  2.581430e+00  2.259491e+00  1.886678e+00  1.513082e+00</span>
<span class="s1">         0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00  1.112542e+00  1.121110e+00  1.139352e+00  1.166373e+00  1.193373e+00  1.747292e+00  1.750786e+00  1.744347e+00  1.533591e+00  1.289816e+00  1.048526e+00  7.535799e-01</span>
<span class="s1">         0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00  9.208774e-01  9.279808e-01  9.422195e-01  9.642405e-01  9.854623e-01  1.388816e+00  1.392019e+00  1.387101e+00  1.223956e+00  1.035605e+00  8.521885e-01  6.280513e-01  5.345716e-01</span>
<span class="s1">         0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00  6.868322e-01  6.913886e-01  7.019228e-01  7.175892e-01  7.333606e-01  9.928217e-01  9.953127e-01  9.930198e-01  8.790898e-01  7.481786e-01  6.233050e-01  4.717560e-01  4.089519e-01  3.193141e-01</span>
<span class="s1">         0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00  5.577461e-01  5.614184e-01  5.699828e-01  5.822554e-01  5.944450e-01  7.851565e-01  7.871801e-01  7.855044e-01  6.967945e-01  5.954048e-01  4.998745e-01  3.846700e-01  3.370624e-01  2.655876e-01  2.228462e-01</span>
<span class="s1">         0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00  3.322102e-01  3.343361e-01  3.386220e-01  3.454492e-01  3.517908e-01  4.290979e-01  4.304639e-01  4.297462e-01  3.834943e-01  3.312716e-01  2.847126e-01  2.295958e-01  2.071083e-01  1.677455e-01  1.427551e-01  9.555420e-02</span>
<span class="s1">         0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00  3.604038e-02  3.589246e-02  3.488834e-02  3.411414e-02  3.282049e-02 -3.279601e-02 -3.284671e-02 -3.271555e-02 -2.635367e-02 -1.497233e-02  1.232291e-03  2.323535e-02  3.246637e-02  3.503985e-02  3.383028e-02  3.062795e-02  2.692990e-02</span>
<span class="s1">         0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00 -7.267533e-02 -7.373635e-02 -7.662602e-02 -8.038130e-02 -8.453273e-02 -1.979285e-01 -1.987893e-01 -1.986476e-01 -1.743977e-01 -1.409929e-01 -1.027300e-01 -5.400185e-02 -3.396930e-02 -1.587535e-02 -8.317105e-03  5.515628e-03  2.637916e-02  3.688719e-02</span>
<span class="s1">         0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00 -8.439620e-02 -8.558441e-02 -8.881654e-02 -9.278483e-02 -9.716333e-02 -2.088966e-01 -2.102492e-01 -2.101251e-01 -1.860955e-01 -1.519483e-01 -1.129048e-01 -6.362840e-02 -4.343154e-02 -2.386577e-02 -1.535218e-02  1.041874e-03  2.649154e-02  3.981114e-02  4.414266e-02</span>
<span class="s1">         0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00 -4.099937e-02 -4.161169e-02 -4.416221e-02 -4.686749e-02 -5.018817e-02 -1.297361e-01 -1.313929e-01 -1.316491e-01 -1.180110e-01 -9.560794e-02 -6.907117e-02 -3.455066e-02 -2.097080e-02 -7.999232e-03 -3.016686e-03  7.647215e-03  2.611127e-02  3.750344e-02  4.216583e-02  4.208217e-02</span>
<span class="s1">         0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00 -8.692396e-03 -9.279179e-03 -1.108010e-02 -1.298799e-02 -1.528045e-02 -7.124834e-02 -7.270001e-02 -7.325542e-02 -6.765080e-02 -5.422922e-02 -3.658099e-02 -1.347648e-02 -4.733320e-03  3.182242e-03  5.588162e-03  1.224217e-02  2.591315e-02  3.602061e-02  4.106297e-02  4.208267e-02  4.331828e-02</span>
<span class="s1">         0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00  1.277385e-01  1.284242e-01  1.292478e-01  1.310071e-01  1.326888e-01  1.657041e-01  1.644256e-01  1.627654e-01  1.391348e-01  1.179997e-01  1.002280e-01  7.962980e-02  6.993322e-02  5.707190e-02  4.833213e-02  3.556557e-02  2.356314e-02  2.440651e-02  2.868411e-02  3.400294e-02  3.815346e-02  4.627409e-02</span>
<span class="s1">         0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00  1.988736e-01  2.001158e-01  2.025712e-01  2.065709e-01  2.102171e-01  2.895255e-01  2.889460e-01  2.871065e-01  2.485628e-01  2.095750e-01  1.732604e-01  1.299079e-01  1.105119e-01  8.630489e-02  7.158975e-02  4.787028e-02  2.091391e-02  1.543294e-02  1.850572e-02  2.567564e-02  3.119235e-02  4.617069e-02  5.066840e-02</span>
<span class="s1">         0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00  2.005723e-01  2.021068e-01  2.048516e-01  2.088673e-01  2.128834e-01  2.960696e-01  2.956199e-01  2.941737e-01  2.555868e-01  2.155465e-01  1.779475e-01  1.326661e-01  1.127036e-01  8.765646e-02  7.258235e-02  4.778240e-02  1.847589e-02  1.132459e-02  1.356651e-02  2.052769e-02  2.579265e-02  4.139233e-02  4.675601e-02  4.376726e-02</span>
<span class="s1">         0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00  1.682710e-01  1.693323e-01  1.714251e-01  1.747393e-01  1.780599e-01  2.444032e-01  2.436937e-01  2.425362e-01  2.109347e-01  1.783747e-01  1.478118e-01  1.113854e-01  9.527406e-02  7.458976e-02  6.200201e-02  4.128731e-02  1.688060e-02  1.109806e-02  1.307890e-02  1.888816e-02  2.330460e-02  3.623141e-02  4.049497e-02  3.776391e-02  3.280182e-02</span>
<span class="s1">         0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00  1.379456e-01  1.387843e-01  1.404562e-01  1.430018e-01  1.454850e-01  1.932246e-01  1.928924e-01  1.916331e-01  1.665959e-01  1.412460e-01  1.182012e-01  9.084645e-02  7.859059e-02  6.231665e-02  5.215703e-02  3.560402e-02  1.647353e-02  1.247273e-02  1.448556e-02  1.930557e-02  2.300591e-02  3.324171e-02  3.619012e-02  3.352310e-02  2.917429e-02  2.625984e-02</span>
<span class="s1">         0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00  1.229217e-01  1.236599e-01  1.251312e-01  1.273135e-01  1.292684e-01  1.674026e-01  1.670501e-01  1.659330e-01  1.439693e-01  1.224219e-01  1.033336e-01  8.060127e-02  7.037075e-02  5.639522e-02  4.739974e-02  3.290179e-02  1.652968e-02  1.351233e-02  1.555447e-02  1.992412e-02  2.327636e-02  3.214322e-02  3.442959e-02  3.170202e-02  2.767207e-02  2.503058e-02  2.405622e-02</span>
<span class="s1">         0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00  1.215488e-01  1.222745e-01  1.235435e-01  1.256653e-01  1.277727e-01  1.661270e-01  1.655886e-01  1.645113e-01  1.428780e-01  1.214350e-01  1.023434e-01  7.961931e-02  6.937311e-02  5.541419e-02  4.651601e-02  3.221869e-02  1.600271e-02  1.301406e-02  1.505617e-02  1.936928e-02  2.262628e-02  3.155131e-02  3.380264e-02  3.117874e-02  2.728977e-02  2.468726e-02  2.365762e-02  2.345737e-02</span>
<span class="s1">         0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00  1.209428e-01  1.216868e-01  1.229914e-01  1.251549e-01  1.273144e-01  1.678512e-01  1.675028e-01  1.664139e-01  1.447007e-01  1.228889e-01  1.030352e-01  7.963224e-02  6.891763e-02  5.464836e-02  4.576022e-02  3.136029e-02  1.486404e-02  1.154498e-02  1.337069e-02  1.760547e-02  2.089117e-02  2.985604e-02  3.244487e-02  3.002768e-02  2.626797e-02  2.368499e-02  2.268672e-02  2.244466e-02  2.164516e-02</span>
<span class="s1">         0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00  1.191637e-01  1.199028e-01  1.213634e-01  1.234824e-01  1.255984e-01  1.662982e-01  1.660038e-01  1.649346e-01  1.434091e-01  1.217682e-01  1.021530e-01  7.867281e-02  6.808521e-02  5.390608e-02  4.509330e-02  3.077834e-02  1.430499e-02  1.084618e-02  1.256069e-02  1.669642e-02  1.990212e-02  2.880841e-02  3.149815e-02  2.921774e-02  2.552252e-02  2.299790e-02  2.201084e-02  2.181507e-02  2.099733e-02  2.046324e-02</span>
<span class="s1">         0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00  1.176283e-01  1.183546e-01  1.197936e-01  1.219420e-01  1.240511e-01  1.648989e-01  1.646051e-01  1.635512e-01  1.422097e-01  1.207601e-01  1.012042e-01  7.779795e-02  6.726494e-02  5.316105e-02  4.444636e-02  3.021617e-02  1.374686e-02  1.015227e-02  1.174391e-02  1.577280e-02  1.890665e-02  2.777053e-02  3.053308e-02  2.837224e-02  2.476958e-02  2.231187e-02  2.132974e-02  2.114385e-02  2.037711e-02  1.986223e-02  1.933972e-02</span>
<span class="s1">         0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00  1.147770e-01  1.154951e-01  1.169225e-01  1.190371e-01  1.211243e-01  1.625308e-01  1.622074e-01  1.611758e-01  1.404440e-01  1.193101e-01  9.967764e-02  7.631129e-02  6.581783e-02  5.182580e-02  4.324281e-02  2.919151e-02  1.269126e-02  8.828116e-03  1.020002e-02  1.406360e-02  1.708787e-02  2.582078e-02  2.876437e-02  2.685574e-02  2.345379e-02  2.106032e-02  2.010601e-02  1.994271e-02  1.929665e-02  1.880384e-02  1.831317e-02  1.743624e-02</span>
<span class="s1">        &#39;&#39;&#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span> <span class="p">)</span>
        <span class="kn">import</span> <span class="nn">copy</span>
        <span class="n">aTestMatrix</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1">#copy.deepcopy( ndim*[ ndim*[ 0.0 ] ] )</span>
        <span class="n">idata</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">ndim</span> <span class="p">):</span>
            <span class="n">aTestMatrix</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">[]</span> <span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">):</span> 
                <span class="n">aTestMatrix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">the_data</span><span class="p">[</span> <span class="n">idata</span> <span class="p">]</span> <span class="p">)</span>
                <span class="n">idata</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span> <span class="n">aTestMatrix</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">aTestMatrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="p">)</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mat</span><span class="p">(</span> <span class="n">aTestMatrix</span> <span class="p">)</span></div>


<div class="viewcode-block" id="get_covariances_from_endf"><a class="viewcode-back" href="../../../../fudge/fudge.core.math.html#fudge.core.math.linearAlgebra.get_covariances_from_endf">[docs]</a><span class="k">def</span> <span class="nf">get_covariances_from_endf</span><span class="p">(</span> <span class="n">endfFile</span><span class="p">,</span> <span class="n">MT</span><span class="p">,</span> <span class="n">MF</span> <span class="o">=</span> <span class="mi">33</span> <span class="p">):</span>

    <span class="kn">from</span> <span class="nn">fudge.legacy.converting</span> <span class="k">import</span> <span class="n">endfFileToGND</span>

    <span class="n">rce</span> <span class="o">=</span> <span class="n">endfFileToGND</span><span class="o">.</span><span class="n">endfFileToGND</span><span class="p">(</span> <span class="n">endfFile</span><span class="p">,</span> <span class="n">toStdOut</span> <span class="o">=</span> <span class="kc">False</span> <span class="p">)</span>
    <span class="n">xFileOne</span><span class="p">,</span> <span class="n">cFileOne</span> <span class="o">=</span> <span class="n">rce</span><span class="p">[</span><span class="s1">&#39;reactionSuite&#39;</span><span class="p">],</span> <span class="n">rce</span><span class="p">[</span><span class="s1">&#39;covarianceSuite&#39;</span><span class="p">]</span>
    <span class="n">MFMTListOne</span> <span class="o">=</span> <span class="p">[</span> <span class="n">section</span><span class="o">.</span><span class="n">rowData</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span> <span class="s1">&#39;ENDF_MFMT&#39;</span> <span class="p">]</span> <span class="k">for</span> <span class="n">section</span> <span class="ow">in</span> <span class="n">cFileOne</span> <span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">(</span><span class="n">MF</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;,&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">MT</span><span class="p">)</span> <span class="ow">in</span> <span class="n">MFMTListOne</span><span class="p">:</span>  <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span> <span class="s2">&quot;Requested MF,MT (&quot;</span> <span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">MF</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;,&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">MT</span><span class="p">)</span><span class="o">+</span> <span class="s2">&quot;) not in first file, pick from &quot;</span> <span class="o">+</span><span class="nb">str</span><span class="p">(</span> <span class="n">MFMTListOne</span> <span class="p">)</span> <span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">section</span> <span class="ow">in</span> <span class="n">cFileOne</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">MF</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;,&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">MT</span><span class="p">)</span> <span class="o">==</span> <span class="n">section</span><span class="o">.</span><span class="n">rowData</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span> <span class="s1">&#39;ENDF_MFMT&#39;</span> <span class="p">]</span> <span class="ow">and</span> <span class="n">section</span><span class="o">.</span><span class="n">nativeData</span> <span class="ow">in</span> <span class="p">[</span> <span class="s1">&#39;covarianceMatrix&#39;</span><span class="p">,</span> <span class="s1">&#39;mixed&#39;</span> <span class="p">]:</span> 
                <span class="n">sectionOne</span> <span class="o">=</span> <span class="n">section</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="n">sectionOne</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span> <span class="s1">&#39;File &#39;</span><span class="o">+</span><span class="n">endfFile</span><span class="o">+</span><span class="s1">&#39; missing plain old covariance matrix for MF,MT=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">MF</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;,&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">MT</span><span class="p">)</span> <span class="p">)</span>
    <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span> <span class="n">err</span><span class="o">.</span><span class="n">message</span> <span class="p">)</span>
    <span class="c1"># sometimes the matrices are plain matrices, other times they are broken in components.  We&#39;ll make all of them a list of components</span>
    <span class="n">componentListOne</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">sectionOne</span><span class="o">.</span><span class="n">nativeData</span> <span class="o">==</span> <span class="s1">&#39;covarianceMatrix&#39;</span><span class="p">:</span> <span class="n">componentListOne</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">sectionOne</span><span class="o">.</span><span class="n">forms</span><span class="p">[</span><span class="s1">&#39;covarianceMatrix&#39;</span><span class="p">]</span> <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">sectionOne</span><span class="o">.</span><span class="n">forms</span><span class="p">[</span> <span class="s1">&#39;mixed&#39;</span> <span class="p">]</span><span class="o">.</span><span class="n">components</span><span class="p">:</span> <span class="n">componentListOne</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">component</span> <span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span> <span class="n">numpy</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span> <span class="n">x</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">data</span> <span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">componentListOne</span> <span class="p">]</span></div>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="c1"># ------------------------- command line parser ------------------------- </span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="s1">&#39;Covariance test widget&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--mt&#39;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s1">&#39;mt&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">53</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;MT of the covariance to check&#39;</span> <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--endf&#39;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s1">&#39;endf&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">default</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;The endf file whose covariance you want to use&#39;</span> <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--mf&#39;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s1">&#39;mf&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">33</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;MF of orginal data to use [default is 33, cross section covariance]&#39;</span> <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--tests&#39;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s1">&#39;doTests&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;store_true&#39;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Run unit tests&#39;</span> <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--plot&#39;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s1">&#39;plot&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;store_true&#39;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Make a plot of the covariance used&#39;</span> <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--plotDiff&#39;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s1">&#39;plotDiff&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;store_true&#39;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Make a plot of the differences between old &amp; new covariances if applying fix&#39;</span> <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--plotBadSpace&#39;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s1">&#39;plotBadSpace&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;store_true&#39;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Make a plot of bad eigenspaces&#39;</span> <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--print&#39;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s1">&#39;print&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;store_true&#39;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Print out the entire covariance&#39;</span> <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--printEVs&#39;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s1">&#39;printEVs&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;store_true&#39;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Print out the eigen values of the covariance&#39;</span> <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--printType&#39;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s1">&#39;printType&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;store_true&#39;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Print type information for the covariance&#39;</span> <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--niter&#39;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s1">&#39;niter&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Num iterations&#39;</span> <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--scaleOffDiagonals&#39;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s1">&#39;scaleOffDiagonals&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;store_true&#39;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Scale off diagonal elements by some factor set by --scaleFactor switch&#39;</span> <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--scaleMatrix&#39;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s1">&#39;scaleMatrix&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;store_true&#39;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Scale all elements by some factor set by --scaleFactor switch&#39;</span> <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--scaleFactor&#39;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s1">&#39;scaleFactor&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.999999</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Scale factor to use when scaling off diagonal elements (Default: 0.999999)&#39;</span> <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--pruneEVs&#39;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s1">&#39;pruneEVs&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;store_true&#39;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Prune small/negative eigenvalues/eigenspaces&#39;</span> <span class="p">)</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>

    <span class="n">numpy</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span> <span class="n">linewidth</span> <span class="o">=</span> <span class="mi">100</span> <span class="p">)</span> 

    <span class="c1"># Run the units tests</span>
    <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">doTests</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">subprocess</span>
        <span class="k">try</span><span class="p">:</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">check_call</span><span class="p">(</span> <span class="p">[</span><span class="s1">&#39;python&#39;</span><span class="p">,</span><span class="s1">&#39;test_mtx.py&#39;</span><span class="p">]</span> <span class="p">)</span>
        <span class="k">except</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">CalledProcessError</span><span class="p">:</span> <span class="k">pass</span>

    <span class="c1"># The test matrices</span>
    <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">endf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">listOfA</span> <span class="o">=</span> <span class="n">get_covariances_from_endf</span><span class="p">(</span> <span class="n">args</span><span class="o">.</span><span class="n">endf</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">mt</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">mf</span> <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> <span class="n">listOfA</span> <span class="o">=</span> <span class="p">[</span> <span class="n">get_test_matrix</span><span class="p">()</span> <span class="p">]</span>
    
    <span class="k">for</span> <span class="n">icomponent</span><span class="p">,</span> <span class="n">A</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span> <span class="n">listOfA</span> <span class="p">):</span>
        <span class="nb">print</span><span class="p">()</span>
    
        <span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;Component &quot;</span> <span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">icomponent</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;:&quot;</span> <span class="p">)</span>
    
        <span class="c1"># Check the matrix</span>
        <span class="n">success</span> <span class="o">=</span> \
            <span class="n">check_symmetric</span><span class="p">(</span> <span class="n">A</span> <span class="p">)</span> <span class="ow">and</span> \
            <span class="n">check_element_bounds</span><span class="p">(</span> <span class="n">A</span> <span class="p">)</span> <span class="ow">and</span> \
            <span class="n">check_positive_semidefinite</span><span class="p">(</span> <span class="n">A</span> <span class="p">)</span>
    
        <span class="c1"># Any and all matrix displaying</span>
        <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">printType</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span> <span class="nb">type</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">print</span><span class="p">:</span>     <span class="nb">print</span><span class="p">(</span> <span class="n">A</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">plot</span><span class="p">:</span>      <span class="n">plot_matrix</span><span class="p">(</span> <span class="n">A</span><span class="p">,</span> <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;MT=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">mt</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;, Covariance Matrix&#39;</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">printEVs</span><span class="p">:</span>  
                           <span class="n">print_eigenvalues</span><span class="p">(</span> <span class="n">A</span> <span class="p">)</span>
                           <span class="n">plot_bad_eigenspaces</span><span class="p">(</span> <span class="n">A</span> <span class="p">)</span>
        <span class="n">Aold</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span> <span class="n">A</span> <span class="p">)</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">args</span><span class="o">.</span><span class="n">niter</span> <span class="p">):</span>
            <span class="k">if</span> <span class="n">success</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;After &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; iterations, component &quot;</span> <span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">icomponent</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; is OK&quot;</span> <span class="p">)</span>
                <span class="k">break</span>
        
            <span class="c1"># Iterating fixes</span>
            <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">scaleOffDiagonals</span><span class="p">:</span> <span class="n">Anew</span> <span class="o">=</span> <span class="n">scale_off_diagonals</span><span class="p">(</span> <span class="n">Aold</span><span class="p">,</span> <span class="n">scaleFactor</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">scaleFactor</span> <span class="p">)</span> 
            <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">scaleMatrix</span><span class="p">:</span>       <span class="n">Anew</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">scaleFactor</span> <span class="o">*</span> <span class="n">Aold</span> 
            <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">pruneEVs</span><span class="p">:</span>          <span class="n">Anew</span> <span class="o">=</span> <span class="n">pruned_matrix</span><span class="p">(</span> <span class="n">Aold</span> <span class="p">)</span>
    
            <span class="c1"># Recheck everything</span>
            <span class="n">success</span> <span class="o">=</span> \
                <span class="n">check_symmetric</span><span class="p">(</span> <span class="n">Anew</span> <span class="p">)</span> <span class="ow">and</span> \
                <span class="n">check_element_bounds</span><span class="p">(</span> <span class="n">Anew</span> <span class="p">)</span> <span class="ow">and</span> \
                <span class="n">check_positive_semidefinite</span><span class="p">(</span> <span class="n">Anew</span> <span class="p">)</span>
    
            <span class="c1"># Any and all matrix displaying (again)</span>
            <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">print</span><span class="p">:</span>     <span class="nb">print</span><span class="p">(</span> <span class="n">Anew</span> <span class="p">)</span>
            <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">printType</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span> <span class="nb">type</span><span class="p">(</span><span class="n">Anew</span><span class="p">)</span> <span class="p">)</span>
            <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">plot</span><span class="p">:</span>      <span class="n">plot_matrix</span><span class="p">(</span> <span class="n">Anew</span><span class="p">,</span> <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;MT=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">mt</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;, Covariance Matrix&#39;</span> <span class="p">)</span>
            <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">printEVs</span><span class="p">:</span>  <span class="n">print_eigenvalues</span><span class="p">(</span> <span class="n">Anew</span> <span class="p">)</span>
            <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">plotDiff</span><span class="p">:</span>
                <span class="n">diff</span><span class="p">,</span> <span class="n">reldiff</span> <span class="o">=</span> <span class="n">diff_matrices</span><span class="p">(</span> <span class="n">A</span><span class="p">,</span> <span class="n">Anew</span> <span class="p">)</span>
                <span class="n">plot_matrix</span><span class="p">(</span> <span class="n">diff</span><span class="p">,</span> <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Absolute difference&#39;</span> <span class="p">)</span>
                <span class="n">plot_matrix</span><span class="p">(</span> <span class="n">reldiff</span><span class="p">,</span> <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Relative </span><span class="si">% d</span><span class="s1">ifference&#39;</span> <span class="p">)</span>
            <span class="n">Aold</span> <span class="o">=</span> <span class="n">Anew</span>


        
    <span class="c1">#In numpy, have around( obj[, decimals[, out] ), _round() too</span>
    <span class="c1">#numpy.testing.assert_approx_equal(actual, desired, significant=7, err_msg=&#39;&#39;, verbose=True)</span>
    <span class="c1">#numpy.nan_to_num( diff/numpy.matrix( matrixOne ) )</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../../index.html">
              <img class="logo" src="../../../../_static/gnd.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">Fudge and GND 4.2.2 beta documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2012, B.Beck, D. Brown, C. Mattoon, N. Patel, N. Summers.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.1.
    </div>
  </body>
</html>
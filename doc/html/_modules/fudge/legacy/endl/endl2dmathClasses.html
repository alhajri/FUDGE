<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>fudge.legacy.endl.endl2dmathClasses &#8212; Fudge and GND 4.2.2 beta documentation</title>
    
    <link rel="stylesheet" href="../../../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../',
        VERSION:     '4.2.2 beta',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../../../_static/gnd-20121206-favicon.ico"/>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">Fudge and GND 4.2.2 beta documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../endl.html" accesskey="U">fudge.legacy.endl</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for fudge.legacy.endl.endl2dmathClasses</h1><div class="highlight"><pre>
<span></span># &lt;&lt;BEGIN-copyright&gt;&gt;
# &lt;&lt;END-copyright&gt;&gt;

&quot;&quot;&quot;
This module contains the endl2dmath class.  Also see the supporting module endl2dmathmisc.py.

It also contains the variables doSafeDivide and doSafeDivideAlways (see __div__ for details).
&quot;&quot;&quot;
#
#  Things to fix;
#   1) What to do if self.data is an empty list (= []).
#   2) Handle case when self.data has two identical E data (i.e., self.data[i][0] = self.data[i+1][0]).
#   3) endl2dmath.__init__ should do a deepcopy of data
#

import os
import math
from math import *  # Needed for scalex
import copy

from fudge.core import fudgemisc
from fudge.core.utilities import fudgeFileMisc, fudgeExceptions
from fudge.vis.gnuplot import plotbase
from fudge.core.utilities import subprocessing
from xData import XYs as XYsModule

__metaclass__ = type

numpyImported = False
try :
    import numpy
    numpyImported = True
except :
    fudgemisc.printWarning( &quot;Warning from endl2dmathClasses.py: numpy not imported&quot; )

import endlParameters
import endl1dmathClasses
import endl2dmathmisc

doSafeDivide = False
doSafeDivideAlways = False
safeDivideMaxValue = 1e20

<div class="viewcode-block" id="endl2dmath"><a class="viewcode-back" href="../../../../fudge/fudge.legacy.endl.html#fudge.legacy.endl.endl2dmathClasses.endl2dmath">[docs]</a>class endl2dmath :
    &quot;&quot;&quot;
    The class endl2dmath is the base class for all 2d data (i.e., data consisting of
    (x, y) pairs or 2 column data). The data is stored as a python list of [ x, y ] values.
    For example, the 2 column data::

      2.5  4.5
      3.1  3.6
      3.4  4.4
    is stored as self.data = [ [ 2.5, 4.5 ], [ 3.1, 3.6 ], [ 3.4, 4.4 ] ].

    Members::

        data               A python list of [ x, y ] pairs.
        columns            Always 2 (i.e., 2 column data).
        interpolation      Type of interpolation used (see below).
        xLabel             X label used for plotting.
        yLabel             Y label used for plotting.

    Interpolation values and meaning::

        xylog   plot-type
        ----------------------
          0     linear-linear
          1     log-linear
          2     linear-log
          3     log-log
    &quot;&quot;&quot;

    def __init__( self, data = None, checkDataType = False, xLabel = None, yLabel = None, label = &quot;unknown&quot;, interpolation = 0, 
        template = None, allowSameX = False ) :
        &quot;&quot;&quot;Returns an endl2dmath instance. Data must be of type list[ number, number ].&quot;&quot;&quot;

        if( data is None ) : data = []
        if( ( interpolation &lt; 0 ) or ( interpolation &gt; 3 ) ) :
            raise Exception( &quot;\nError in endl2dmath.__init__: Bad interpolation value = %s&quot; % `interpolation` )
        self.data = endl2dmathmisc.get2dmathData( data, &quot;endl2dmath.__init__&quot;, &quot;data&quot; )
        if ( checkDataType ) : dummy = endl2dmathmisc.check2dData( self.data, positiveY = 0, allowSameX = allowSameX )
        if( not( template is None ) ) : endl2dmathmisc.valid2dClassType( template, &quot;endl2dmath.__init__&quot;, &quot;template&quot; )
        self.columns = 2
        self.label = label
        self.xLabel = xLabel
        if( xLabel is None ) :
            try :
                self.xLabel = template.xLabel
            except :
                pass
        self.yLabel = yLabel
        if( yLabel is None ) :
            try :
                self.yLabel = template.yLabel
            except :
                pass
        self.interpolation = interpolation
        if(   self.interpolation == 0 ) :
            self.xInterpolation = &#39;linear,linear&#39;
        elif( self.interpolation == 1 ) :
            self.xInterpolation = &#39;log,linear&#39;
        elif( self.interpolation == 2 ) :
            self.xInterpolation = &#39;linear,log&#39;
        elif( self.interpolation == 3 ) :
            self.xInterpolation = &#39;log,log&#39;
        if ( not( template is None ) and ( interpolation is None ) ) : self.interpolation = template.interpolation

    def __getitem__( self, i ) :
        &quot;&quot;&quot;Returns self&#39;s y value evaluated at i.  If i is outside the range
    of self&#39;s i domain then 0. is returned. This will be changed in version 4 to return
    self.data[i] (i.e., the (i+1)^th element of self.data). Use getValue or getValueInDomain
    instead of this routine.&quot;&quot;&quot;

        return self.getValue( i )

    def __setitem__( self, x, y ) :
        &quot;&quot;&quot;Sets self&#39;s y value evaluated at x to y.  If there is no point at x 
        then one is added. x and y must be numbers. Like __getitem__ this will 
        also be changed in version 4. Use setValue instead of this routine.&quot;&quot;&quot;

        self.setValue( x, y )

    def __len__( self ) :
        &quot;&quot;&quot;Returns the number of (x,y) pairs in the self&#39;s data member.&quot;&quot;&quot;

        return len( self.data )

    def __repr__( self ) :
        &quot;&quot;&quot;Returns a printable string of the data in self. This method uses endl2dmathmisc.endl2d_repr_xFormat
        and endl2dmathmisc.endl2d_repr_yFormat to convert each point to a string.&quot;&quot;&quot;

        xy = &quot;%s %s&quot; % ( endl2dmathmisc.endl2d_repr_xFormat, endl2dmathmisc.endl2d_repr_yFormat )
        s = [ xy % ( x, y ) for x, y in self.data ]
        s = &#39;\n&#39;.join( s ) + &#39;\n&#39;
        return s

    def __neg__( self ) :
        &quot;&quot;&quot;Returns an endl2dmath instance that has all y values of self negated.&quot;&quot;&quot;

        d = self.copyData( )
        for xy in d.data : xy[1] = -xy[1]
        return d

    def __abs__( self ) :
        &quot;&quot;&quot;Returns an endl2dmath instance whose y values are the absolute value of self&#39;s y values.&quot;&quot;&quot;

        d = self.copyData( )
        for xy in d.data : xy[1] = math.fabs( xy[1] )
        return d

    def __add__( self, v ) :
        &quot;&quot;&quot;Returns an endl2dmath instance that is first set to self.union( v ).
    Then the y values of self are set to self&#39;s y value plus v&#39;s y value evaluated at
    each union point (v must be a number or another endl2dmath instance).&quot;&quot;&quot;

        if ( type( v ) == type( 1 ) ) or ( type( v ) == type( 1. ) ) :
            d = self.copyData( )
            for p in d.data : p[1] = p[1] + v
        else :
            data = endl2dmathmisc.valid2dClassType( v, &quot;endl2dmath.__add__&quot;, &quot;addition&quot; )
            if ( len( self ) &lt; 1 ) :
                d = data.copyData( )
            elif ( len( data ) &lt; 1 ) :
                d = self.copyData( )
            else :
                d = self.union( data )
                j = 0
                dArray = data.data
                x1, y1 = dArray[0]
                x2, y2 = dArray[1]
                xEnd  = dArray[-1][0]
                j = 1
                n = len( dArray )
                for p in d.data :
                    x = p[0]
                    if( x &lt; x1 ) :
                        vp = 0.
                    elif( x &gt; xEnd ) :
                        vp = 0.
                    else :
                        if( x2 &lt; x ) : 
                            j += 1
                            x1, y1 = x2, y2
                            x2, y2 = dArray[j]
                        vp = endl2dmathmisc.interpolate2dPoints( self.interpolation, x, x1, y1, x2, y2 )
                    p[1] = p[1] + vp
                if  ( self.data[0][0]  == data.data[-1][0] ) :
                    x = self.data[0][0]
                    d.setValue( x, 0.5 * ( self.data[0][1] + data.data[-1][1] ) )
                    j = 0
                    dx = endlParameters.endlEpsx * x
                    xp = x - 2. * dx
                    for xy in d.data :
                        if( xy[0] &gt;= xp ) : break
                        j += 1
                    xp += dx
                    if( d.data[j][0] == x ) :
                        d.setValue( xp, data.getValue( xp ) )
                        j += 1
                    xp = x + 2. * dx
                    j += 1
                    if( d.data[j][0] &gt; xp ) :
                        xp -= dx
                        d.setValue( xp, self.getValue( xp ) )
                elif( self.data[-1][0] == data.data[0][0]  ) :
                    x = data.data[0][0]
                    d.setValue( x, 0.5 * ( self.data[-1][1] + data.data[0][1] ) )
                    j = 0
                    dx = endlParameters.endlEpsx * x
                    xp = x - 2. * dx
                    for xy in d.data :
                        if( xy[0] &gt;= xp ) : break
                        j += 1
                    xp += dx
                    if( d.data[j][0] == x ) :
                        d.setValue( xp, self.getValue( xp ) )
                        j += 1
                    xp = x + 2. * dx
                    j += 1
                    if( d.data[j][0] &gt; xp ) :
                        xp -= dx
                        d.setValue( xp, data.getValue( xp ) )
            d.interpolation = min( self.interpolation, data.interpolation )
        return d

    def __radd__( self, v ) :
        &quot;&quot;&quot;Same as __add__( self, v ).&quot;&quot;&quot;

        return self + v

    def __sub__( self, v ) :
        &quot;&quot;&quot;Returns an endl2dmath instance that is first set to self.union( v ).
    Then the y values of self are set to self&#39;s y value minus v&#39;s y value evaluated at 
    each union point (v must be a number or another endl2dmath instance).&quot;&quot;&quot;

        if ( type( v ) == type( 1 ) ) or ( type( v ) == type( 1. ) ) :
            d = self.copyData( )
            for p in d.data : p[1] = p[1] - v
        else :
            data = endl2dmathmisc.valid2dClassType( v, &quot;endl2dmath.__sub__&quot;, &quot;subtraction&quot; )
            if ( len( self ) &lt; 1 ) :
                d = -data
            elif ( len( data ) &lt; 1 ) :
                d = self.copyData( )
            else :
                d = self.union( data )
                j = 0
                for p in d.data :
                    vp, j = data.GetValueNIndex( p[0], j )
                    p[1] = p[1] - vp
            d.interpolation = min( self.interpolation, data.interpolation )
        return d

    def __rsub__( self, v ) :
        &quot;&quot;&quot;Returns an endl2dmath instance that is the same as self except every
    y value is subtracted from v (v must be a number).&quot;&quot;&quot;

        if ( type( v ) == type( 1 ) ) or ( type( v ) == type( 1. ) ) :
            d = self.copyData( )
            for e in d.data : e[1] = v - e[1]
        else :
            raise Exception( &quot;\nError in endl2dmath.__rsub__: invalid type for subtraction&quot; )
        return d

    def __mul__( self, v ) :
        &quot;&quot;&quot;Returns an endl2dmath instance that is the same as self except every
    y value is multiplied by v (v must be a number).&quot;&quot;&quot;

        if ( type( v ) == type( 1 ) ) or ( type( v ) == type( 1. ) ) :
            v = float( v )
            d = self.copyData( )
            for e in d.data : e[1] = v * e[1]
        else :
            data = endl2dmathmisc.valid2dClassType( v, &quot;endl2dmath.__mul__&quot;, &quot;multiplication&quot; )
            if ( len( self ) &lt; 1 ) :        # Nothing to multiply
                d = self.copyData( )
            elif ( len( data ) &lt; 1 ) :
                d = data.copyData( )
            if ( len( self ) == 1 ) :       # Weird situation, but will treat (kind of) as a delta function.
                d = self.copyData( )
                d.data[0][1] = d.data[0][1] * data.getValue( d.data[0][0] )
            elif ( len( data ) == 1 ) :
                d = data.copyData( )
                d.data[0][1] = d.data[0][1] * self.getValue( d.data[0][0] )
            else :
                d = endl2dmath.union( self, data, xDomainUnionOnly = True )
                dArray = data.data
                if( len( d ) &lt; 2 ) :
                    for xy in d.data : xy[1] = xy[1] * data.getValue( xy[0] )
                else :
                    j = 0
                    x0 = d.data[0][0]
                    for x, y in dArray :                # This is needed as the slice above may make x0 &gt; dArray[0][0].
                        if( x &gt;= x0 ) : break           # Should break on x == x0, as d contains all x-values in self and v.
                        j += 1
                    x1, y1 = dArray[j]
                    if( ( x1 &gt; x0 ) and ( j &gt; 0 ) ) :
                        j -= 1
                        x1, y1 = dArray[j]
                    j += 1
                    x2, y2 = dArray[j]
                    xEnd  = dArray[-1][0]
                    for p in d.data :
                        x = p[0]
                        if( x &gt; xEnd ) :
                            vp = 0.
                        else :
                            if( x2 &lt; x ) : 
                                j += 1
                                x1, y1 = x2, y2
                                x2, y2 = dArray[j]
                            vp = endl2dmathmisc.interpolate2dPoints( self.interpolation, x, x1, y1, x2, y2 )
                        p[1] = p[1] * vp
                    trimOnMultiply = True
                    if( hasattr( self, &#39;trimOnMultiply&#39; ) ) : trimOnMultiply = self.trimOnMultiply
                    if( hasattr( v, &#39;trimOnMultiply&#39; ) ) : trimOnMultiply = trimOnMultiply and v.trimOnMultiply
                    if( trimOnMultiply ) : d.trim( )
            d.interpolation = min( self.interpolation, data.interpolation )
        return d

    def __rmul__( self, v ) :
        &quot;&quot;&quot;Same as __mul__( self, v ).&quot;&quot;&quot;

        return self.__mul__( v )

    def __div__( self, v ) :
        &quot;&quot;&quot;Returns an endl2dmath instance that is the same as self except every
    y value is divide by v (v must be a number or endl2dmath instance). If either the 
    variable endl2dmathClasses.doSafeDivide or endl2dmathClasses.doSafeDivideAlways 
    is True, then the y-value where a divide-by-zero occurs is replaced by 
    float( &#39;NaN&#39; ). Otherwise, a raise is triggered. Note, endl2dmathClasses.doSafeDivide
    is reset to False everytime __div__ is called, while endl2dmathClasses.doSafeDivideAlways
    is not.&quot;&quot;&quot;

        global doSafeDivide, doSafeDivideAlways
        _doSafeDivide = doSafeDivide or doSafeDivideAlways
        doSafeDivide = False
        if ( type( v ) == type( 1 ) ) or ( type( v ) == type( 1. ) ) :
            v = float( v )
            d = self.copyData( )
            for e in d.data : e[1] = e[1] / v
        else :
            data = endl2dmathmisc.valid2dClassType( v, &quot;endl2dmath.__div__&quot;, &quot;division&quot; )
            if ( len( self ) &lt; 1 ) :        # Nothing to divide
                d = self.copyData( )
            elif ( len( data ) &lt; 1 ) :
                raise Exception( &quot;\nError in endl2dmath.__div__: denominator is an empty object&quot; )
            else :
                d = data.slicex( xMin = self.xMin( ), xMax = self.xMax( ) )
                d = self.union( d )
                j = 0
                for p in d.data :
                    vp, j = data.GetValueNIndex( p[0], j )
                    try :
                        p[1] = p[1] / vp
                    except ZeroDivisionError :
                        if( _doSafeDivide ) :
                            p[1] = float( &#39;NaN&#39; )
                        else :
                            raise Exception( &quot;\nError in endl2dmath.__div__: Divide by zero at x = %.12e&quot; % p[0] )
                    except :
                        raise
            d.interpolation = min( self.interpolation, data.interpolation )
        return d

<div class="viewcode-block" id="endl2dmath.safeDivide"><a class="viewcode-back" href="../../../../fudge/fudge.legacy.endl.html#fudge.legacy.endl.endl2dmathClasses.endl2dmath.safeDivide">[docs]</a>    def safeDivide( self, other, fMaxValue = 10. ) :
        &quot;&quot;&quot;Like __div__ except it attemps to handle divide by removing the offending point and 
        adding near by points on either side. This routine also detects zeros in the denominator
        and adds near by points on either side. See __div__ for more information.&quot;&quot;&quot;

        global doSafeDivide
        def getMaxValue( y ) :
            &quot;&quot;&quot;For internal use only. Returns safeDivideMaxValue if argument is positive and -safeDivideMaxValue otherwise.&quot;&quot;&quot;

            if( y &lt; 0. ) : return( -safeDivideMaxValue )
            return( safeDivideMaxValue )

        def addPoint( self, safeData, flag, x1, x2, newOther, yMax ) :
            &quot;&quot;&quot;For internal use only. Adds a point near the zero of the denominator.&quot;&quot;&quot;

            eps = 1e-5
            if( abs( x2 - x1 ) &lt; eps * ( abs( x1 ) + abs( x2 ) ) ) : return
            if( flag == 1 ) :   # Add point just after x1.
                x = x1 + eps * ( x2 - x1 )
            else :              # Add point just before x2.
                x = x2 - eps * ( x2 - x1 )
            yo = newOther.getValue( x )
            ys = self.getValue( x )
            if( yo == 0. ) :
                y = yMax
                if( ys &lt; 0. ) : y = -yMax
            else :
                y = ys / yo
            safeData.append( [ x, y ] )

        if ( type( other ) == type( 1 ) ) or ( type( other ) == type( 1. ) ) :
            other = float( other )
            results = self.copyData( )
            if( doSafeDivide and ( other == 0. ) ) :
                for e in results.data :   e[1] = getMaxValue( e[1] )
            else :
                for e in results.data : e[1] = e[1] / other
        else :
            if( len( other ) == 0 ) :
                newOther = other
            else :
                other = other.copyData( )
                other.trim( )
                newOther = []
                y1 = other.data[0][1]
                for x2, y2 in other.data :
                    if( y2 * y1 &lt; 0 ) :                                     # Add the point between x1 and x2 where other&#39;s y-value is zero.
                        xZero = x1 - y1 * ( x2 - x1 ) / float( y2 - y1 )
                        newOther.append( [ xZero, 0. ] )
                    newOther.append( [ x2, y2 ] )
                    x1 = x2
                    y1 = y2
            newOther = endl2dmath( newOther, checkDataType = 0, template = self )
            doSafeDivide = True                                             # Note, this is automatically reset to false in __div__
            results = self / newOther
            yMin = None
            for xy in results.data :                                        # Find yMin, yMax and set all invalid (i.e., &#39;nan&#39;) y-values to None.
                x = xy[0]
                y = xy[1]
                if( not ( ( y &gt; -1. ) or ( y &lt; 1. ) ) ) :                   # Here I am relying on a bug? in python.
                    xy[1] = None
                    y = None
                if( not( y is None ) ) :
                    if( yMin is None ) :
                        yMin = y
                        yMax = y
                    else :
                        yMin = min( yMin, y )
                        yMax = max( yMax, y )
            yMax = max( abs( yMin ), abs( yMax ) ) * fMaxValue
            safeData = []
            if( len( results ) ) :
                x1, y1 = results.data[0]
                mode = 0
                if( y1 is None ) : mode = 1
                for x2, y2 in results.data :
                    if( y2 is None ) :
                        if( mode == 0 ) : addPoint( self, safeData, -1, x1, x2, newOther, yMax )  # Add point just before x2.
                        mode = 1
                    else :
                        if( mode == 1 ) : addPoint( self, safeData,  1, x1, x2, newOther, yMax )  # Add point just after x1.
                        mode = 0
                        safeData.append( [ x2, y2 ] )
                    x1 = x2
            results = endl2dmath( safeData, checkDataType = 0, template = results )
        return( results )</div>

    def __rdiv__( self, v ) :
        &quot;&quot;&quot;Returns an endl2dmath instance that is the same as self except every
    y value is v divided by y value (v must be a number).&quot;&quot;&quot;


        if ( type( v ) == type( 1 ) ) or ( type( v ) == type( 1. ) ) :
            v = float( v )
            d = self.copyData( )
            for e in d.data : e[1] = v / e[1]
        else :
            raise Exception( &quot;\nError in endl2dmath.__rdiv__: numerator must be a number.&quot; )

    def __pow__( self, p ) :
        &quot;&quot;&quot;Returns an endl2dmath instance whose y values are self&#39;s y values raised to the power p.&quot;&quot;&quot;

        d = self.copyData( )
        for xy in d.data : xy[1] = math.pow( xy[1], p )
        return d

    def __rpow__( self, p ) :
        &quot;&quot;&quot;Returns an endl2dmath instance whose y values are p raised to the power of self&#39;s y values.&quot;&quot;&quot;

        d = self.copyData( )
        for xy in d.data : xy[1] = math.pow( p, xy[1] )
        return d

<div class="viewcode-block" id="endl2dmath.GetValueNIndex"><a class="viewcode-back" href="../../../../fudge/fudge.legacy.endl.html#fudge.legacy.endl.endl2dmathClasses.endl2dmath.GetValueNIndex">[docs]</a>    def GetValueNIndex( self, x, i = 0 ) :
        &quot;&quot;&quot;Returns the tuple ( y, index ) where y is the value of self evaluated at x and
    index is the starting index to be used in the next call when ascending the list.
    I is the starting index.&quot;&quot;&quot;

        try :
            x = float( x )
        except :
            raise Exception( &quot;\nError in endl2dmath.GetValueNIndex: Index x not a number&quot; )
        if ( type( i ) == type( 1 ) ) :
            y = 0.
            if ( len( self ) &gt; 0 ) :
                if ( self.data[0][0] &lt;= x &lt;= self.data[-1][0] ) :
                    l = len( self )
                    while ( i &lt; l ) :
                        if ( x &lt;= self.data[i][0] ) : break
                        i = i + 1
                    if ( x == self.data[i][0] ) :
                        y = self.data[i][1]
                    else :
                        xy1 = self.data[i-1]
                        x1 = xy1[0]
                        y1 = xy1[1]
                        xy2 = self.data[i]
                        x2 = xy2[0]
                        y2 = xy2[1]
                        y = endl2dmathmisc.interpolate2dPoints( self.interpolation, x, x1, y1, x2, y2 )
            return ( y, i )
        else :
            raise Exception( &quot;\nError in endl2dmath.GetValueNIndex: i not an integer&quot; )</div>

<div class="viewcode-block" id="endl2dmath.toString"><a class="viewcode-back" href="../../../../fudge/fudge.legacy.endl.html#fudge.legacy.endl.endl2dmathClasses.endl2dmath.toString">[docs]</a>    def toString( self, format = None ) :
        &quot;&quot;&quot;Returns the string returned by the endl2dmath&#39;s __repr__ function. This can be useful when endl2dmath is used as a base class.&quot;&quot;&quot;

        endl2d_repr_xFormat = endl2dmathmisc.endl2d_repr_xFormat
        endl2d_repr_yFormat = endl2dmathmisc.endl2d_repr_yFormat
        if( not( format is None ) ) :
            endl2dmathmisc.endl2d_repr_xFormat = format
            endl2dmathmisc.endl2d_repr_yFormat = format
        s = endl2dmath.__repr__( self )
        endl2dmathmisc.endl2d_repr_xFormat = endl2d_repr_xFormat
        endl2dmathmisc.endl2d_repr_yFormat = endl2d_repr_yFormat
        return( s )</div>

<div class="viewcode-block" id="endl2dmath.toStringWithPrefixSuffix"><a class="viewcode-back" href="../../../../fudge/fudge.legacy.endl.html#fudge.legacy.endl.endl2dmathClasses.endl2dmath.toStringWithPrefixSuffix">[docs]</a>    def toStringWithPrefixSuffix( self, Prefix = &quot;&quot;, Suffix = &quot;&quot; ) :
        &quot;&quot;&quot;Returns a printable string of the data in self with Prefix and Suffix append to each line.&quot;&quot;&quot;

        xy = &quot;%s %s&quot; % ( endl2dmathmisc.endl2d_repr_xFormat, endl2dmathmisc.endl2d_repr_yFormat )
        s = [ xy % ( x, y ) for x, y in self.data ]
        return fudgemisc.stringWithPrefixSuffix( s, Prefix, Suffix )</div>

<div class="viewcode-block" id="endl2dmath.clip"><a class="viewcode-back" href="../../../../fudge/fudge.legacy.endl.html#fudge.legacy.endl.endl2dmathClasses.endl2dmath.clip">[docs]</a>    def clip( self, yMin, yMax ) :
        &quot;&quot;&quot;Returns an endl2dmath object whose y values are self&#39;s y values clipped to be between yMin and yMax.&quot;&quot;&quot;

        if( yMin &gt;= yMax ) : raise Exception( &quot;\nError in endl2dmath.clip: yMin must be less than yMax.&quot; )
        d = []
        Mode = 0
        for x, y in self.data :
            if(   y &lt; yMin ) :
                yp = yMin
                if( ( Mode == 2 ) or ( Mode == 3 ) ) :
                    if( x != x1 ) :
                        xp = ( yp - y1 ) * ( x - x1 ) / ( y - y1 ) + x1
                        d.append( [ xp, yp ] )
                Mode = 1
            elif( y &lt;= yMax ) :
                yp = y
                if  ( Mode == 1 ) :
                    if( x != x1 ) :
                        xp = ( yMin - y1 ) * ( x - x1 ) / ( y - y1 ) + x1
                        d.append( [ xp, yMin ] )
                elif( Mode == 3 ) :
                    if( x != x1 ) :
                        xp = ( yMax - y1 ) * ( x - x1 ) / ( y - y1 ) + x1
                        d.append( [ xp, yMax ] )
                Mode = 2
            else :
                yp = yMax
                if( ( Mode == 1 ) or ( Mode == 2 ) ) :
                    if( x != x1 ) :
                        xp = ( yp - y1 ) * ( x - x1 ) / ( y - y1 ) + x1
                        d.append( [ xp, yp ] )
                Mode = 3
            d.append( [ x, yp ] )
            x1 = x
            y1 = y
        return( endl2dmath( d, checkDataType = 0, template = self ) )</div>

<div class="viewcode-block" id="endl2dmath.cmp"><a class="viewcode-back" href="../../../../fudge/fudge.legacy.endl.html#fudge.legacy.endl.endl2dmathClasses.endl2dmath.cmp">[docs]</a>    def cmp( self, other, f = 5.e-5 ) :
        &quot;&quot;&quot;Compares self to other and prints out data where they differ by more than f.&quot;&quot;&quot;

        l1 = len( self )
        l2 = len( other )
        i1, i2 = 0, 0
        while ( i1 &lt; l1 ) and ( i2 &lt; l2 ) :
            if ( self.data[i1][0] == other.data[i2][0] ) :
                d = self.relativediff( other, i1, i2 )
                if ( abs( d ) &gt; f ) : print &quot;i1 = %5d i2 = %5d   %.5e %.5e %.5e %+.5e %+.5e&quot; % \
                (i1, i2, self.data[i1][0], self.data[i1][1], other.data[i2][1], self.data[i1][1] - other.data[i2][1], d)
                i1 = i1 + 1
                i2 = i2 + 1
            elif ( self.data[i1][0] &lt; other.data[i2][0] ) :
                print &quot;Extra E in  self: i1 = %5d %.5e %.5e&quot; % ( i1, self.data[i1][0], self.data[i1][1] )
                i1 = i1 + 1
            else :
                print &quot;Extra E in other: i2 = %5d %.5e %.5e&quot; % ( i2, other.data[i2][0], other.data[i2][1] )
                i2 = i2 + 1</div>

<div class="viewcode-block" id="endl2dmath.convolution"><a class="viewcode-back" href="../../../../fudge/fudge.legacy.endl.html#fudge.legacy.endl.endl2dmathClasses.endl2dmath.convolution">[docs]</a>    def convolution( self, other, dxMax = None, convolutionMethod = None, interpolationAccuracy = 1e-2 ) :
        &quot;&quot;&quot;Returns an endl2dmath instance that is a convolution of self and other. convolutionMethod
        can be None or &#39;pythonCodingV1&#39;. If None and module fudgeConvolutions exist then function
        fudgeConvolutions.convolution will be used; otherwise, the slow, original python code will be 
        used. If interpolationAccuracy is not None then the endl2dmath.thin method is called with
        interpolationAccuracy = interpolationAccuracy.&quot;&quot;&quot;

        def convoluteGH( start, end, x, g, h, hxMax, lastx, convolute ) :
            &quot;&quot;&quot;Performs the convolution of g * h starting at x in g. The x-range of g must be greater
            than or equal to that of h.&quot;&quot;&quot;

            dx = h[-1][0] - h[0][0]
            xEnd = x + dx
            if( xEnd &gt; g[end][0] ) : xEnd = g[end][0]           # In case of round-off problem from previous line.
            while( g[end][0] &lt; xEnd ) : end += 1
            value = 0.
            gx1, gy1 = g[start]
            start += 1
            gx2, gy2 = g[start]
            if( gx1 &lt; x ) :
                gyp1 = ( gy2 * ( x - gx1 ) + gy1 * ( gx2 - x ) ) / float( gx2 - gx1 )
            else :
                gyp1 = gy1
            hx1 = None
            for hx2, hy2 in h :
                x2 = x + hx2
                if( x2 &gt; xEnd ) : x2 = xEnd                     # In case of round-off problem from previous line.
                if( not( hx1 is None ) ) :
                    doMore = True
                    while( doMore ) :
                        if( gx2 &lt; x2 ) :
                            xp2, gyp2 = gx2, gy2
                            hyp2 = ( hy2 * ( ( gx2 - x ) - hx1 ) + hy1 * ( hx2 - ( gx2 - x ) ) ) / float( hx2 - hx1 )
                            gx1, gy1 = gx2, gy2
                            if( gx2 &lt; xEnd ) : start += 1
                            gx2, gy2 = g[start]
                        else :
                            doMore = False
                            xp2 = x2
                            if( gx2 == x2 ) :
                                gyp2 = gy2
                                gx1, gy1 = gx2, gy2
                                if( gx2 &lt; xEnd ) : start += 1
                                gx2, gy2 = g[start]
                            else :
                                gyp2 = ( gy2 * ( x2 - gx1 ) + gy1 * ( gx2 - x2 ) ) / float( gx2 - gx1 )
                            hyp2 = hy2
                        value += ( xp2 - xp1 ) * ( ( gyp2 + gyp1 ) * ( hyp2 + hyp1 ) + gyp1 * hyp1 + gyp2 * hyp2 )
                        xp1 = xp2
                        gyp1 = gyp2
                        hyp1 = hyp2
                xp1 = x1 = x2
                hx1 = hx2
                hyp1 = hy1 = hy2
            value /= 6.
            convolute.append( [ x + hxMax, value ] )

        if( convolutionMethod not in [ None, &#39;pythonCodingV1&#39; ] ) :
            fudgemisc.printWarning( &#39;Bad convolutionMethod argument to method endl2dmath.convolution in module endl2dmathClasses. &#39; + \
                &#39;Using convolutionMethod = None&#39; )
            convolutionMethod = None
        if( convolutionMethod is None ) :
            try :
                import fudgeConvolutions
            except :
                convolutionMethod = &#39;pythonCodingV1&#39;
            else :
                if( dxMax is None ) : dxMax = 0.
                convolute = fudgeConvolutions.convolution( self.data, other.data, dxMax = dxMax )
        if( convolutionMethod == &#39;pythonCodingV1&#39; ) :
            if( numpyImported == False ) : raise fudgeExceptions.ENDL_numpyException( 
                &quot;numpy was not in python search path, cannot use endl2dmath.convolution.&quot; )
            convolute = []
            if( ( len( self ) &gt; 1 ) and ( len( other ) &gt; 1 ) ) :
                dx1 = self.xMax( ) - self.xMin( )
                dx2 = other.xMax( ) - other.xMin( )
                if( dx1 &gt;= dx2 ) :
                    dx = dx2
                    g = self
                    h = other
                else :
                    dx = dx1
                    g = other
                    h = self
                if( dx &gt; 0. ) :
                    h = numpy.array( h.data )
                    g = numpy.array( g.data )
                    hxMin = h[0][0]
                    hxMax = h[-1][0]
                    gxMin = g[0][0]
                    gxMax = g[-1][0]
                    up = 0
                    down = len( h ) - 1
                    while( up &lt; down ) :                            # Reverse x-data as we need h(y-x).
                        x, y = h[down]
                        h[down] = h[up]
                        h[up] = x, y
                        up += 1
                        down -= 1
                    for xy in h : xy[0] = hxMax - xy[0]
                    if( dxMax is None ) : dxMax = dx / 50.
                    start = 0
                    n = len( g ) - 1
                    x = g[0][0]
                    end = 1
                    while( ( g[end][0] &lt; x + dx ) and ( end &lt; n ) ) : end += 1
                    convoluteGH( start, end, x, g, h, hxMax, x, convolute )
                    while( start &lt; n ) :
                        lastx = x
                        x = min( x + dxMax, g[n][0] - dx )
                        if( abs( x - lastx ) &lt;= 1e-10 * ( abs( x ) + abs( lastx ) ) ) : break
                        if( g[start+1][0] &lt;= x ) :
                            start += 1
                            x = g[start][0]
                        if( lastx == x ) : continue
                        while( ( g[end][0] &lt; x + dx ) and ( end &lt; n ) ) : end += 1
                        convoluteGH( start, end, x, g, h, hxMax, lastx, convolute )
        convolute = endl2dmath( convolute, checkDataType = 0 )
        if( not( interpolationAccuracy is None ) ) :
            convolute = convolute.thin( interpolationAccuracy = interpolationAccuracy )
        return( convolute )</div>

<div class="viewcode-block" id="endl2dmath.copyData"><a class="viewcode-back" href="../../../../fudge/fudge.legacy.endl.html#fudge.legacy.endl.endl2dmathClasses.endl2dmath.copyData">[docs]</a>    def copyData( self ) :
        &quot;&quot;&quot;Returns an endl2dmath instance that is a copy, and not a reference, of self.&quot;&quot;&quot;

        d = []
        for xy in self.data : d.append( [ xy[0], xy[1] ] )
        return endl2dmath( d, checkDataType = 0, template = self )</div>

<div class="viewcode-block" id="endl2dmath.exp"><a class="viewcode-back" href="../../../../fudge/fudge.legacy.endl.html#fudge.legacy.endl.endl2dmathClasses.endl2dmath.exp">[docs]</a>    def exp( self ) :
        &quot;&quot;&quot;Returns an endl2dmath instance that has all y values of self exponentiated.&quot;&quot;&quot;

        d = self.copyData( )
        for xy in d.data : xy[1] = math.exp( xy[1] )
        return d</div>

<div class="viewcode-block" id="endl2dmath.getDimensions"><a class="viewcode-back" href="../../../../fudge/fudge.legacy.endl.html#fudge.legacy.endl.endl2dmathClasses.endl2dmath.getDimensions">[docs]</a>    def getDimensions( self ) :
        &quot;&quot;&quot;Returns the dimensions (2 for endl2dmath) for this type of data.&quot;&quot;&quot;

        return( 2 )</div>

    @property
    def dimension( self ) :

        return( self.getDimensions( ) )

<div class="viewcode-block" id="endl2dmath.domain"><a class="viewcode-back" href="../../../../fudge/fudge.legacy.endl.html#fudge.legacy.endl.endl2dmathClasses.endl2dmath.domain">[docs]</a>    def domain( self ) :
        &quot;&quot;&quot;Returns the domain (minumum and maximum x values) for self.&quot;&quot;&quot;

        return( self.xMin( ), self.xMax( ) )</div>

<div class="viewcode-block" id="endl2dmath.getValue"><a class="viewcode-back" href="../../../../fudge/fudge.legacy.endl.html#fudge.legacy.endl.endl2dmathClasses.endl2dmath.getValue">[docs]</a>    def getValue( self, x ) :
        &quot;&quot;&quot;Returns self&#39;s y value evaluated at x.  If x is outside the range
        of self&#39;s x domain then 0. is returned. Also see getValueInDomain.&quot;&quot;&quot;

        return self.GetValueNIndex( x )[0]</div>

<div class="viewcode-block" id="endl2dmath.getValueInDomain"><a class="viewcode-back" href="../../../../fudge/fudge.legacy.endl.html#fudge.legacy.endl.endl2dmathClasses.endl2dmath.getValueInDomain">[docs]</a>    def getValueInDomain( self, x ) :
        &quot;&quot;&quot;Returns self&#39;s y value evaluated at x.  If x is outside the range
        of self&#39;s x domain then None is returned. Also see getValue.&quot;&quot;&quot;

        if( ( len( self ) == 0 ) or ( x &lt; self.xMin( ) ) or ( x &gt; self.xMax( ) ) ) : return( None )
        return self.GetValueNIndex( x )[0]</div>

<div class="viewcode-block" id="endl2dmath.integrateX"><a class="viewcode-back" href="../../../../fudge/fudge.legacy.endl.html#fudge.legacy.endl.endl2dmathClasses.endl2dmath.integrateX">[docs]</a>    def integrateX( self, xArray = None, weight = None, normalize = 0 ) :
        &quot;&quot;&quot;Returns an endl1dmath object of length len( xArray ) - 1 whose value at index i
    is the integral of self from xArray[i] to xArray[i+1].  If xArray is none then 
    the x values of self are used for xArray.  If Normailzie is non-zero the value 
    at index i is divided by the x interval xArray[i+1] - xArray[i]. If weight is not 
    equal to None, weigth must be an endl2dmath object, and the integral is of self * weight.&quot;&quot;&quot;

        if( ( xArray is None ) and not( weight is None ) ) : xArray = self.xArray( )
        if( xArray is None ) :
            d = []
            ix = 0
            for xy in self.data :
                if ( ix != 0 ) :
                    if ( normalize ) :
                        d.append( 0.5 * ( xy[1] + y1 ) )
                    else :
                        d.append( 0.5 * ( xy[0] - x1 ) * ( xy[1] + y1 ) )
                x1 = xy[0]
                y1 = xy[1]
                ix += 1
        else :
            nx = len( xArray )
            if ( nx &lt; 2 ) :
                d = []
            elif ( ( len( self.data ) &lt; 2 ) or ( self.data[0][0] &gt;= xArray[-1] ) or ( self.data[-1][0] &lt;= xArray[0] ) ) :
                d = ( nx - 1 ) * [0.]
            else :
                if( weight is None ) :
                    ixy = []
                    for x in xArray : ixy.append( [ x, 0. ] )
                    ixy = endl2dmath( ixy, checkDataType = False )
                    s = self.copyData( )
                    if ( ( self.data[ 0][1] != 0. ) and ( self.data[ 0][0] &gt; xArray[ 0] ) ) : s.data.insert( 0, [ self.data[ 0][0], 0. ] )
                    if ( ( self.data[-1][1] != 0. ) and ( self.data[-1][0] &lt; xArray[-1] ) ) : s.data.append(    [ self.data[-1][0], 0. ] )
                    ixy = s.union( ixy )
                    iixy = 0
                    for xy in ixy.data :                    # Find index to start integration in ixy.
                        if ( xy[0] == xArray[0] ) : break
                        iixy += 1
                    xy1 = ixy.data[iixy]
                    iixy += 1
                    ix = 1
                    d = []
                    while ( ix &lt; nx ) :                     # Do integration for each energy group.
                        x = xArray[ix]
                        sum = 0
                        while ( xy1[0] &lt; x ) :
                            xy2 = ixy.data[iixy]
                            sum += ( xy2[0] - xy1[0] ) * ( xy2[1] + xy1[1] )
                            xy1 = xy2
                            iixy += 1
                        if ( normalize ) : sum /= ( xArray[ix] - xArray[ix-1] )
                        d.append( 0.5 * sum )
                        ix += 1
                else :
                    endl2dmathmisc.valid2dClassType( weight, &quot;endl2dmath.integrateX&quot;, &quot;weight&quot; )
                    xMin = max( self.xMin( ), weight.xMin( ) )
                    xMax = min( self.xMax( ), weight.xMax( ) )
                    a = self.slicex( xMin = xMin, xMax = xMax )
                    c = weight.slicex( xMin = xMin, xMax = xMax )
                    a = a.union( c )
                    b = a.copyData( )
                    b.map( c )                              # self and weight are now a and b with the same x values.
                    ixy = []
                    for x in xArray : ixy.append( [ x, 0. ] )
                    ixy = endl2dmath( ixy, checkDataType = False )
                    s = self.copyData( )
                    if ( ( self.data[ 0][1] != 0. ) and ( self.data[ 0][0] &gt; xArray[ 0] ) ) : s.data.insert( 0, [ self.data[ 0][0], 0. ] )
                    if ( ( self.data[-1][1] != 0. ) and ( self.data[-1][0] &lt; xArray[-1] ) ) : s.data.append(    [ self.data[-1][0], 0. ] )
                    ixy = s.union( ixy )
                    iixy = 0
                    for xy in ixy.data :                    # Find index to start integration in ixy.
                        if ( xy[0] == xArray[0] ) : break
                        iixy += 1
                    xy1 = ixy.data[iixy]
                    iixy += 1
                    ix = 1
                    d = []
                    while ( ix &lt; nx ) :                     # Do integration for each energy group.
                        x = xArray[ix]
                        sum = 0
                        while ( xy1[0] &lt; x ) :
                            xy2 = ixy.data[iixy]
                            sum += ( xy2[0] - xy1[0] ) * ( xy2[1] + xy1[1] )
                            xy1 = xy2
                            iixy += 1
                        if ( normalize ) : sum /= ( xArray[ix] - xArray[ix-1] )
                        d.append( 0.5 * sum )
                        ix += 1
        return endl1dmathClasses.endl1dmath( d )</div>

<div class="viewcode-block" id="endl2dmath.integrateOneFunction"><a class="viewcode-back" href="../../../../fudge/fudge.legacy.endl.html#fudge.legacy.endl.endl2dmathClasses.endl2dmath.integrateOneFunction">[docs]</a>    def integrateOneFunction( self, xMin = None, xMax = None ) :
        &quot;&quot;&quot;Returns the integral of self from xMin to xMax.&quot;&quot;&quot;

        if( xMin is None ) : xMin = self.xMin( )
        if( xMax is None ) : xMax = self.xMax( )
        xMin = max( xMin, self.xMin( ) )
        xMax = min( xMax, self.xMax( ) )
        self_ = XYsModule.XYs( self.data, axes = XYsModule.XYs.defaultAxes( ) )
        return( float( self_.integrate( xMin, xMax ) ) )</div>

<div class="viewcode-block" id="endl2dmath.integrateTwoFunctions"><a class="viewcode-back" href="../../../../fudge/fudge.legacy.endl.html#fudge.legacy.endl.endl2dmathClasses.endl2dmath.integrateTwoFunctions">[docs]</a>    def integrateTwoFunctions( self, other, xMin = None, xMax = None ) :
        &quot;&quot;&quot;Returns the integral of self and other from xMin to xMax.&quot;&quot;&quot;

        endl2dmathmisc.valid2dClassType( other, &quot;endl2dmath.integrateTwoFunctions&quot;, &quot;other&quot; )
        if( xMin is None ) : xMin = self.xMin( )
        if( xMax is None ) : xMax = self.xMax( )
        xMin = max( xMin, self.xMin( ), other.xMin( ) )
        xMax = min( xMax, self.xMax( ), other.xMax( ) )
        self_ = XYsModule.XYs( self.data, axes = XYsModule.XYs.defaultAxes( ) )
        other_ = XYsModule.XYs( other.data, axes = XYsModule.XYs.defaultAxes( ) )
        return( self_.integrateTwoFunctions( other_, xMin, xMax ) )</div>

<div class="viewcode-block" id="endl2dmath.integrateThreeFunctions"><a class="viewcode-back" href="../../../../fudge/fudge.legacy.endl.html#fudge.legacy.endl.endl2dmathClasses.endl2dmath.integrateThreeFunctions">[docs]</a>    def integrateThreeFunctions( self, other1, other2, xMin = None, xMax = None ) :
        &quot;&quot;&quot;Returns the integral of self, other1 and other2 from xMin to xMax.&quot;&quot;&quot;

        endl2dmathmisc.valid2dClassType( other1, &quot;endl2dmath.integrateThreeFunctions&quot;, &quot;other1&quot; )
        endl2dmathmisc.valid2dClassType( other2, &quot;endl2dmath.integrateThreeFunctions&quot;, &quot;other2&quot; )
        if( xMin is None ) : xMin = self.xMin( )
        if( xMax is None ) : xMax = self.xMax( )
        xMin = max( xMin, self.xMin( ), other1.xMin( ), other1.xMin( ) )
        xMax = min( xMax, self.xMax( ), other1.xMax( ), other2.xMax( ) )
        self_ = XYsModule.XYs( self.data, axes = XYsModule.XYs.defaultAxes( ) )
        other1_ = XYsModule.XYs( other1.data, axes = XYsModule.XYs.defaultAxes( ) )
        other2_ = XYsModule.XYs( other2.data, axes = XYsModule.XYs.defaultAxes( ) )
        return( self_.integrateThreeFunctions( other1_, other2_, xMin, xMax ) )</div>

<div class="viewcode-block" id="endl2dmath.union"><a class="viewcode-back" href="../../../../fudge/fudge.legacy.endl.html#fudge.legacy.endl.endl2dmathClasses.endl2dmath.union">[docs]</a>    def union( self, other, xDomainUnionOnly = False ) :
        &quot;&quot;&quot;Returns an endl2dmath instance with its x values being a union of self&#39;s
    and other&#39;s x values.  The y values are self&#39;s y values mapped onto
    the union&#39;s x values. If xDomainUnionOnly is True then only the x domain
    common to self and other is returned.&quot;&quot;&quot;

        d1 = self.data
        n1 = len( d1 )
        d2 = endl2dmathmisc.valid2dClassType( other, &quot;endl2dmath.union&quot;, &quot;intersecting&quot; ).data
        n2 = len( d2 )
        d = []
        if( ( n1 != 0 ) or ( n2 != 0 ) ) :
            i1 = 0
            i2 = 0
            if( n1 != 0 ) :
                x1 = d1[i1][0]
            else :
                x1 = d2[i2][0]
            if( n2 != 0 ) :
                x2 = d2[i2][0]
            else :
                x2 = d1[i1][0]
            if( xDomainUnionOnly ) :
                if( x1 &lt; x2 ) :
                    while( i1 &lt; n1 ) :
                        x1 = d1[i1][0]
                        if( x2 &lt;= x1 ) : break
                        i1 += 1
                elif( x1 &gt; x2 ) :
                    while( i2 &lt; n2 ) :
                        x2 = d2[i2][0]
                        if( x1 &lt;= x2 ) : break
                        i2 += 1
            j = 0
            while( ( i1 &lt; n1 ) and ( i2 &lt; n2 ) ) :
                if( x1 &lt;= x2 ) :
                    d.append( [ x1, d1[i1][1] ] )
                    if( x1 == x2 ) :
                        i2 += 1
                        if ( i2 &lt; n2 ) : x2 = d2[i2][0]
                    i1 += 1
                    if( i1 &lt; n1 ) : x1 = d1[i1][0]
                else :
                    ( y, j ) = self.GetValueNIndex( x2, j )
                    d.append( [ x2, y ] )
                    i2 += 1
                    if ( i2 &lt; n2 ) : x2 = d2[i2][0]
            if( not xDomainUnionOnly ) :
                while( i1 &lt; n1 ) :
                    d.append( [ d1[i1][0], d1[i1][1] ] )
                    i1 += 1
                while( i2 &lt; n2 ) :
                    x2 = d2[i2][0]
                    ( y, j ) = self.GetValueNIndex( x2, j )
                    d.append( [ x2, y ] )
                    i2 += 1
        d = endl2dmath( d, checkDataType = 0, template = self )
        return d</div>

<div class="viewcode-block" id="endl2dmath.log"><a class="viewcode-back" href="../../../../fudge/fudge.legacy.endl.html#fudge.legacy.endl.endl2dmathClasses.endl2dmath.log">[docs]</a>    def log( self ) :
        &quot;&quot;&quot;Returns an endl2dmath instance that has all y values of self log_e-ed.&quot;&quot;&quot;

        d = self.copyData( )
        for xy in d.data : xy[1] = math.log( xy[1] )
        return d</div>

<div class="viewcode-block" id="endl2dmath.log10"><a class="viewcode-back" href="../../../../fudge/fudge.legacy.endl.html#fudge.legacy.endl.endl2dmathClasses.endl2dmath.log10">[docs]</a>    def log10( self ) :
        &quot;&quot;&quot;Returns an endl2dmath instance that has all y values of self log10_e-ed.&quot;&quot;&quot;

        d = self.copyData( )
        for xy in d.data : xy[1] = math.log10( xy[1] )
        return d</div>

<div class="viewcode-block" id="endl2dmath.max"><a class="viewcode-back" href="../../../../fudge/fudge.legacy.endl.html#fudge.legacy.endl.endl2dmathClasses.endl2dmath.max">[docs]</a>    def max( self ) :
        &quot;&quot;&quot;Returns the maximum y value of self of None if self is empty.&quot;&quot;&quot;

        if( len( self ) == 0 ) :
            m = None
        else :
            m = self.data[0][1]
            for x, y in self.data :
                if( y &gt; m ) : m = y
        return m</div>

<div class="viewcode-block" id="endl2dmath.min"><a class="viewcode-back" href="../../../../fudge/fudge.legacy.endl.html#fudge.legacy.endl.endl2dmathClasses.endl2dmath.min">[docs]</a>    def min( self ) :
        &quot;&quot;&quot;Returns the minimum y value of self or None if self is empty.&quot;&quot;&quot;

        if( len( self ) == 0 ) :
            m = None
        else :
            m = self.data[0][1]
            for x, y in self.data :
                if( y &lt; m ) : m = y
        return m</div>

<div class="viewcode-block" id="endl2dmath.map"><a class="viewcode-back" href="../../../../fudge/fudge.legacy.endl.html#fudge.legacy.endl.endl2dmathClasses.endl2dmath.map">[docs]</a>    def map( self, other ) :
        &quot;&quot;&quot;Sets self&#39;s y values to other evaluated at self&#39;s x values.&quot;&quot;&quot;

        j = 0
        for d in self.data : ( d[1], j ) = other.GetValueNIndex( d[0], j )</div>

<div class="viewcode-block" id="endl2dmath.label"><a class="viewcode-back" href="../../../../fudge/fudge.legacy.endl.html#fudge.legacy.endl.endl2dmathClasses.endl2dmath.label">[docs]</a>    def label( self ) :
        &quot;&quot;&quot;Returns self&#39;s label.&quot;&quot;&quot;

        return( self.label )</div>

<div class="viewcode-block" id="endl2dmath.normalize"><a class="viewcode-back" href="../../../../fudge/fudge.legacy.endl.html#fudge.legacy.endl.endl2dmathClasses.endl2dmath.normalize">[docs]</a>    def normalize( self ) :
        &quot;&quot;&quot;Returns an endl2dmath instance that is the same as self normalized to 1. This, is
        the integral of dx y(x) is 1.&quot;&quot;&quot;

        d = self.copyData( )
        sum = 0.
        x1 = None
        for x2, y2 in d.data :
            if( not( x1 is None ) ) : sum += ( x2 - x1 ) * ( y2 + y1 )
            x1 = x2
            y1 = y2
        sum /= 2.
        if( sum != 0 ) :
            for xy in d.data : xy[1] /= sum
        return( d )</div>


<div class="viewcode-block" id="endl2dmath.overstrike"><a class="viewcode-back" href="../../../../fudge/fudge.legacy.endl.html#fudge.legacy.endl.endl2dmathClasses.endl2dmath.overstrike">[docs]</a>    def overstrike( self, other, leftFill = 1, rightFill = 1 ) :
        &quot;&quot;&quot;Returns an endl2dmath instance that is the same as self, except that the data from
    other.xMin to other.xMax is replaced by other&#39;s data.  Other must be an endl2dmath object.
    If leftFill is true then a point at other.xMin * ( 1. - endlParameters.endlEpsx ) is inserted 
    with y value of self at that x value.  If rightFill is true then a point at other.xMax * 
    ( 1. + endlParameters.endlEpsx ) is inserted  with y value of self at that x value.&quot;&quot;&quot;

        d = []
        endl2dmathmisc.valid2dClassType( other, &quot;endl2dmath.overstrike&quot;, &quot;&quot; )
        if ( len( other ) == 0 ) :
            for xy in self.data : d.append( [ xy[0], xy[1] ] )
        else :
            i = 0
            n = len( self.data )
            xMin = other.data[0][0] * ( 1. - endlParameters.endlEpsx )
            while ( i &lt; n ) :                                   # Add self&#39;s points that are less than other&#39;s xMin.
                xy = self.data[i]
                if ( xy[0] &gt;= xMin ) : break
                d.append( [ xy[0], xy[1] ] )
                i += 1
            if ( leftFill and ( i &gt; 0 ) and ( i &lt; n ) ) : d.append( [ xMin, self.getValue( xMin ) ] )
            for xy in other.data : d.append( [ xy[0], xy[1] ] ) # Add in other&#39;s points
            xMax = other.data[-1][0] * ( 1. + endlParameters.endlEpsx )
            while ( i &lt; n ) :
                xy = self.data[i]
                if ( xy[0] &gt; xMax ) : break
                i += 1
            if ( rightFill and ( i &gt; 0 ) and ( i &lt; n ) ) : d.append( [ xMax, self.getValue( xMax ) ] )
            while ( i &lt; n ) :                                   # Add self&#39;s points that are greater than other&#39;s xMax.
                xy = self.data[i]
                d.append( [ xy[0], xy[1] ] )
                i += 1
        return endl2dmath( d, checkDataType = 0, template = self )</div>

<div class="viewcode-block" id="endl2dmath.plot"><a class="viewcode-back" href="../../../../fudge/fudge.legacy.endl.html#fudge.legacy.endl.endl2dmathClasses.endl2dmath.plot">[docs]</a>    def plot( self, xMin = None, xMax = None, yMin = None, yMax = None, xylog = 0, xLabel = None, yLabel = None, 
        title = None, style = &quot;lines&quot; ) :
        &quot;&quot;&quot;
        This routine is like qplot (quick plot) except it spawns an interactive plot.
        qplot is faster while plot is more flexible.

        xylog interpolation values and meaning::

            xylog   plot-type
           -----------------------
              0     linear-linear
              1     log-linear
              2     linear-log
              3     log-log
        &quot;&quot;&quot;

        if ( xLabel is None ) and not( self.xLabel is None ) : xLabel = self.xLabel
        if ( yLabel is None ) and not( self.yLabel is None ) : yLabel = self.yLabel
        dt = plotbase.parsePlotOptions( xMin, xMax, yMin, yMax, xLabel, yLabel, title )
        f = fudgeFileMisc.fudgeTempFile( )
        for p in self.data : f.write( &quot;%15.7e %14.6e\n&quot; % ( p[0], p[1] ) )
        f.close( )
        p = os.path.join( __file__.split( &#39;fudge/legacy/&#39; )[0], &quot;fudge&quot;, &quot;vis&quot;, &quot;gnuplot&quot;, &quot;endl2dplot.py&quot; )
        s = [ &#39;python&#39;, p, &#39;xylog&#39;, str( xylog ) ] + dt + [ f.getName( ) ]
        subprocessing.spawn( s )</div>

<div class="viewcode-block" id="endl2dmath.qplot"><a class="viewcode-back" href="../../../../fudge/fudge.legacy.endl.html#fudge.legacy.endl.endl2dmathClasses.endl2dmath.qplot">[docs]</a>    def qplot( self, xMin = None, xMax = None, yMin = None, yMax = None, xylog = 0, xLabel = None, yLabel = None,
        title = None, style = &quot;lines&quot; ) :
        &quot;&quot;&quot;Also see plot( ).

        xylog interpolation values and meaning::

            xylog   plot-type
           -----------------------
              0     linear-linear
              1     log-linear
              2     linear-log
              3     log-log
        &quot;&quot;&quot;

        import Gnuplot
        xylog = int( xylog )            # Allow argument to be a string
        if( not( xMin is None ) ) : xMin = float( xMin )
        if( not( xMax is None ) ) : xMax = float( xMax )
        if( not( yMin is None ) ) : yMin = float( yMin )
        if( not( yMax is None ) ) : yMax = float( yMax )

        self.g = Gnuplot.Gnuplot( )
        self.g( &#39;set style data %s&#39; % style )
        xylog = xylog % 4
        if ( len( self.data ) &gt; 0 ) :
            mx = self.data[0][0]
            my = self.data[0][1]
            for d in self.data :
                mx = min( mx, d[0] )
                my = min( my, d[1] )
            if ( mx &lt;= 0. ) and ( xylog % 2 == 1 ) : xylog = xylog - 1
            if ( my &lt;= 0. ) and ( xylog &gt; 1 ) : xylog = xylog - 2
        if   ( xylog == 1 ) : self.g( &#39;set logscale x&#39; )
        elif ( xylog == 2 ) : self.g( &#39;set logscale y&#39; )
        elif ( xylog == 3 ) : self.g( &#39;set logscale xy&#39; )
        if( not( xMin is None ) or not( xMax is None ) ) :
            xMin = `xMin`
            if ( xMin == &quot;None&quot; ) : xMin = &quot;*&quot;
            xMax = `xMax`
            if ( xMax == &quot;None&quot; ) : xMax = &quot;*&quot;
            self.g( &quot;set xrange [ %s : %s ]&quot; % ( xMin, xMax ) )
        if( not( yMin is None ) or not( yMax is None ) ) :
            yMin = `yMin`
            if ( yMin == &quot;None&quot; ) : yMin = &quot;*&quot;
            yMax = `yMax`
            if ( yMax == &quot;None&quot; ) : yMax = &quot;*&quot;
            self.g( &quot;set yrange [ %s : %s ]&quot; % ( yMin, yMax ) )
        if( ( xLabel is None ) and not( self.xLabel is None ) ) : xLabel = `self.xLabel`
        if( not( xLabel is None ) ) : self.g( &quot;set xlabel %s&quot; % `xLabel` )
        if( ( yLabel is None ) and not( self.yLabel is None ) ) : yLabel = `self.yLabel`
        if( not( yLabel is None ) ) : self.g( &quot;set ylabel %s&quot; % `yLabel` )
        if( not( title  is None ) ) : self.g( &quot;set title %s&quot; % `title` )
        self.g.plot( self.data )</div>

<div class="viewcode-block" id="endl2dmath.relativediff"><a class="viewcode-back" href="../../../../fudge/fudge.legacy.endl.html#fudge.legacy.endl.endl2dmathClasses.endl2dmath.relativediff">[docs]</a>    def relativediff( self, other, i1, i2 ) :
        &quot;&quot;&quot;Compares self&#39;s y value at i1 to other&#39;s y value at i2.  Mainly for internal use.&quot;&quot;&quot;

        d = ( self.data[i1][1] - other.data[i2][1] )
        if ( abs( d ) &gt; 0 ) : d = 2 * d / ( abs( self.data[i1][1] ) + abs( other.data[i2][1] ) )
        return d</div>

<div class="viewcode-block" id="endl2dmath.removeClosePoints"><a class="viewcode-back" href="../../../../fudge/fudge.legacy.endl.html#fudge.legacy.endl.endl2dmathClasses.endl2dmath.removeClosePoints">[docs]</a>    def removeClosePoints( self, verbose = 0 ) :
        &quot;&quot;&quot;Calls endl2dmathmisc.check2dData and removes all points that check2dData claims are too close.&quot;&quot;&quot;

        ne, badXIndicies, messages = endl2dmathmisc.check2dData( self,  printErrors = False, printWarning = False )
        badXIndicies.reverse( )
        for i in badXIndicies :
            if( verbose ) : fudgemisc.printWarning( &quot;    removing point at index %d with x value = %e&quot; % ( i, self.data[i][0] ) )
            del self.data[i]</div>

<div class="viewcode-block" id="endl2dmath.reversex"><a class="viewcode-back" href="../../../../fudge/fudge.legacy.endl.html#fudge.legacy.endl.endl2dmathClasses.endl2dmath.reversex">[docs]</a>    def reversex( self ) :
        &quot;&quot;&quot;Returns an endl2dmath instance whose list of [x,y] has been reversed. For example, the data
        [ [1, 2], [3, 3], [4, 5], [6, 3] ] becomes [ [6, 3], [4, 5], [3, 3], [1, 2] ].&quot;&quot;&quot;

        d = self.copyData( )
        d.data.reverse( )
        return( d )</div>


<div class="viewcode-block" id="endl2dmath.scalex"><a class="viewcode-back" href="../../../../fudge/fudge.legacy.endl.html#fudge.legacy.endl.endl2dmathClasses.endl2dmath.scalex">[docs]</a>    def scalex( self, f, xLabel = None ) :
        &quot;&quot;&quot;Returns an endl2dmath instance whose x data is set to f(x) where the x in f(x)
        is self&#39;s x data and f(x) is a string representing a function. The y data is not altered.
        Two examples of f(x) are &#39;exp(x)&#39; and &#39;sqrt( pow( x, 2 ) - 1 ) / x&#39;. 
        Sets the returned objects xLabel to xLabel if is it not None.&quot;&quot;&quot;

        d = self.copyData( )
        for xy in d.data :
            x = xy[0]
            xy[0] = eval( f )
        if( len( d ) ) :
            inverted = True
            x1 = d.data[0][0]
            for x2, y in d.data :
                if( x1 &lt; x2 ) :
                    inverted = False
                    break;
            if( inverted ) : d = d.reversex( )
        if( not( xLabel is None ) ) : d.xLabel = xLabel
        return( d )</div>

<div class="viewcode-block" id="endl2dmath.set"><a class="viewcode-back" href="../../../../fudge/fudge.legacy.endl.html#fudge.legacy.endl.endl2dmathClasses.endl2dmath.set">[docs]</a>    def set( self, other ) :
        &quot;&quot;&quot;Sets self&#39;s data to other&#39;s data.&quot;&quot;&quot;

        self.data = other.data</div>

<div class="viewcode-block" id="endl2dmath.setValue"><a class="viewcode-back" href="../../../../fudge/fudge.legacy.endl.html#fudge.legacy.endl.endl2dmathClasses.endl2dmath.setValue">[docs]</a>    def setValue( self, x, y ) :
        &quot;&quot;&quot;Sets self&#39;s y value evaluated at x to y.  If there is no point at x 
        then one is added. x and y must be numbers.&quot;&quot;&quot;

        np = [ x, y ]
        endl2dmathmisc.check2dPoint( np )
        if ( len( self.data ) == 0 ) :
            self.data = [ [ x, y ] ]
        else :
            if ( x &lt;= self.data[-1][0] ) :
                i = 0
                for p in self.data :
                    if ( x &lt;= p[0] ) :
                        if ( x == p[0] ) :
                            p[1] = y
                        else :
                            self.data.insert( i, np )
                        return
                    i = i + 1
            else :
                self.data.append( np )</div>

<div class="viewcode-block" id="endl2dmath.slice"><a class="viewcode-back" href="../../../../fudge/fudge.legacy.endl.html#fudge.legacy.endl.endl2dmathClasses.endl2dmath.slice">[docs]</a>    def slice( self, xMin = None, xMax = None ) :
        &quot;&quot;&quot;Returns an endl2dmath instance that includes all points of self that lie between
    xMin and xMax inclusively.  If xMin = None (xMax = None) then the lowest (highest)
    x value of self is used for xMin (xMax).&quot;&quot;&quot;

        d = []
        if ( len( self.data ) &gt; 0 ) :
            if( xMin is None ) : xMin = self.data[0][0]
            if( xMax is None ) : xMax = self.data[-1][0]
            i = 0
            imax = len( self )
            while ( i &lt; imax ) and ( self.data[i][0] &lt; xMin ) : i = i + 1
            while ( i &lt; imax ) and ( self.data[i][0] &lt;= xMax ) : d.append( self.data[i] ); i = i + 1
        return endl2dmath( d, checkDataType = 0, template = self )</div>

<div class="viewcode-block" id="endl2dmath.sliceDull"><a class="viewcode-back" href="../../../../fudge/fudge.legacy.endl.html#fudge.legacy.endl.endl2dmathClasses.endl2dmath.sliceDull">[docs]</a>    def sliceDull( self, xMin = None, xMax = None ) :
        &quot;&quot;&quot;Same as slice except that the end points of the returned endl2dmath instance are 
    dulled if they are not the same as the end points of self.&quot;&quot;&quot;

        s = self.slice( xMin, xMax )
        if ( len( s ) &gt; 0 ) :
            if( s.data[ 0][0] &gt; self.data[ 0][0] ) : endl2dmathmisc.dullLowerEdge2d( s )
            if( s.data[-1][0] &lt; self.data[-1][0] ) : endl2dmathmisc.dullUpperEdge2d( s )
        return s</div>
        

<div class="viewcode-block" id="endl2dmath.slicex"><a class="viewcode-back" href="../../../../fudge/fudge.legacy.endl.html#fudge.legacy.endl.endl2dmathClasses.endl2dmath.slicex">[docs]</a>    def slicex( self, xMin = None, xMax = None, addZeroPoint = False ) :
        &quot;&quot;&quot;Same as slice except if self does not contain a point at xMin (xMax) then it is added with the y 
    value being self evalauted at xMin (xMax). If self evalauted at xMin (xMax) is zero then no point is added,
    unless addZeroPoint is True.&quot;&quot;&quot;

        if ( len( self ) &gt; 0 ) :
            if( xMin is None ) : xMin = self.data[0][0]
            if( xMax is None ) : xMax = self.data[-1][0]
        d = self.slice( xMin, xMax )
        if ( len( self ) &gt; 0 ) :
            if( ( xMin &lt; self.xMax( ) ) and ( xMax &gt; self.xMin( ) ) ) :
                if( ( len( d ) == 0 ) or ( d.data[0][0] &gt; xMin ) ) :
                    v = self.getValue( xMin )
                    if( ( v != 0. ) or addZeroPoint ) : d.data.insert( 0, [ xMin, v ] )
                if( ( len( d ) == 0 ) or ( d.data[-1][0] &lt; xMax ) ) :
                    v = self.getValue( xMax )
                    if( ( v != 0. ) or addZeroPoint ) : d.data.append( [ xMax, v ] )
        return d</div>

<div class="viewcode-block" id="endl2dmath.slicexDull"><a class="viewcode-back" href="../../../../fudge/fudge.legacy.endl.html#fudge.legacy.endl.endl2dmathClasses.endl2dmath.slicexDull">[docs]</a>    def slicexDull( self, xMin = None, xMax = None ) :
        &quot;&quot;&quot;Same as slicex except the end points of the returned endl2dmath instance are 
    dulled if they are not the same as the end points of self.&quot;&quot;&quot;

        s = self.slicex( xMin, xMax )
        if ( len( s ) &gt; 0 ) :
            if( s.data[ 0][0] &gt; self.data[ 0][0] ) : endl2dmathmisc.dullLowerEdge2d( s )
            if( s.data[-1][0] &lt; self.data[-1][0] ) : endl2dmathmisc.dullUpperEdge2d( s )
        return s</div>

<div class="viewcode-block" id="endl2dmath.sqrt"><a class="viewcode-back" href="../../../../fudge/fudge.legacy.endl.html#fudge.legacy.endl.endl2dmathClasses.endl2dmath.sqrt">[docs]</a>    def sqrt( self ) :
        &quot;&quot;&quot;Returns an endl2dmath instance that has all y values of self sqrt-ed.&quot;&quot;&quot;

        d = self.copyData( )
        for xy in d.data : xy[1] = math.sqrt( xy[1] )
        return d</div>

<div class="viewcode-block" id="endl2dmath.thicken"><a class="viewcode-back" href="../../../../fudge/fudge.legacy.endl.html#fudge.legacy.endl.endl2dmathClasses.endl2dmath.thicken">[docs]</a>    def thicken( self, dx, Log = 0 ) :
        &quot;&quot;&quot;Returns an endl2dmath instance that is the same as self except that more
    points are added, if needed, to insure that the x spacing between points is less
    than dx if Log = 0 or the ratio between x values of points is less than dx if 
    Log != 0. The actual x spacing may be smaller than dx but not larger.&quot;&quot;&quot;

        if( dx &lt;= 0. ) : raise Exception( &quot;\nError in endl2dmath.thicked: dx = %e &lt;= 0.&quot; % dx )
        if( ( Log != 0 ) and ( dx &lt;= 1. ) ) : raise Exception( &quot;\nError in endl2dmath.thicked: dx = %e &lt;= 1. for Log != 0&quot; % dx )
        d = endl2dmath( [], checkDataType = 0, template = self )
        i = 0
        j = 0
        n = len( self )
        if( n &gt; 0 ) :
            x2 = float( self.data[i][0] )
            ( y, j ) = self.GetValueNIndex( x2, j )
            d.data.append( [ x2, y ] )
            i += 1
        while( i &lt; n ) :
            x1 = x2
            x2 = float( self.data[i][0] )
            if( Log == 0 ) :
                rm = ( x2 - x1 ) / dx
                m = int( rm )
                if( abs( rm - m ) &gt; 1e-6 ) : m += 1
                if( m &gt; 0 ) : s = ( x2 - x1 ) / m
            else :
                m = int( math.log( x2 / x1 ) / math.log( dx ) )
                if( m &gt; 0 ) : s = math.exp( math.log( x2 / x1 ) / ( m + 1 ) )
            k = 1
            x = x1
            while( k &lt;= m ) :
                if( Log == 0 ) :
                    x += s
                else :
                    x *= s
                if( abs( x - x2 ) &lt;= 0.01 * dx ) : break
                ( y, j ) = self.GetValueNIndex( x, j )
                d.data.append( [ x, y ] )
                k += 1
            i += 1
            ( y, j ) = self.GetValueNIndex( x2, j )
            d.data.append( [ x2, y ] )
        return d</div>

<div class="viewcode-block" id="endl2dmath.thin"><a class="viewcode-back" href="../../../../fudge/fudge.legacy.endl.html#fudge.legacy.endl.endl2dmathClasses.endl2dmath.thin">[docs]</a>    def thin( self, interpolationAccuracy = 0.01, thinningMethod = None ) :
        &quot;&quot;&quot;Returns an endl2dmath instance that is the same as self except the points are
    thinned while keeping linear interpolation accurate to interpolationAccuracy. interpolationAccuracy
    is forced into the range 1e-1 to 1e-8.  thinningMethod can be None, &#39;c_CodingV1&#39; or &#39;pythonCodingV1&#39;.
    If thinningMethod is None or &#39;c_CodingV1&#39; then thin tries to use the thinning function in fudge2dThin.
    If this fails or thinningMethod is &#39;pythonCodingV1&#39;, a slower python code is used.&quot;&quot;&quot;

        interpolationAccuracy = max( 1e-8, min( 1e-1, interpolationAccuracy ) )

        if( thinningMethod not in [ None, &#39;c_CodingV1&#39;, &#39;pythonCodingV1&#39; ] ) :
            fudgemisc.printWarning( &#39;Bad thinningMethod argument to method endl2dmath.thin in module endl2dmathClasses. Using thinningMethod = None&#39; )
            thinningMethod = None

        if( thinningMethod in [ None, &#39;c_CodingV1&#39; ] ) :
            try :
                import fudge2dThin
            except :
                thinningMethod = &#39;pythonCodingV1&#39;
            else :
                datap = fudge2dThin.fudge2dThin( self.data, interpolationAccuracy = interpolationAccuracy )

        if( thinningMethod == &#39;pythonCodingV1&#39; ) :
            n = len( self )
            thinPoint = n * [ True ]

            i = -1
            x1 = None
            x2 = None
            multiPoints = 0
            for x3, y3 in self.data :       # Remove middle point if surrounding points have same x-value.
                if( not( x1 is None ) ) :
                    if( x1 == x2 == x3 ) :
                        thinPoint[i] == False
                        multiPoints += 1
                x1 = x2
                x2 = x3
                i += 1
            if( multiPoints == 0 ) :
                data = self.data
            else :
                data = []
                i = 0
                for xy in self.data :
                    if( thinPoint[i] ) : data.append( xy )
                    i += 1
                n = len( data )
                thinPoint = n * [ True ]

            if( n &gt; 0 ) :                   # Do not thin end points.
                thinPoint[0] = False
                thinPoint[-1] = False

            i = -1
            y1 = None
            y2 = None
            for x3, y3 in data :            # Do not thin local minima and maxima.
                if( not( y1 is None ) and thinPoint[i] ) :
                    if( ( y2 - y1 ) * ( y3 - y2 ) &lt; 0. ) : thinPoint[i] = False
                y1 = y2
                y2 = y3
                i += 1

            i = 0
            x1 = None
            for x2, y2 in data :            # Do not thin step function.
                if( x1 == x2 ) :
                    thinPoint[i-1] = False
                    thinPoint[i] = False
                x2 = x1
                i += 1

            iPrior = 0
            nm2 = n - 1
            while( iPrior &lt; nm2 ) :           # Now thin the other points.
                x1, y1 = data[iPrior]
                iNext = iPrior + 1
                iCurrent = iNext
                while( thinPoint[iCurrent] ) :
                    iNext += 1
                    if( iNext &gt; n ) : break
                    x3, y3 = data[iNext]
                    iCurrent = iPrior + 1
                    while( iCurrent != iNext ) :
                        x2, y2 = data[iCurrent]
                        if( abs( ( y3 - y1 ) * ( x2 - x1 ) - ( y2 - y1 ) * ( x3 - x1 ) ) &gt;= abs( interpolationAccuracy * y2 * ( x3 - x1 ) ) ) :
                            i = iCurrent
                            f = 0.
                            while( i &lt; iNext ) :
                                x2, y2 = data[i]
                                y2p = ( y3 - y1 ) * ( x2 - x1 ) / ( x3 - x1 ) + y1
                                if( y2 == y2p == 0. ) :
                                    iCurrent = i
                                else :
                                    fp = abs( y2p - y2 ) / ( abs( y2 ) + abs( y2p ) )
                                    if( fp &gt; f ) :
                                        f = fp
                                        iCurrent = i
                                i += 1
                            thinPoint[iCurrent] = False
                        if( not thinPoint[iCurrent] ) : break
                        iCurrent += 1
                iPrior = iCurrent

            datap = []
            i = 0
            for x, y in data :
                if( not thinPoint[i] ) : datap.append( [ x, y ] )
                i += 1
        return( endl2dmath( datap, checkDataType = 0, template = self ) )</div>

<div class="viewcode-block" id="endl2dmath.toInterpolation"><a class="viewcode-back" href="../../../../fudge/fudge.legacy.endl.html#fudge.legacy.endl.endl2dmathClasses.endl2dmath.toInterpolation">[docs]</a>    def toInterpolation( self, interpolation, accuracy, diSectionMax = 3 ) :
        &quot;&quot;&quot;Returns a new endl2dmath object with data converted to the specified interpolation and accuracy.&quot;&quot;&quot;

        if( ( interpolation &lt; 0 ) or ( interpolation &gt; 3 ) ) : raise Exception( &quot;Invalid interpolation = %d&quot; % interpolation )
        if( self.interpolation != interpolation ) :
            if( self.interpolation == 3 ) :
                if( interpolation == 0 ) :
                    d = endl2dmathmisc.convertLogLogToLinLin( self, accuracy, diSectionMax = diSectionMax )
                else :
                    raise Exception( &quot;Conversion of data from interpolation = %d to interpolation = %d is currently not supported&quot; % \
                        ( self.interpolation, interpolation ) )
            else :
                raise Exception( &quot;Conversion of data from interpolation = %d to interpolation = %d is currently not supported&quot; % \
                    ( self.interpolation, interpolation ) )
        else :
            d = self.copyData( )
        return( d )</div>

<div class="viewcode-block" id="endl2dmath.toPointwise_withLinearXYs"><a class="viewcode-back" href="../../../../fudge/fudge.legacy.endl.html#fudge.legacy.endl.endl2dmathClasses.endl2dmath.toPointwise_withLinearXYs">[docs]</a>    def toPointwise_withLinearXYs( self, accuracy = 1e-3, lowerEps = 0, upperEps = 0, cls = None ) :
        &quot;&quot;&quot;
        This routine is designed to make an endl2dmath instance work with plotting packages like plot2d.py. This routine is not 
        compatible with legacy fudge as the returned instance is of type XYs and not of type endl2dmath.
        &quot;&quot;&quot;

        linear = self.toInterpolation( 0, accuracy )
        linearXYs = XYsModule.XYs( linear.data, axes = XYsModule.XYs.defaultAxes( ) )
        if( cls is not None ) : linearXYs = cls.returnAsClass( linearXYs )
        return( linearXYs )</div>

<div class="viewcode-block" id="endl2dmath.copyDataToXYs"><a class="viewcode-back" href="../../../../fudge/fudge.legacy.endl.html#fudge.legacy.endl.endl2dmathClasses.endl2dmath.copyDataToXYs">[docs]</a>    def copyDataToXYs( self ) :

        return( self.data )</div>

<div class="viewcode-block" id="endl2dmath.copyDataToXsAndYs"><a class="viewcode-back" href="../../../../fudge/fudge.legacy.endl.html#fudge.legacy.endl.endl2dmathClasses.endl2dmath.copyDataToXsAndYs">[docs]</a>    def copyDataToXsAndYs( self ) :

        xs, ys = [], []
        for x, y in self.data :
            xs.append( x )
            ys.append( y )
        return( xs, ys )</div>

<div class="viewcode-block" id="endl2dmath.trim"><a class="viewcode-back" href="../../../../fudge/fudge.legacy.endl.html#fudge.legacy.endl.endl2dmathClasses.endl2dmath.trim">[docs]</a>    def trim( self ) :
        &quot;&quot;&quot;Removes extra leading and trailing data whose y values are zero.&quot;&quot;&quot;

        i = -1                                  # First, remove zeros from beginning.
        for e in self.data :
            if ( e[1] != 0. ) : break
            i = i + 1
        if ( i &gt; 0 ) : self.data = self.data[i:]
        i = len( self.data ) - 1                # Now, remove zeros from end.
        if ( i &gt;= 0 ) :
            j = i - 1
            while ( i &gt;= 0 ) and ( self.data[i][1] == 0. ) : i = i - 1
            if ( i == -1 ) : self.data = []
            elif ( i &lt; j ) : self.data = self.data[:i + 2]</div>

<div class="viewcode-block" id="endl2dmath.vectorScale"><a class="viewcode-back" href="../../../../fudge/fudge.legacy.endl.html#fudge.legacy.endl.endl2dmathClasses.endl2dmath.vectorScale">[docs]</a>    def vectorScale( self, vector ) :
        &quot;&quot;&quot;Scales the y value of self at x by vector evaluated at x.  Only self&#39;s data within the x range of vector are modified.&quot;&quot;&quot;

        endl2dmathmisc.valid2dClassType( vector, &quot;endl2dmath.vectorScaleAdd&quot;, &quot;vector&quot; )
        d = self.copyData( )
        i = 0
        for xy in d.data :
            ( y, i ) = vector.GetValueNIndex( xy[0], i )
            xy[1] = y * xy[1]
        return d</div>

<div class="viewcode-block" id="endl2dmath.vectorScaleAdd"><a class="viewcode-back" href="../../../../fudge/fudge.legacy.endl.html#fudge.legacy.endl.endl2dmathClasses.endl2dmath.vectorScaleAdd">[docs]</a>    def vectorScaleAdd( self, vector ) :
        &quot;&quot;&quot;Scales the y value of self at x by vector evaluated at x.
        Only self&#39;s data within the x range of vector are modified.&quot;&quot;&quot;

        endl2dmathmisc.valid2dClassType( vector, &quot;endl2dmath.vectorScaleAdd&quot;, &quot;vector&quot; )
        d = self.copyData( )
        i = 0
        xMax = vector.xMax( )
        if( not( xMax is None ) ) :
            for xy in d.data :
                if ( xy[0] &gt; xMax ) : break
                ( y, i ) = vector.GetValueNIndex( xy[0], i )
                xy[1] += y * xy[1]
        return d</div>

<div class="viewcode-block" id="endl2dmath.xArray"><a class="viewcode-back" href="../../../../fudge/fudge.legacy.endl.html#fudge.legacy.endl.endl2dmathClasses.endl2dmath.xArray">[docs]</a>    def xArray( self ) :
        &quot;&quot;&quot;Returns an endl1dmath instances of the x values in self.&quot;&quot;&quot;

        xa = []
        for xy in self.data : xa.append( xy[0] )
        return endl1dmathClasses.endl1dmath( xa )</div>

<div class="viewcode-block" id="endl2dmath.xMax"><a class="viewcode-back" href="../../../../fudge/fudge.legacy.endl.html#fudge.legacy.endl.endl2dmathClasses.endl2dmath.xMax">[docs]</a>    def xMax( self ) :
        &quot;&quot;&quot;Returns the maximum x value of self if self contains data, otherwise it returns None.&quot;&quot;&quot;

        if ( len( self.data ) &gt; 0 ) : return self.data[-1][0]
        return None</div>

<div class="viewcode-block" id="endl2dmath.xMin"><a class="viewcode-back" href="../../../../fudge/fudge.legacy.endl.html#fudge.legacy.endl.endl2dmathClasses.endl2dmath.xMin">[docs]</a>    def xMin( self ) :
        &quot;&quot;&quot;Returns the minimum x value of self if self contains data, otherwise it returns None.&quot;&quot;&quot;

        if ( len( self.data ) &gt; 0 ) : return self.data[0][0]
        return None</div>

<div class="viewcode-block" id="endl2dmath.yMax"><a class="viewcode-back" href="../../../../fudge/fudge.legacy.endl.html#fudge.legacy.endl.endl2dmathClasses.endl2dmath.yMax">[docs]</a>    def yMax( self ) :
        &quot;&quot;&quot;Returns the maximum y value of self if self contains data, otherwise it returns None.&quot;&quot;&quot;

        return( self.yMinMax( )[1] )</div>

<div class="viewcode-block" id="endl2dmath.yMin"><a class="viewcode-back" href="../../../../fudge/fudge.legacy.endl.html#fudge.legacy.endl.endl2dmathClasses.endl2dmath.yMin">[docs]</a>    def yMin( self ) :
        &quot;&quot;&quot;Returns the minimum y value of self if self contains data, otherwise it returns None.&quot;&quot;&quot;

        return( self.yMinMax( )[0] )</div>

<div class="viewcode-block" id="endl2dmath.yMinMax"><a class="viewcode-back" href="../../../../fudge/fudge.legacy.endl.html#fudge.legacy.endl.endl2dmathClasses.endl2dmath.yMinMax">[docs]</a>    def yMinMax( self ) :
        &quot;&quot;&quot;Returns the tuple of the minimum and maximum y values of self if self contains data, otherwise it returns ( None, None ).&quot;&quot;&quot;

        the_min = None
        if ( len( self.data ) &gt; 0 ) : the_min = self.data[0][1]
        the_max = the_min
        for x, y in self.data:
            the_min = min( the_min, y )
            the_max = max( the_max, y )
        return( the_min, the_max )</div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../../index.html">
              <img class="logo" src="../../../../_static/gnd.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">Fudge and GND 4.2.2 beta documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../endl.html" >fudge.legacy.endl</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2012, B.Beck, D. Brown, C. Mattoon, N. Patel, N. Summers.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.1.
    </div>
  </body>
</html>
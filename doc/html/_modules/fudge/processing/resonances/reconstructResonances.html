<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>fudge.processing.resonances.reconstructResonances &#8212; Fudge and GND 4.2.2 beta documentation</title>
    
    <link rel="stylesheet" href="../../../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../',
        VERSION:     '4.2.2 beta',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../../../_static/gnd-20121206-favicon.ico"/>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">Fudge and GND 4.2.2 beta documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for fudge.processing.resonances.reconstructResonances</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1">#encoding: utf-8</span>

<span class="c1"># &lt;&lt;BEGIN-copyright&gt;&gt;</span>
<span class="c1"># &lt;&lt;END-copyright&gt;&gt;</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">reconstruct resonance region</span>
<span class="sd">cmattoon, 12/1/2010</span>

<span class="sd">See ENDF-102 (endf documentation) appendix D for equations</span>

<span class="sd">Basic usage:</span>
<span class="sd">------------</span>

<span class="sd">    if x is a reactionSuite instance,::</span>

<span class="sd">        &gt;&gt;x.reconstructResonances(tolerance=0.01)</span>

<span class="sd">    This reconstructs all resolved/unresolved resonance sections. In each section,</span>
<span class="sd">    the results are accurate under linear interpolation to tolerance of 1% or better.</span>
<span class="sd">    Sections are summed together and then added to the appropriate background cross</span>
<span class="sd">    sections to form new pointwise, lin-lin cross sections that are stored in the</span>
<span class="sd">    appropriate reaction inside reactionSuite x.</span>

<span class="sd">Alternate uses:</span>
<span class="sd">---------------</span>

<span class="sd">    You can skip the final step (adding background cross sections) and just get the</span>
<span class="sd">    resonance parameter contribution to the cross section by doing::</span>

<span class="sd">        &gt;&gt;xsecs = reconstructResonances.reconstructResonances(x, tolerance=0.01)</span>

<span class="sd">    Here,::</span>

<span class="sd">        * xsecs = dictionary containing cross sections: {&#39;total&#39;:XYs, &#39;elastic&#39;:XYs, ...}</span>

<span class="sd">    each cross section is an XYs class instance, containing data and also axes with units</span>

<span class="sd">    Another option would be to only reconstruct a single section::</span>

<span class="sd">        &gt;&gt; resCls = reconstructResonances.RMcrossSection(x, energyUnit=&#39;eV&#39;)   # for Reich_Moore</span>
<span class="sd">        &gt;&gt; energy_grid = s.generateEnergyGrid()</span>
<span class="sd">        &gt;&gt; crossSections = s.getCrossSection( energy_grid )</span>
<span class="sd">        # the input to getCrossSection is the energy (or list of energies) in self.energyUnit</span>
<span class="sd">        # crossSections are returned as a dictionary {&#39;total&#39;:,&#39;elastic&#39;:,&#39;capture&#39;:,&#39;fission&#39;:,}</span>

<span class="sd">        # improve grid to desired tolerance for linear interpolation:</span>
<span class="sd">        &gt;&gt; new_energy_grid, new_crossSections, messages = s.refineInterpolation(energy_grid, crossSections, tolerance=0.01)</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">numpy</span><span class="o">,</span> <span class="nn">collections</span><span class="o">,</span> <span class="nn">math</span><span class="o">,</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">abc</span>

<span class="kn">from</span> <span class="nn">pqu</span> <span class="k">import</span> <span class="n">PQU</span>

<span class="kn">from</span> <span class="nn">fudge.gnd.reactionData</span> <span class="k">import</span> <span class="n">crossSection</span>
<span class="kn">from</span> <span class="nn">fudge.gnd.productData</span> <span class="k">import</span> <span class="n">distributions</span>
<span class="kn">import</span> <span class="nn">fudge.gnd.resonances</span>
<span class="kn">import</span> <span class="nn">fudge.processing.resonances.getCoulombWavefunctions</span> <span class="k">as</span> <span class="nn">getCoulombWavefunctions</span>

<span class="kn">from</span> <span class="nn">xData</span> <span class="k">import</span> <span class="n">axes</span> <span class="k">as</span> <span class="n">axesModule</span>
<span class="kn">from</span> <span class="nn">xData</span> <span class="k">import</span> <span class="n">standards</span> <span class="k">as</span> <span class="n">standardsModule</span>
<span class="kn">from</span> <span class="nn">xData</span> <span class="k">import</span> <span class="n">XYs</span> <span class="k">as</span> <span class="n">XYsModule</span>
<span class="kn">from</span> <span class="nn">xData.isclose</span> <span class="k">import</span> <span class="n">isclose</span>

<span class="kn">from</span> <span class="nn">PoPs</span> <span class="k">import</span> <span class="n">misc</span> <span class="k">as</span> <span class="n">miscPoPsModule</span>
<span class="kn">from</span> <span class="nn">PoPs.families</span> <span class="k">import</span> <span class="n">nuclearLevel</span> <span class="k">as</span> <span class="n">nuclearLevelPoPsModule</span>

<span class="n">__metaclass__</span> <span class="o">=</span> <span class="nb">type</span>

<span class="n">debug</span> <span class="o">=</span> <span class="kc">False</span>   <span class="c1"># recommend setting to True before debugging (disables multiprocessing)</span>

<span class="n">VERBOSE</span> <span class="o">=</span> <span class="kc">False</span>

<span class="n">FISSIONCHANNEL</span><span class="p">,</span> <span class="n">NEUTRONCHANNEL</span><span class="p">,</span> <span class="n">CPCHANNEL</span><span class="p">,</span> <span class="n">GAMMACHANNEL</span><span class="p">,</span> <span class="n">COMPETATIVECHANNEL</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

<div class="viewcode-block" id="ChannelDesignator"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.ChannelDesignator">[docs]</a><span class="k">class</span> <span class="nc">ChannelDesignator</span><span class="p">:</span>
    <span class="n">__slots__</span><span class="o">=</span><span class="p">[</span> <span class="s1">&#39;l&#39;</span><span class="p">,</span> <span class="s1">&#39;J&#39;</span><span class="p">,</span> <span class="s1">&#39;reaction&#39;</span><span class="p">,</span> <span class="s1">&#39;index&#39;</span><span class="p">,</span> <span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;gfact&#39;</span><span class="p">,</span> <span class="s1">&#39;particleA&#39;</span><span class="p">,</span> <span class="s1">&#39;particleB&#39;</span><span class="p">,</span> <span class="s1">&#39;Xi&#39;</span><span class="p">,</span> <span class="s1">&#39;isElastic&#39;</span><span class="p">,</span> <span class="s1">&#39;channelClass&#39;</span><span class="p">,</span> <span class="s1">&#39;useRelativistic&#39;</span><span class="p">,</span> <span class="s1">&#39;eliminated&#39;</span> <span class="p">]</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">reaction</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">gfact</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">particleA</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">particleB</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Xi</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">isElastic</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">channelClass</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">useRelativistic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">eliminated</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simple widget to specify a channel</span>

<span class="sd">        RRBaseClass.setResonanceParametersByChannel() creates these mostly and getAllowedTotalSpins() is used to determine the spins in there.</span>
<span class="sd">        So, if you&#39;re wondering why s is really 2*s, unlike l and J, check in those routines.</span>

<span class="sd">        :param l: orbital angular momentum of channel, an int</span>
<span class="sd">        :param J: total angular momentum of a channel, can be an int or 1/2 int (use the _eq_ below to avoid floating point comparisons)</span>
<span class="sd">        :param reaction: string, name of the reaction associated with this channel</span>
<span class="sd">        :param index: int, an optional index of the channel (useful if using this in an unordered dictionary)</span>
<span class="sd">        :param s: total spin of a channel, can be an int or 1/2 int (use the _eq_ below to avoid floating point comparisons)</span>
<span class="sd">        :param gfact: statistical factor</span>
<span class="sd">        :param particleA: the projectile, either a string (&#39;n&#39;) or None if you don&#39;t need it</span>
<span class="sd">        :param particleB: the target, either a string (&#39;Pu239&#39;) or None if you don&#39;t need it</span>
<span class="sd">        :param Xi: threshold energy in lab frame</span>
<span class="sd">        :param isElastic: flag to denote that this channel is, in fact, also incoming channel so this is an elastic channel</span>
<span class="sd">        :param channelClass: nature of channel: gamma, fission, neutron or charged particle</span>
<span class="sd">        :param useRelativistic: flag for using relativistic kinematics</span>
<span class="sd">        :param eliminated: flag for whether to eliminate this channel using Reich-Moore approximation (useful for gamma channels)</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="o">=</span><span class="n">l</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="o">=</span><span class="n">J</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reaction</span><span class="o">=</span><span class="n">reaction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">=</span><span class="n">index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="o">=</span><span class="n">s</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gfact</span><span class="o">=</span><span class="n">gfact</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">particleA</span><span class="o">=</span><span class="n">particleA</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">particleB</span><span class="o">=</span><span class="n">particleB</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Xi</span><span class="o">=</span><span class="n">Xi</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">isElastic</span><span class="o">=</span><span class="n">isElastic</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channelClass</span><span class="o">=</span><span class="n">channelClass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">useRelativistic</span><span class="o">=</span><span class="n">useRelativistic</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eliminated</span><span class="o">=</span><span class="n">eliminated</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">l</span> <span class="ow">and</span> \
               <span class="nb">int</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">)</span><span class="o">==</span><span class="nb">int</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">J</span><span class="p">)</span> <span class="ow">and</span> \
               <span class="nb">int</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">)</span><span class="o">==</span><span class="nb">int</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">s</span><span class="p">)</span> <span class="ow">and</span> \
               <span class="n">isclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gfact</span><span class="p">,</span><span class="n">other</span><span class="o">.</span><span class="n">gfact</span><span class="p">,</span><span class="n">rel_tol</span><span class="o">=</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span><span class="n">abs_tol</span><span class="o">=</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">5</span><span class="p">)</span> <span class="ow">and</span> \
               <span class="bp">self</span><span class="o">.</span><span class="n">particleA</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">particleA</span> <span class="ow">and</span> \
               <span class="bp">self</span><span class="o">.</span><span class="n">particleB</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">particleB</span> <span class="ow">and</span> \
               <span class="bp">self</span><span class="o">.</span><span class="n">isElastic</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">isElastic</span> <span class="ow">and</span> \
               <span class="bp">self</span><span class="o">.</span><span class="n">channelClass</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">channelClass</span> <span class="ow">and</span> \
               <span class="bp">self</span><span class="o">.</span><span class="n">useRelativistic</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">useRelativistic</span> <span class="ow">and</span> \
               <span class="bp">self</span><span class="o">.</span><span class="n">eliminated</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">eliminated</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">theHash</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">ChannelDesignator</span><span class="o">.</span><span class="n">__slots__</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="s1">&#39;Xi&#39;</span><span class="p">:</span><span class="k">continue</span> <span class="c1"># is computable and is real, so lousy for hashing</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="s1">&#39;gfact&#39;</span><span class="p">:</span> <span class="k">continue</span> <span class="c1"># is computable and is real, so lousy for hashing</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="s1">&#39;reaction&#39;</span><span class="p">:</span> <span class="k">continue</span> <span class="c1"># LRF=7 calls &#39;elastic&#39; &#39;n+Target&#39;, so the name is kinda meaningless</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="s1">&#39;eliminated&#39;</span><span class="p">:</span> <span class="k">continue</span> <span class="c1"># different approximations treat this field differently</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="s1">&#39;index&#39;</span><span class="p">:</span> <span class="k">continue</span> <span class="c1"># this isn&#39;t used except for printing out</span>
            <span class="n">theHash</span><span class="o">+=</span><span class="nb">eval</span><span class="p">(</span><span class="s2">&quot;hash(self.</span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="n">s</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">theHash</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;ChannelDesignator(l=</span><span class="si">%i</span><span class="s2">, J=</span><span class="si">%s</span><span class="s2">, reaction=&#39;</span><span class="si">%s</span><span class="s2">&#39;, index=</span><span class="si">%i</span><span class="s2">, s=</span><span class="si">%s</span><span class="s2">, gfact=</span><span class="si">%s</span><span class="s2">, particleA=&#39;</span><span class="si">%s</span><span class="s2">&#39;, particleB=&#39;</span><span class="si">%s</span><span class="s2">&#39;, Xi=</span><span class="si">%s</span><span class="s2">, isElastic=</span><span class="si">%s</span><span class="s2">, channelClass=</span><span class="si">%s</span><span class="s2">, useRelativistic=</span><span class="si">%s</span><span class="s2">, eliminated=</span><span class="si">%s</span><span class="s2">)&quot;</span> \
               <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">reaction</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gfact</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">particleA</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">particleB</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xi</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">isElastic</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">channelClass</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">useRelativistic</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eliminated</span><span class="p">)</span>

<div class="viewcode-block" id="ChannelDesignator.has_same_J"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.ChannelDesignator.has_same_J">[docs]</a>    <span class="k">def</span> <span class="nf">has_same_J</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="o">-</span><span class="n">other</span><span class="o">.</span><span class="n">J</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">0.001</span></div>

<div class="viewcode-block" id="ChannelDesignator.is_open"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.ChannelDesignator.is_open">[docs]</a>    <span class="k">def</span> <span class="nf">is_open</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">Ein</span><span class="p">):</span> <span class="k">return</span> <span class="n">Ein</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Xi</span></div></div>


<div class="viewcode-block" id="spins_equal"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.spins_equal">[docs]</a><span class="k">def</span> <span class="nf">spins_equal</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">s2</span><span class="p">):</span> <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">s1</span><span class="p">)</span><span class="o">==</span><span class="nb">int</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">s2</span><span class="p">)</span></div>


<div class="viewcode-block" id="getResonanceReconstructionClass"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.getResonanceReconstructionClass">[docs]</a><span class="k">def</span> <span class="nf">getResonanceReconstructionClass</span><span class="p">(</span> <span class="n">formalismMoniker</span> <span class="p">):</span>
    <span class="k">try</span><span class="p">:</span> <span class="k">return</span> <span class="n">RRClassMap</span><span class="p">[</span><span class="n">formalismMoniker</span><span class="p">][</span><span class="s1">&#39;proc&#39;</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">,</span> <span class="s2">&quot;Don&#39;t recognize resonance type </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">formalismMoniker</span></div>


<div class="viewcode-block" id="getAllowedTotalSpins"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.getAllowedTotalSpins">[docs]</a><span class="k">def</span> <span class="nf">getAllowedTotalSpins</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">useFactor2Trick</span><span class="o">=</span><span class="kc">True</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a list of allowed J values from summing angular momenta L and S, where</span>
<span class="sd">    :math:`\\vec{J}=\\vec{L}+\\vec{S}`</span>
<span class="sd">    which implies :math:`|L-S| \\leq J \\leq L+S`</span>

<span class="sd">    The useFactor2Trick flag tells the routine whether we are summing real angular momenta or momenta * 2.</span>
<span class="sd">    If the useFactor2Trick flag is true, then momenta are really momenta*2, meaning they can be pure integers,</span>
<span class="sd">    even if the real momenta refer to 1/2-integer values (e.g. spin).  The default is to useFactor2Trick because</span>
<span class="sd">    most C/C++/Fortran codes that compute angular momentum-stuff use the trick so they can use integer math.</span>
<span class="sd">    Also, it makes the use of the Python range() function possible.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">useFactor2Trick</span><span class="p">:</span> <span class="k">return</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">abs</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">S</span><span class="p">),</span> <span class="n">L</span><span class="o">+</span><span class="n">S</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span> <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="p">[</span> <span class="n">j</span><span class="o">/</span><span class="mf">2.0</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">getAllowedTotalSpins</span><span class="p">(</span> <span class="nb">int</span><span class="p">(</span><span class="n">L</span><span class="o">*</span><span class="mi">2</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">S</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="p">)</span> <span class="p">]</span></div>


<div class="viewcode-block" id="RoundToSigFigs"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RoundToSigFigs">[docs]</a><span class="k">def</span> <span class="nf">RoundToSigFigs</span><span class="p">(</span> <span class="n">x</span><span class="p">,</span> <span class="n">sigfigs</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rounds the value(s) in x to the number of significant figures in sigfigs.</span>

<span class="sd">    Restrictions:</span>
<span class="sd">    sigfigs must be an integer type and store a positive value.</span>
<span class="sd">    x must be a real value or an array like object containing only real values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#The following constant was computed in maxima 5.35.1 using 64 bigfloat digits of precision</span>
    <span class="n">__logBase10of2</span> <span class="o">=</span> <span class="mf">3.010299956639811952137388947244930267681898814621085413104274611e-1</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span> <span class="nb">type</span><span class="p">(</span><span class="n">sigfigs</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span> <span class="ow">or</span> <span class="n">numpy</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">sigfigs</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span> <span class="s2">&quot;RoundToSigFigs: sigfigs must be an integer.&quot;</span> <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span> <span class="n">x</span> <span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span> <span class="s2">&quot;RoundToSigFigs: all x must be real.&quot;</span> <span class="p">)</span>

    <span class="k">if</span> <span class="n">sigfigs</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span> <span class="s2">&quot;RoundtoSigFigs: sigfigs must be positive.&quot;</span> <span class="p">)</span>

    <span class="n">mantissas</span><span class="p">,</span> <span class="n">binaryExponents</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">frexp</span><span class="p">(</span> <span class="n">x</span> <span class="p">)</span>

    <span class="n">decimalExponents</span> <span class="o">=</span> <span class="n">__logBase10of2</span> <span class="o">*</span> <span class="n">binaryExponents</span>
    <span class="n">intParts</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">decimalExponents</span><span class="p">)</span>

    <span class="n">mantissas</span> <span class="o">*=</span> <span class="mf">10.0</span><span class="o">**</span><span class="p">(</span><span class="n">decimalExponents</span> <span class="o">-</span> <span class="n">intParts</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">around</span><span class="p">(</span> <span class="n">mantissas</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="n">sigfigs</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">)</span> <span class="o">*</span> <span class="mf">10.0</span><span class="o">**</span><span class="n">intParts</span></div>


<div class="viewcode-block" id="reconstructResonances"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.reconstructResonances">[docs]</a><span class="k">def</span> <span class="nf">reconstructResonances</span><span class="p">(</span><span class="n">reactionSuite</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">significantDigits</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">energyUnit</span><span class="o">=</span><span class="s1">&#39;eV&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reconstruct all resonance cross sections (resolved and unresolved) in reactionSuite,</span>
<span class="sd">    and add results together for full (resonance region) pointwise cross section.</span>

<span class="sd">    Optional arguments:</span>
<span class="sd">    &#39;tolerance&#39;: fractional tolerance, used to refine interpolation grid.</span>
<span class="sd">        e.g. if tolerance=0.001, points are added until lin-lin interpolation is good to 0.1% everywhere</span>

<span class="sd">    &#39;verbose&#39;: print status messages during reconstruction</span>

<span class="sd">    &#39;significantDigits&#39;: Controls how many digits can be used to represent the energy grid. For example,</span>
<span class="sd">        if significantDigits=4 the resulting energy grid can contain 1.034, 1.035, 1.036 but not 1.0345.</span>
<span class="sd">        Using significantDigits=8 should allow data to be written back to ENDF-6 without loss of precision.</span>
<span class="sd">        </span>
<span class="sd">    &#39;energyUnit&#39;: unit to use for reconstruction. Resonance energies and widths will be converted to this unit.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">egrids</span><span class="p">,</span> <span class="n">xsecs</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">reactionSuite</span><span class="o">.</span><span class="n">resonances</span><span class="o">.</span><span class="n">reconstructCrossSection</span><span class="p">:</span>
        <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;      Resonance reconstruction was already done. Reconstruct again? y/N&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">raw_input</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">):</span> <span class="c1"># bug!!!</span>
            <span class="k">return</span> <span class="n">xsecs</span>

    <span class="c1"># Helper function to reconstruct one region, used for single &amp; multiple regions as well as URR ensembles</span>
    <span class="k">def</span> <span class="nf">resolvedReconstruct</span><span class="p">(</span> <span class="n">formalism</span><span class="p">,</span> <span class="n">sectionIndex</span> <span class="o">=</span> <span class="kc">None</span> <span class="p">):</span>
        <span class="n">resCls</span> <span class="o">=</span> <span class="n">getResonanceReconstructionClass</span><span class="p">(</span><span class="n">formalism</span><span class="o">.</span><span class="n">moniker</span><span class="p">)</span>
        <span class="n">reconstructClass</span> <span class="o">=</span> <span class="n">resCls</span><span class="p">(</span> <span class="n">reactionSuite</span><span class="p">,</span> <span class="n">sectionIndex</span><span class="p">,</span> <span class="n">enableAngDists</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">energyUnit</span><span class="o">=</span><span class="n">energyUnit</span> <span class="p">)</span>
        <span class="n">egrid</span> <span class="o">=</span> <span class="n">reconstructClass</span><span class="o">.</span><span class="n">generateEnergyGrid</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">significantDigits</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">egrid</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span> <span class="nb">set</span><span class="p">(</span> <span class="n">RoundToSigFigs</span><span class="p">(</span><span class="n">egrid</span><span class="p">,</span><span class="n">significantDigits</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="p">)</span> <span class="p">)</span>
        <span class="n">xsecs_now</span> <span class="o">=</span> <span class="n">reconstructClass</span><span class="o">.</span><span class="n">getCrossSection</span><span class="p">(</span> <span class="n">egrid</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">tolerance</span><span class="p">:</span>
            <span class="n">egrid</span><span class="p">,</span> <span class="n">xsecs_now</span><span class="p">,</span> <span class="n">messages</span> <span class="o">=</span> <span class="n">reconstructClass</span><span class="o">.</span><span class="n">refineInterpolation</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">egrid</span><span class="p">),</span> <span class="n">xsecs_now</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span>
                    <span class="n">significantDigits</span><span class="o">=</span><span class="n">significantDigits</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">message</span> <span class="ow">in</span> <span class="n">messages</span><span class="p">:</span> <span class="nb">print</span> <span class="p">(</span><span class="n">message</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">egrid</span><span class="p">,</span> <span class="n">xsecs_now</span>

    <span class="c1"># Resolved resonance reconstruction</span>
    <span class="k">if</span> <span class="n">reactionSuite</span><span class="o">.</span><span class="n">resonances</span><span class="o">.</span><span class="n">resolved</span><span class="p">:</span>
        <span class="c1"># For multiple regions, we need to do each region separately, then add them to the unified xs table &amp; egrid</span>
        <span class="k">if</span> <span class="n">reactionSuite</span><span class="o">.</span><span class="n">resonances</span><span class="o">.</span><span class="n">resolved</span><span class="o">.</span><span class="n">multipleRegions</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;      WARNING! Multiple resolved/unresolved energy regions are deprecated</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="o">+</span><span class="s2">&quot;        and should be consolidated into single section&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">RRidx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">reactionSuite</span><span class="o">.</span><span class="n">resonances</span><span class="o">.</span><span class="n">resolved</span><span class="o">.</span><span class="n">regions</span><span class="p">)):</span>
                <span class="n">formalism</span> <span class="o">=</span> <span class="n">reactionSuite</span><span class="o">.</span><span class="n">resonances</span><span class="o">.</span><span class="n">resolved</span><span class="o">.</span><span class="n">regions</span><span class="p">[</span><span class="n">RRidx</span><span class="p">]</span><span class="o">.</span><span class="n">evaluated</span>
                <span class="n">egrid_now</span><span class="p">,</span> <span class="n">xsecs_now</span> <span class="o">=</span> <span class="n">resolvedReconstruct</span><span class="p">(</span> <span class="n">formalism</span><span class="p">,</span> <span class="n">RRidx</span> <span class="p">)</span>
                <span class="c1"># merge with &#39;full&#39; energy grid:</span>
                <span class="n">egrids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">egrid_now</span> <span class="p">)</span>
                <span class="n">xsecs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">xsecs_now</span> <span class="p">)</span>
        <span class="c1"># Single region, everything goes on unified grid</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">formalism</span> <span class="o">=</span> <span class="n">reactionSuite</span><span class="o">.</span><span class="n">resonances</span><span class="o">.</span><span class="n">resolved</span><span class="o">.</span><span class="n">evaluated</span>
            <span class="n">egrid_now</span><span class="p">,</span> <span class="n">xsecs_now</span> <span class="o">=</span> <span class="n">resolvedReconstruct</span><span class="p">(</span> <span class="n">formalism</span> <span class="p">)</span>
            <span class="c1"># merge with &#39;full&#39; energy grid:</span>
            <span class="n">egrids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">egrid_now</span> <span class="p">)</span>
            <span class="n">xsecs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">xsecs_now</span> <span class="p">)</span>

    <span class="c1"># Unresolved region has more complex logic, we may do one of a couple of things:</span>
    <span class="c1">#   a) do nothing</span>
    <span class="c1">#   b) reconstruct the average cross section assuming SLBW resonances (traditional ENDF)</span>
    <span class="c1">#   c) reconstruct the average xs and the PDF for the xs</span>
    <span class="k">if</span> <span class="n">reactionSuite</span><span class="o">.</span><span class="n">resonances</span><span class="o">.</span><span class="n">unresolved</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">reactionSuite</span><span class="o">.</span><span class="n">resonances</span><span class="o">.</span><span class="n">unresolved</span><span class="o">.</span><span class="n">reconstructCrossSection</span><span class="p">:</span> <span class="c1"># don&#39;t reconstruct</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;Skipping unresolved: for self shielding only&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">formalism</span> <span class="o">=</span> <span class="n">reactionSuite</span><span class="o">.</span><span class="n">resonances</span><span class="o">.</span><span class="n">unresolved</span><span class="o">.</span><span class="n">evaluated</span>
            <span class="n">reconstructClass</span> <span class="o">=</span> <span class="n">URRcrossSection</span><span class="p">(</span> <span class="n">reactionSuite</span><span class="p">,</span> <span class="n">verbose</span><span class="p">,</span> <span class="n">energyUnit</span><span class="o">=</span><span class="n">energyUnit</span> <span class="p">)</span>
            <span class="n">xsecs_now</span> <span class="o">=</span> <span class="n">reconstructClass</span><span class="o">.</span><span class="n">getCrossSection</span><span class="p">(</span> <span class="p">)</span>

            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            if tolerance:</span>
<span class="sd">                # Disabling this section since ENDF manual now states that we should interpolate cross sections rather than parameters for URR.</span>
<span class="sd">                egrid, xsecs_now, messages = reconstructClass.refineInterpolation(numpy.array(egrid), xsecs_now, tolerance)</span>
<span class="sd">                if verbose:</span>
<span class="sd">                    for message in messages: print (message)</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="c1"># meld with resolved region:</span>
            <span class="n">egrids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="kc">None</span> <span class="p">)</span>
            <span class="n">xsecs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">xsecs_now</span> <span class="p">)</span>

    <span class="c1"># &#39;xsecs&#39; list now holds one or more regions. Convert to pointwise or regions1d cross section instance:</span>
    <span class="n">xsecs_final</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">crossSectionAxes</span> <span class="o">=</span> <span class="n">crossSection</span><span class="o">.</span><span class="n">defaultAxes</span><span class="p">(</span> <span class="n">energyUnit</span> <span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xsecs</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>   <span class="c1"># only one region: treat as XYs1d</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">xsecs</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">xsecs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">key</span><span class="p">],</span> <span class="n">crossSection</span><span class="o">.</span><span class="n">XYs1d</span> <span class="p">):</span> <span class="n">xsecs_final</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">xsecs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">key</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">xsecs_final</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">crossSection</span><span class="o">.</span><span class="n">XYs1d</span><span class="p">(</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">crossSectionAxes</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">(</span><span class="n">egrids</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xsecs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">key</span><span class="p">]),</span> <span class="n">dataForm</span><span class="o">=</span><span class="s2">&quot;XsAndYs&quot;</span> <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>               <span class="c1"># multiple regions: treat as regions1d</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">xsecs</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">pwxs</span> <span class="o">=</span> <span class="n">crossSection</span><span class="o">.</span><span class="n">regions1d</span><span class="p">(</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">crossSectionAxes</span> <span class="p">)</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xsecs</span><span class="p">)):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">xsecs</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">key</span><span class="p">],</span> <span class="n">crossSection</span><span class="o">.</span><span class="n">XYs1d</span> <span class="p">):</span> <span class="n">xys</span> <span class="o">=</span> <span class="n">xsecs</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">key</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">xys</span> <span class="o">=</span> <span class="n">crossSection</span><span class="o">.</span><span class="n">XYs1d</span><span class="p">(</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">crossSectionAxes</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">(</span><span class="n">egrids</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">xsecs</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">key</span><span class="p">]),</span> <span class="n">dataForm</span><span class="o">=</span><span class="s2">&quot;XsAndYs&quot;</span> <span class="p">)</span>
                <span class="n">pwxs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">xys</span> <span class="p">)</span>
            <span class="n">xsecs_final</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">pwxs</span>

    <span class="c1"># note that this does not add the background contribution if any (ENDF-MF3 portion).</span>
    <span class="c1"># Use gnd.reactionSuite.reconstructResonances for that</span>
    <span class="k">return</span> <span class="n">xsecs_final</span></div>


<div class="viewcode-block" id="reconstructAngularDistributions"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.reconstructAngularDistributions">[docs]</a><span class="k">def</span> <span class="nf">reconstructAngularDistributions</span><span class="p">(</span><span class="n">reactionSuite</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">energyUnit</span><span class="o">=</span><span class="s1">&#39;eV&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reconstruct all pure two-body angular distributions from the resonance region.</span>
<span class="sd">    For MLBW and RM, that means &#39;elastic&#39; channel only, but R-Matrix evaluations can support additional channels.</span>
<span class="sd">    SLBW cannot be used for angular distributions.</span>

<span class="sd">    Returns a Python dict.  They key is the reaction and the value is a reconstructed</span>
<span class="sd">    distributions.angular.XYs2d instance containing Legendre expansions for each incident energy.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">angdists</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">angdistRegions</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">egrids</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Helper function to compute the per-region angular distributions</span>
    <span class="k">def</span> <span class="nf">resolvedReconstruct</span><span class="p">(</span> <span class="n">formalism</span><span class="p">,</span> <span class="n">sectionIndex</span> <span class="o">=</span> <span class="kc">None</span> <span class="p">):</span>

        <span class="c1"># Get the correct class</span>
        <span class="n">resCls</span> <span class="o">=</span> <span class="n">getResonanceReconstructionClass</span><span class="p">(</span><span class="n">formalism</span><span class="o">.</span><span class="n">moniker</span><span class="p">)</span>
        <span class="n">reconstructClass</span> <span class="o">=</span> <span class="n">resCls</span><span class="p">(</span> <span class="n">reactionSuite</span><span class="p">,</span> <span class="n">sectionIndex</span><span class="p">,</span> <span class="n">enableAngDists</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">energyUnit</span><span class="o">=</span><span class="n">energyUnit</span> <span class="p">)</span>

        <span class="c1"># Deal with potential thresholds by splitting up the energy grid at the thresholds</span>
        <span class="n">fullEgrid</span> <span class="o">=</span> <span class="n">reconstructClass</span><span class="o">.</span><span class="n">generateEnergyGrid</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">reconstructClass</span><span class="p">,</span><span class="s1">&#39;_thresholds&#39;</span><span class="p">):</span>
            <span class="n">thresholdIndices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">Xi</span> <span class="ow">in</span> <span class="n">reconstructClass</span><span class="o">.</span><span class="n">_thresholds</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">Xi</span> <span class="ow">in</span> <span class="n">fullEgrid</span><span class="p">:</span>
                    <span class="n">thresholdIndices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">fullEgrid</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">Xi</span><span class="p">))</span>
                <span class="n">thresholdIndices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">subgrids</span> <span class="o">=</span> <span class="p">[</span><span class="n">fullEgrid</span><span class="p">[</span><span class="n">thresholdIndices</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">thresholdIndices</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">thresholdIndices</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))]</span>
        <span class="k">else</span><span class="p">:</span> <span class="n">subgrids</span><span class="o">=</span><span class="p">[</span><span class="n">fullEgrid</span><span class="p">]</span>

        <span class="c1">#for egrid in subgrids:</span>
        <span class="c1">#    print type(reconstructClass),&quot;[%s, ..., %s]&quot;%(str(egrid[0]),str(egrid[-1]))</span>
        <span class="c1">#exit()</span>

        <span class="c1"># Now do the calculation &amp; merge the different regions</span>
        <span class="n">angularResults</span><span class="o">=</span><span class="p">{}</span>
        <span class="k">for</span> <span class="n">egrid</span> <span class="ow">in</span> <span class="n">subgrids</span><span class="p">:</span>
            <span class="nb">print</span> <span class="s2">&quot;Working egrid: [</span><span class="si">%s</span><span class="s2">, ..., </span><span class="si">%s</span><span class="s2">]&quot;</span><span class="o">%</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">egrid</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="nb">str</span><span class="p">(</span><span class="n">egrid</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">thisAngularResults</span> <span class="o">=</span> <span class="n">reconstructClass</span><span class="o">.</span><span class="n">getAngularDistribution</span><span class="p">(</span> <span class="n">egrid</span><span class="p">,</span> <span class="n">keepL0Term</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">renormalize</span><span class="o">=</span><span class="kc">True</span> <span class="p">)</span>
            <span class="k">if</span> <span class="n">tolerance</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Refining interpolation grid for angular distributions&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">reaction</span><span class="p">,</span> <span class="n">results</span> <span class="ow">in</span> <span class="n">thisAngularResults</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">reaction</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">angularResults</span><span class="p">:</span> <span class="n">angularResults</span><span class="p">[</span><span class="n">reaction</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">angularResults</span><span class="p">[</span><span class="n">reaction</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">zip</span><span class="p">(</span> <span class="n">egrid</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">results</span> <span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="p">)</span>
        <span class="k">return</span> <span class="n">angularResults</span>

    <span class="k">if</span> <span class="n">reactionSuite</span><span class="o">.</span><span class="n">resonances</span><span class="o">.</span><span class="n">resolved</span><span class="p">:</span>

        <span class="c1"># Compute the per-region angular distributions &amp; make a list of regional distributions</span>
        <span class="k">if</span> <span class="n">reactionSuite</span><span class="o">.</span><span class="n">resonances</span><span class="o">.</span><span class="n">resolved</span><span class="o">.</span><span class="n">multipleRegions</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Angular reconstruction for multiple resolved regions, untested&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;      WARNING! Multiple resolved/unresolved energy regions are deprecated</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="o">+</span><span class="s2">&quot;        and should be consolidated into single section&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">RRidx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">reactionSuite</span><span class="o">.</span><span class="n">resonances</span><span class="o">.</span><span class="n">resolved</span><span class="o">.</span><span class="n">regions</span><span class="p">)):</span>
                <span class="n">formalism</span> <span class="o">=</span> <span class="n">reactionSuite</span><span class="o">.</span><span class="n">resonances</span><span class="o">.</span><span class="n">resolved</span><span class="o">.</span><span class="n">regions</span><span class="p">[</span><span class="n">RRidx</span><span class="p">]</span><span class="o">.</span><span class="n">evaluated</span>
                <span class="n">angdistRegions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">resolvedReconstruct</span><span class="p">(</span> <span class="n">formalism</span><span class="p">,</span> <span class="n">RRidx</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">formalism</span> <span class="o">=</span> <span class="n">reactionSuite</span><span class="o">.</span><span class="n">resonances</span><span class="o">.</span><span class="n">resolved</span><span class="o">.</span><span class="n">evaluated</span>
            <span class="n">angdistRegions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">resolvedReconstruct</span><span class="p">(</span> <span class="n">formalism</span> <span class="p">)</span> <span class="p">)</span>

        <span class="c1"># Check that egrids don&#39;t overlap</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="n">angdistRegions</span> <span class="p">)</span> <span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">iRegion</span><span class="p">,</span> <span class="n">this_region</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">angdistRegions</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">next_region</span> <span class="o">=</span> <span class="n">angdistRegions</span><span class="p">[</span><span class="n">iRegion</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">this_region</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">next_region</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span> <span class="s2">&quot;this_region[-1][0] &gt; next_region[0][0] for region </span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">iRegion</span> <span class="p">)</span>

        <span class="c1"># &#39;angdistRegions&#39; list holds one or more regions.  Convert to one Legendre coefficient table</span>
        <span class="c1"># right now only do elastic scattering (OK for MLBW &amp; RM, but (unimplemented) RML can do more)</span>
        <span class="n">angdists_final</span><span class="o">=</span><span class="p">{}</span>
        <span class="n">angularAxes</span> <span class="o">=</span> <span class="n">distributions</span><span class="o">.</span><span class="n">angular</span><span class="o">.</span><span class="n">defaultAxes</span><span class="p">(</span> <span class="n">energyUnit</span> <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">angdistRegions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>    <span class="c1"># only one region, treat as XYs2d</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">angdistRegions</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">form</span> <span class="o">=</span> <span class="n">distributions</span><span class="o">.</span><span class="n">angular</span><span class="o">.</span><span class="n">XYs2d</span><span class="p">(</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">angularAxes</span> <span class="p">)</span>
                <span class="k">for</span> <span class="n">i1</span><span class="p">,</span> <span class="n">E_Bs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span> <span class="n">angdistRegions</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="p">):</span>
                    <span class="n">form</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">distributions</span><span class="o">.</span><span class="n">angular</span><span class="o">.</span><span class="n">Legendre</span><span class="p">(</span> <span class="n">coefficients</span> <span class="o">=</span> <span class="n">E_Bs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">value</span> <span class="o">=</span> <span class="n">E_Bs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">angularAxes</span> <span class="p">)</span> <span class="p">)</span>
                <span class="n">angdists_final</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">form</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Still TBD&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">angdists_final</span></div>


<div class="viewcode-block" id="reconstructURRCrossSectionPDF"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.reconstructURRCrossSectionPDF">[docs]</a><span class="k">def</span> <span class="nf">reconstructURRCrossSectionPDF</span><span class="p">(</span><span class="n">reactionSuite</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">reconstructionScheme</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

    <span class="c1"># Determine how to represent the resonance region we are going to make up</span>
    <span class="k">if</span> <span class="n">reconstructionScheme</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">reactionSuite</span><span class="o">.</span><span class="n">resonances</span><span class="o">.</span><span class="n">resolved</span><span class="o">.</span><span class="n">multipleRegions</span><span class="p">:</span>
            <span class="n">reconstructionScheme</span> <span class="o">=</span> <span class="n">reactionSuite</span><span class="o">.</span><span class="n">resonances</span><span class="o">.</span><span class="n">resolved</span><span class="o">.</span><span class="n">regions</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">evaluated</span><span class="o">.</span><span class="n">moniker</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">reconstructionScheme</span> <span class="o">=</span> <span class="n">reactionSuite</span><span class="o">.</span><span class="n">resonances</span><span class="o">.</span><span class="n">resolved</span><span class="o">.</span><span class="n">evaluated</span><span class="o">.</span><span class="n">moniker</span>
    <span class="k">if</span> <span class="n">reconstructionScheme</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">RRClassMap</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown resonance moniker </span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="n">reconstructionScheme</span><span class="p">)</span>

    <span class="c1"># Set the resonance reconstruction class that will generate fake resonance regions for us</span>
    <span class="n">resCls</span><span class="o">=</span><span class="n">getResonanceReconstructionClass</span><span class="p">(</span><span class="n">reconstructionScheme</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">URRcrossSection</span><span class="p">(</span> <span class="n">reactionSuite</span><span class="p">,</span> <span class="n">verbose</span> <span class="p">)</span><span class="o">.</span><span class="n">getURRPDF</span><span class="p">(</span> <span class="n">resCls</span> <span class="p">)</span></div>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">@blockwise: function decorator for improving performance in resolved region.</span>
<span class="sd">Each &#39;getCrossSection&#39; and &#39;getAngularDistribution&#39; method is wrapped by this function.</span>
<span class="sd">If we have lots of incident energies, this splits up a calculation using the multiprocessing module.</span>
<span class="sd">May still need to tweak the &#39;NE&#39; and &#39;nprocesses&#39; variables for best performance.</span>
<span class="sd">&quot;&quot;&quot;</span>
<div class="viewcode-block" id="blockwise"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.blockwise">[docs]</a><span class="k">def</span> <span class="nf">blockwise</span><span class="p">(</span><span class="n">function</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapped</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">E</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="c1"># disable multiprocessing</span>
            <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">E</span><span class="p">):</span>
                <span class="n">E</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">E</span><span class="p">]])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">E</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">E</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">),</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">E</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">E</span><span class="p">):</span>
            <span class="n">E</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">E</span><span class="p">]])</span>
            <span class="k">return</span> <span class="n">function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">E</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">NE</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
            <span class="c1"># turn E into a column vector</span>
            <span class="n">E</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">E</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">NE</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">NE</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">:</span> <span class="c1"># faster to run directly</span>
                <span class="k">return</span> <span class="n">function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">E</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="k">import</span> <span class="n">Process</span><span class="p">,</span> <span class="n">Queue</span>
                <span class="n">queue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>

                <span class="k">def</span> <span class="nf">enqueue_result</span><span class="p">(</span><span class="n">elist</span><span class="p">,</span> <span class="n">Slice</span><span class="p">,</span> <span class="n">queue</span><span class="p">):</span>
                    <span class="c1"># perform the calculation, put result in the queue</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elist</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                        <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span> <span class="p">(</span><span class="n">Slice</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span> <span class="p">)</span>
                    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                        <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span> <span class="p">(</span><span class="n">Slice</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span> <span class="p">)</span>

                <span class="n">jobs</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">nprocesses</span> <span class="o">=</span> <span class="mi">8</span>  <span class="c1"># number of processes to spawn</span>
                <span class="n">errorsEncountered</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="c1"># how many energies does each process calculate?</span>
                <span class="n">chunk</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">NE</span><span class="o">+</span><span class="mf">0.</span><span class="p">)</span> <span class="o">/</span> <span class="n">nprocesses</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">pid</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nprocesses</span><span class="p">):</span> <span class="c1"># start the calculations</span>
                    <span class="n">Slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">pid</span><span class="o">*</span><span class="n">chunk</span><span class="p">,</span> <span class="p">(</span><span class="n">pid</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">chunk</span><span class="p">)</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">enqueue_result</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="n">Slice</span><span class="p">],</span> <span class="n">Slice</span><span class="p">,</span> <span class="n">queue</span><span class="p">))</span>
                    <span class="n">jobs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                    <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

                <span class="k">for</span> <span class="n">pid</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nprocesses</span><span class="p">):</span> <span class="c1"># collect results as they finish</span>
                    <span class="n">Slice</span><span class="p">,</span> <span class="n">vals</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">):</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error in child process #</span><span class="si">%d</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">pid</span><span class="p">,</span><span class="n">vals</span><span class="p">))</span>
                        <span class="n">errorsEncountered</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">function</span><span class="o">.</span><span class="n">__name__</span> <span class="o">==</span> <span class="s1">&#39;getCrossSection&#39;</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">result</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span> <span class="n">vals</span> <span class="p">)</span>
                            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span> <span class="n">result</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">NE</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
                            <span class="n">result</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">Slice</span><span class="p">]</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="n">function</span><span class="o">.</span><span class="n">__name__</span> <span class="o">==</span> <span class="s1">&#39;getAngularDistribution&#39;</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">result</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span> <span class="n">vals</span> <span class="p">)</span>
                            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span> <span class="n">result</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">NE</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span> <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="n">key</span><span class="p">]))]</span>
                        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="n">key</span><span class="p">])):</span>
                                <span class="n">result</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">L</span><span class="p">][</span><span class="n">Slice</span><span class="p">]</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">L</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Blockwise computation for function </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">function</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>

                <span class="c1"># allow child processes to exit:</span>
                <span class="k">for</span> <span class="n">job</span> <span class="ow">in</span> <span class="n">jobs</span><span class="p">:</span> <span class="n">job</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">errorsEncountered</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Aborting due to errors in child processes&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">result</span>
    <span class="k">return</span> <span class="n">wrapped</span></div>


<span class="c1"># base class common to resolved and unresolved resonance reconstruction</span>
<div class="viewcode-block" id="resonanceReconstructionBaseClass"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.resonanceReconstructionBaseClass">[docs]</a><span class="k">class</span> <span class="nc">resonanceReconstructionBaseClass</span><span class="p">:</span>

    <span class="n">__metaclass__</span> <span class="o">=</span> <span class="n">abc</span><span class="o">.</span><span class="n">ABCMeta</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">reactionSuite</span><span class="p">,</span> <span class="n">energyUnit</span> <span class="o">=</span> <span class="s1">&#39;eV&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span> <span class="p">)</span> <span class="p">:</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">neutron</span> <span class="o">=</span> <span class="n">reactionSuite</span><span class="o">.</span><span class="n">PoPs</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">neutronMass_amu</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span> <span class="n">neutron</span><span class="o">.</span><span class="n">mass</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pqu</span><span class="p">(</span> <span class="s1">&#39;amu&#39;</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">neutronMass_amu</span> <span class="o">=</span> <span class="mf">1.00866491574</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span> <span class="o">=</span> <span class="n">energyUnit</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">projectile</span> <span class="o">=</span> <span class="n">reactionSuite</span><span class="o">.</span><span class="n">projectile</span>
        <span class="n">projectile</span> <span class="o">=</span> <span class="n">reactionSuite</span><span class="o">.</span><span class="n">PoPs</span><span class="p">[</span><span class="n">reactionSuite</span><span class="o">.</span><span class="n">projectile</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">projectileMass_amu</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span> <span class="n">projectile</span><span class="o">.</span><span class="n">mass</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pqu</span><span class="p">(</span> <span class="s1">&#39;amu&#39;</span> <span class="p">)</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">projectileSpin</span> <span class="o">=</span> <span class="n">projectile</span><span class="o">.</span><span class="n">spin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">target</span> <span class="o">=</span> <span class="n">reactionSuite</span><span class="o">.</span><span class="n">target</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">reactionSuite</span><span class="o">.</span><span class="n">PoPs</span><span class="p">[</span><span class="n">reactionSuite</span><span class="o">.</span><span class="n">target</span><span class="p">]</span>
        <span class="k">if</span><span class="p">(</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">target</span><span class="p">,</span> <span class="n">nuclearLevelPoPsModule</span><span class="o">.</span><span class="n">particle</span> <span class="p">)</span> <span class="p">)</span> <span class="p">:</span>
            <span class="n">isotope</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">getAncestor</span><span class="p">(</span> <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">targetMass_amu</span> <span class="o">=</span> <span class="n">isotope</span><span class="o">.</span><span class="n">mass</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">float</span><span class="p">(</span> <span class="s1">&#39;amu&#39;</span> <span class="p">)</span>
        <span class="k">else</span> <span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">targetMass_amu</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">mass</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">float</span><span class="p">(</span> <span class="s1">&#39;amu&#39;</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">targetSpin</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">nucleus</span><span class="o">.</span><span class="n">spin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">targetToNeutronMassRatio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">targetMass_amu</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">neutronMass_amu</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">reactionSuite</span> <span class="o">=</span> <span class="n">reactionSuite</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
<div class="viewcode-block" id="resonanceReconstructionBaseClass.getCrossSection"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.resonanceReconstructionBaseClass.getCrossSection">[docs]</a>    <span class="k">def</span> <span class="nf">getCrossSection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">):</span> <span class="k">pass</span></div>

<div class="viewcode-block" id="resonanceReconstructionBaseClass.k"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.resonanceReconstructionBaseClass.k">[docs]</a>    <span class="k">def</span> <span class="nf">k</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">energy</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For an incident neutron, with energy in eV, the ENDF manual states</span>
<span class="sd">        :math:`k = \frac{\sqrt{2m_n}}{\hbar}\frac{AWRI}{AWRI+1}\sqrt{|E|}`</span>

<span class="sd">        sqrt( 2 * neutronMass ) / hbar == 2.196807e-3 (eV*barn)**-1/2. Thus for energy in eV, k is in b**-1/2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="mf">2.196807122623e-3</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">targetToNeutronMassRatio</span> <span class="o">/</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targetToNeutronMassRatio</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">energy</span><span class="p">))</span></div>

    <span class="sd">&quot;&quot;&quot; refer to SAMMY manual page 9 for penetration/shift/phase factor equations: &quot;&quot;&quot;</span>
<div class="viewcode-block" id="resonanceReconstructionBaseClass.penetrationFactor"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.resonanceReconstructionBaseClass.penetrationFactor">[docs]</a>    <span class="k">def</span> <span class="nf">penetrationFactor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">rho</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">L</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="n">rho</span>
        <span class="k">elif</span> <span class="n">L</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="n">rho</span><span class="o">**</span><span class="mi">3</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">L</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span> <span class="k">return</span> <span class="n">rho</span><span class="o">**</span><span class="mi">5</span> <span class="o">/</span> <span class="p">(</span><span class="mi">9</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">rho</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">L</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span> <span class="k">return</span> <span class="n">rho</span><span class="o">**</span><span class="mi">7</span> <span class="o">/</span> <span class="p">(</span><span class="mi">225</span><span class="o">+</span><span class="mi">45</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="mi">6</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">4</span><span class="o">+</span><span class="n">rho</span><span class="o">**</span><span class="mi">6</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">L</span><span class="o">==</span><span class="mi">4</span><span class="p">:</span> <span class="k">return</span> <span class="n">rho</span><span class="o">**</span><span class="mi">9</span> <span class="o">/</span> <span class="p">(</span><span class="mi">11025</span><span class="o">+</span><span class="mi">1575</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="mi">135</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">4</span><span class="o">+</span><span class="mi">10</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">6</span><span class="o">+</span><span class="n">rho</span><span class="o">**</span><span class="mi">8</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">L</span><span class="o">&gt;</span><span class="mi">4</span><span class="p">:</span>
            <span class="c1"># find it recursively</span>
            <span class="n">P_Lminus1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactor</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">rho</span><span class="p">)</span>
            <span class="n">S_Lminus1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shiftFactor</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">rho</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">rho</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">P_Lminus1</span> <span class="o">/</span> <span class="p">((</span><span class="n">L</span><span class="o">-</span><span class="n">S_Lminus1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">P_Lminus1</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span></div>

<div class="viewcode-block" id="resonanceReconstructionBaseClass.shiftFactor"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.resonanceReconstructionBaseClass.shiftFactor">[docs]</a>    <span class="k">def</span> <span class="nf">shiftFactor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">rho</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; calculate shift factor used in SLBW and MLBW formalisms &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">L</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="mf">0.0</span><span class="o">*</span><span class="n">rho</span>   <span class="c1"># rho may be an array</span>
        <span class="k">elif</span> <span class="n">L</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">L</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span> <span class="k">return</span> <span class="o">-</span><span class="p">(</span><span class="mf">18.0</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">9</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">rho</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">L</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span> <span class="k">return</span> <span class="o">-</span><span class="p">(</span><span class="mf">675.0</span><span class="o">+</span><span class="mi">90</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="mi">6</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">225</span><span class="o">+</span><span class="mi">45</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="mi">6</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">4</span><span class="o">+</span><span class="n">rho</span><span class="o">**</span><span class="mi">6</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">L</span><span class="o">==</span><span class="mi">4</span><span class="p">:</span> <span class="k">return</span> <span class="o">-</span><span class="p">(</span> <span class="p">(</span><span class="mf">44100.0</span><span class="o">+</span><span class="mi">4725</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="mi">270</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">4</span><span class="o">+</span><span class="mi">10</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">6</span><span class="p">)</span> <span class="o">/</span>
                <span class="p">(</span><span class="mi">11025</span><span class="o">+</span><span class="mi">1575</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="mi">135</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">4</span><span class="o">+</span><span class="mi">10</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">6</span><span class="o">+</span><span class="n">rho</span><span class="o">**</span><span class="mi">8</span><span class="p">)</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="n">L</span><span class="o">&gt;</span><span class="mi">4</span><span class="p">:</span>
            <span class="n">P_Lminus1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactor</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">rho</span><span class="p">)</span>
            <span class="n">S_Lminus1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shiftFactor</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">rho</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">S_Lminus1</span><span class="p">)</span> <span class="o">/</span> <span class="p">((</span><span class="n">L</span><span class="o">-</span><span class="n">S_Lminus1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">P_Lminus1</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">L</span><span class="p">)</span></div>

<div class="viewcode-block" id="resonanceReconstructionBaseClass.phi"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.resonanceReconstructionBaseClass.phi">[docs]</a>    <span class="k">def</span> <span class="nf">phi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">rho</span><span class="p">):</span>
        <span class="c1"># calculate hard-sphere phase-shift</span>
        <span class="k">if</span>   <span class="n">L</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="n">rho</span>
        <span class="k">elif</span> <span class="n">L</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="n">rho</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">L</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span> <span class="k">return</span> <span class="n">rho</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">rho</span><span class="o">/</span><span class="p">(</span><span class="mi">3</span><span class="o">-</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">L</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span> <span class="k">return</span> <span class="n">rho</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="mi">15</span><span class="o">-</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">15</span><span class="o">-</span><span class="mi">6</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">L</span><span class="o">==</span><span class="mi">4</span><span class="p">:</span> <span class="k">return</span> <span class="n">rho</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="mi">105</span><span class="o">-</span><span class="mi">10</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">105</span><span class="o">-</span><span class="mi">45</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">rho</span><span class="o">**</span><span class="mi">4</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">L</span><span class="o">&gt;</span><span class="mi">4</span><span class="p">:</span>
            <span class="n">P_Lminus1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactor</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">rho</span><span class="p">)</span>
            <span class="n">S_Lminus1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shiftFactor</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">rho</span><span class="p">)</span>
            <span class="n">phi_Lminus1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">rho</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">phi_Lminus1</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">P_Lminus1</span> <span class="o">/</span> <span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">S_Lminus1</span><span class="p">))</span></div>

    <span class="c1"># for use after the cross section has been calculated on the initial grid:</span>
<div class="viewcode-block" id="resonanceReconstructionBaseClass.refineInterpolation"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.resonanceReconstructionBaseClass.refineInterpolation">[docs]</a>    <span class="k">def</span> <span class="nf">refineInterpolation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">egrid</span><span class="p">,</span> <span class="n">xsecs</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">significantDigits</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; generateEnergyGrid may not give a fine enough grid to linearly interpolate to desired tolerance.</span>
<span class="sd">        My solution to that: for all consecutive points (x0,y0), (x1,y1) and (x2,y2) do a linear interpolation between</span>
<span class="sd">        (x0,y0) and (x2,y2). If the interpolation doesn&#39;t agree with (x1,y1) within tolerance,</span>
<span class="sd">        subdivide up the region by adding two more calculated points.  Iterate until interpolation agrees within tolerance.</span>

<span class="sd">        This means that in the end we will have more points than required for given tolerance.</span>
<span class="sd">        The results can be thinned (thinning implemented in xData.XYs1d)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">checkInterpolation</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Does a linear interpolation of each point from its two nearest neighbors,</span>
<span class="sd">            checks where the interpolation grid is insufficient and returns a list of indices (in array x)</span>
<span class="sd">            where additional points are needed.</span>

<span class="sd">            @type x: numpy.multiarray.ndarray</span>
<span class="sd">            @type y: numpy.multiarray.ndarray</span>
<span class="sd">            :return:</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span><span class="o">-</span><span class="n">y</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span><span class="o">-</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">delta_x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">y</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>

            <span class="c1"># add first and last points back in, for easier comparison with</span>
            <span class="c1"># original y values:</span>
            <span class="n">interpolated</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">interpolated</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="o">*</span><span class="n">delta_x</span><span class="o">+</span><span class="n">b</span>
            <span class="n">interpolated</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">interpolated</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># find where original and interpolated grids differ by more than tolerance</span>
            <span class="c1"># silence div/0 warnings for this step, since xsc = 0 case is explicitly handled below</span>
            <span class="k">with</span> <span class="n">numpy</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span> <span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span> <span class="p">):</span>
                <span class="n">delt</span> <span class="o">=</span> <span class="n">interpolated</span> <span class="o">/</span> <span class="n">y</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">delt</span><span class="o">&gt;</span><span class="mi">1</span><span class="o">+</span><span class="n">tolerance</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">delt</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">-</span><span class="n">tolerance</span><span class="p">)</span> <span class="c1"># boolean array</span>

            <span class="n">badindices</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mask</span><span class="p">))[</span> <span class="n">mask</span> <span class="p">]</span>    <span class="c1"># points where finer mesh is needed</span>

            <span class="c1"># switch to absolute convergence condition for very small cross sections (i.e. near thresholds):</span>
            <span class="n">smallXSec</span> <span class="o">=</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">50</span>
            <span class="n">zeros</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">badindices</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;</span><span class="n">smallXSec</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">badindices</span><span class="p">]</span><span class="o">&lt;</span><span class="n">smallXSec</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">badindices</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;</span><span class="n">smallXSec</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">zeros</span><span class="p">):</span>
                <span class="n">ignore</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">badindices</span><span class="p">[</span> <span class="n">zeros</span> <span class="p">]:</span>
                    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">-</span><span class="n">y</span><span class="p">[</span><span class="n">idx</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">&lt;</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">3</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">y</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span><span class="o">&lt;</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">3</span><span class="p">:</span>
                        <span class="n">mask</span><span class="p">[</span> <span class="n">idx</span> <span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="n">ignore</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">idx</span> <span class="p">)</span>
                <span class="n">badindices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">badindices</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">ignore</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">badindices</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">badindices</span>

        <span class="n">messages</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">reactionDone</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">xsecs</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">n_iter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">addedPoints</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">newIdx</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">xsecs</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">xsecs</span><span class="p">[</span><span class="n">key</span><span class="p">]):</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">reactionDone</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
                    <span class="n">badindices</span> <span class="o">=</span> <span class="n">checkInterpolation</span><span class="p">(</span><span class="n">egrid</span><span class="p">,</span><span class="n">xsecs</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">badindices</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="n">reactionDone</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">newIdx</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="n">badindices</span> <span class="p">)</span>
            <span class="n">newIdx</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">newIdx</span><span class="p">)</span>

            <span class="n">mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">egrid</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span> <span class="p">)</span>
            <span class="n">mask</span><span class="p">[</span><span class="n">newIdx</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">midpoints</span> <span class="o">=</span> <span class="p">(</span><span class="n">egrid</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">egrid</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span><span class="o">/</span><span class="mi">2</span>

            <span class="n">energies_needed</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span> <span class="nb">set</span><span class="p">(</span> <span class="nb">list</span><span class="p">(</span><span class="n">midpoints</span><span class="p">[</span><span class="n">mask</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">midpoints</span><span class="p">[</span><span class="n">mask</span><span class="p">[</span><span class="mi">1</span><span class="p">:]])</span> <span class="p">)</span> <span class="p">)</span>
            <span class="k">if</span> <span class="n">significantDigits</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">rounded</span> <span class="o">=</span> <span class="n">RoundToSigFigs</span><span class="p">(</span> <span class="n">energies_needed</span><span class="p">,</span> <span class="n">significantDigits</span> <span class="p">)</span>
                <span class="n">rounded</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span> <span class="n">rounded</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="p">)</span>
                <span class="n">rounded</span><span class="o">.</span><span class="n">difference_update</span><span class="p">(</span> <span class="n">egrid</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="p">)</span> <span class="c1"># remove any rounded values that were already computed</span>
                <span class="n">energies_needed</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span> <span class="n">rounded</span> <span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">energies_needed</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>    <span class="c1"># success!</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="n">n_iter</span> <span class="o">&gt;</span> <span class="mi">20</span><span class="p">:</span>
                <span class="n">messages</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Iteration limit exceeded when refining interpolation grid!&quot;</span><span class="p">)</span>
                <span class="k">break</span>
            <span class="n">n_iter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;Iteration #</span><span class="si">%d</span><span class="s2">: adding </span><span class="si">%d</span><span class="s2"> points to interpolation grid&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n_iter</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">energies_needed</span><span class="p">))</span> <span class="p">)</span>
            <span class="n">addedPoints</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">energies_needed</span><span class="p">)</span>
            <span class="n">newY</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getCrossSection</span><span class="p">(</span> <span class="n">energies_needed</span> <span class="p">)</span>
            <span class="c1"># merge new x/y values with original list:</span>
            <span class="n">fulllist</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">egrid</span><span class="p">,</span> <span class="n">energies_needed</span> <span class="p">)</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span> <span class="n">fulllist</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;merged&#39;</span> <span class="p">)</span>
            <span class="n">egrid</span> <span class="o">=</span> <span class="n">fulllist</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">xsecs</span><span class="p">:</span>
                <span class="n">xsecs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">xsecs</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">newY</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">)[</span> <span class="n">order</span> <span class="p">]</span>

        <span class="n">messages</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%i</span><span class="s2"> points were added (for total of </span><span class="si">%i</span><span class="s2">) to achieve tolerance of </span><span class="si">%s%%</span><span class="s2">&quot;</span> <span class="o">%</span>
            <span class="p">(</span><span class="n">addedPoints</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">egrid</span><span class="p">),</span> <span class="n">tolerance</span><span class="o">*</span><span class="mi">100</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">egrid</span><span class="p">,</span> <span class="n">xsecs</span><span class="p">,</span> <span class="n">messages</span></div></div>


<span class="c1">#### base class for resolved resonance reconstruction ####</span>
<div class="viewcode-block" id="RRBaseClass"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass">[docs]</a><span class="k">class</span> <span class="nc">RRBaseClass</span><span class="p">(</span><span class="n">resonanceReconstructionBaseClass</span><span class="p">):</span>

    <span class="n">__metaclass__</span> <span class="o">=</span> <span class="n">abc</span><span class="o">.</span><span class="n">ABCMeta</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reactionSuite</span><span class="p">,</span> <span class="n">sectionIndex</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lowerBound</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">upperBound</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">RR</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">RRBaseClass</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">reactionSuite</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot; store resonance parameters in convenient structure for quick cross section calculations: &quot;&quot;&quot;</span>


        <span class="k">if</span> <span class="n">sectionIndex</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># energy boundaries for this region (multiple regions are deprecated):</span>
            <span class="n">energyRegion</span> <span class="o">=</span> <span class="n">reactionSuite</span><span class="o">.</span><span class="n">resonances</span><span class="o">.</span><span class="n">resolved</span><span class="o">.</span><span class="n">regions</span><span class="p">[</span><span class="n">sectionIndex</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># only one energy region:</span>
            <span class="n">energyRegion</span> <span class="o">=</span> <span class="n">reactionSuite</span><span class="o">.</span><span class="n">resonances</span><span class="o">.</span><span class="n">resolved</span>

        <span class="k">if</span> <span class="n">RR</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span> <span class="o">=</span> <span class="n">energyRegion</span><span class="o">.</span><span class="n">evaluated</span>
        <span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span> <span class="o">=</span> <span class="n">RR</span>

        <span class="k">if</span> <span class="n">lowerBound</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lowerBound</span> <span class="o">=</span> <span class="n">PQU</span><span class="o">.</span><span class="n">PQU</span><span class="p">(</span> <span class="n">energyRegion</span><span class="o">.</span><span class="n">domainMin</span><span class="p">,</span> <span class="n">energyRegion</span><span class="o">.</span><span class="n">domainUnit</span> <span class="p">)</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">lowerBound</span> <span class="o">=</span> <span class="n">lowerBound</span>

        <span class="k">if</span> <span class="n">upperBound</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">upperBound</span> <span class="o">=</span> <span class="n">PQU</span><span class="o">.</span><span class="n">PQU</span><span class="p">(</span> <span class="n">energyRegion</span><span class="o">.</span><span class="n">domainMax</span><span class="p">,</span> <span class="n">energyRegion</span><span class="o">.</span><span class="n">domainUnit</span> <span class="p">)</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">upperBound</span> <span class="o">=</span> <span class="n">upperBound</span>

<div class="viewcode-block" id="RRBaseClass.sortLandJ"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.sortLandJ">[docs]</a>    <span class="k">def</span> <span class="nf">sortLandJ</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        SLBW, MLBW and Reich_Moore formalisms have similar structure</span>
<span class="sd">        it&#39;s convenient to sort their resonances by L and J</span>
<span class="sd">        This method should NOT be used for R-Matrix Limited</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># make a unified table of resonance parameter data, convert to self.energyUnit if necessary</span>
        <span class="n">nRes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">resonanceParameters</span><span class="o">.</span><span class="n">table</span> <span class="p">)</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;energy&#39;</span><span class="p">,</span><span class="s1">&#39;L&#39;</span><span class="p">,</span><span class="s1">&#39;J&#39;</span><span class="p">,</span><span class="s1">&#39;channelSpin&#39;</span><span class="p">,</span><span class="s1">&#39;totalWidth&#39;</span><span class="p">,</span><span class="s1">&#39;neutronWidth&#39;</span><span class="p">,</span><span class="s1">&#39;captureWidth&#39;</span><span class="p">,</span>
                <span class="s1">&#39;fissionWidth&#39;</span><span class="p">,</span><span class="s1">&#39;fissionWidthB&#39;</span><span class="p">)</span>
        <span class="n">EU</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span>
        <span class="n">units</span> <span class="o">=</span> <span class="p">(</span><span class="n">EU</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="n">EU</span><span class="p">,</span><span class="n">EU</span><span class="p">,</span><span class="n">EU</span><span class="p">,</span><span class="n">EU</span><span class="p">,</span><span class="n">EU</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">resonanceParameters</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">getColumn</span><span class="p">(</span> <span class="n">quant</span><span class="p">,</span><span class="n">unit</span> <span class="p">)</span> <span class="k">for</span> <span class="n">quant</span><span class="p">,</span><span class="n">unit</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">params</span><span class="p">,</span><span class="n">units</span><span class="p">)</span> <span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">nRes</span>
        <span class="n">table</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">data</span> <span class="p">)</span>

        <span class="c1"># sort resonances by L and J, store parameters in numpy arrays</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Ls</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">Llist</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span> <span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;L&#39;</span><span class="p">)</span> <span class="p">]</span>
        <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span> <span class="n">Llist</span> <span class="p">))</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">Lres</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span> <span class="p">:,</span> <span class="n">table</span><span class="p">[</span> <span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;L&#39;</span><span class="p">)</span> <span class="p">]</span><span class="o">==</span><span class="n">L</span> <span class="p">]</span>
            <span class="n">Jlist</span> <span class="o">=</span> <span class="n">Lres</span><span class="p">[</span> <span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;J&#39;</span><span class="p">)</span> <span class="p">]</span>
            <span class="n">Js</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">J</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">Jlist</span><span class="p">)):</span>
                <span class="n">LJres</span> <span class="o">=</span> <span class="n">Lres</span><span class="p">[</span> <span class="p">:,</span> <span class="n">Lres</span><span class="p">[</span> <span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;J&#39;</span><span class="p">)</span> <span class="p">]</span><span class="o">==</span><span class="n">J</span> <span class="p">]</span>
                <span class="n">spinList</span> <span class="o">=</span> <span class="n">LJres</span><span class="p">[</span> <span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;channelSpin&#39;</span><span class="p">)</span> <span class="p">]</span>
                <span class="n">spins</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">spin</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">spinList</span><span class="p">)):</span>
                    <span class="n">spinRes</span> <span class="o">=</span> <span class="n">LJres</span><span class="p">[</span> <span class="p">:,</span> <span class="n">LJres</span><span class="p">[</span> <span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;channelSpin&#39;</span><span class="p">)</span> <span class="p">]</span><span class="o">==</span><span class="n">spin</span> <span class="p">]</span>
                    <span class="n">energies</span> <span class="o">=</span> <span class="n">spinRes</span><span class="p">[</span> <span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;energy&#39;</span><span class="p">)</span> <span class="p">]</span>
                    <span class="n">neutronWidth</span> <span class="o">=</span> <span class="p">(</span> <span class="n">spinRes</span><span class="p">[</span> <span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;neutronWidth&#39;</span><span class="p">)</span> <span class="p">]</span> <span class="o">/</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactor</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">energies</span><span class="p">),</span><span class="n">L</span><span class="p">))</span> <span class="p">)</span>
                    <span class="c1"># FIXME for easier-to-read code, should I wait until getCrossSection</span>
                    <span class="c1"># to adjust the neutronWidth for penetrability at resonances?</span>

                    <span class="n">spindict</span> <span class="o">=</span> <span class="p">{</span>
                            <span class="s1">&#39;channelSpin&#39;</span><span class="p">:</span> <span class="n">spin</span><span class="p">,</span>
                            <span class="s1">&#39;energy&#39;</span><span class="p">:</span> <span class="n">energies</span><span class="p">,</span>
                            <span class="s1">&#39;neutronWidth&#39;</span><span class="p">:</span> <span class="n">neutronWidth</span><span class="p">,</span>
                            <span class="s1">&#39;captureWidth&#39;</span><span class="p">:</span> <span class="n">spinRes</span><span class="p">[</span><span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;captureWidth&#39;</span><span class="p">)],</span>
                            <span class="s1">&#39;fissionWidth&#39;</span><span class="p">:</span> <span class="n">spinRes</span><span class="p">[</span><span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;fissionWidth&#39;</span><span class="p">)],</span>
                            <span class="s1">&#39;fissionWidthB&#39;</span><span class="p">:</span> <span class="n">spinRes</span><span class="p">[</span><span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;fissionWidthB&#39;</span><span class="p">)],</span>
                            <span class="s1">&#39;shiftFactor&#39;</span><span class="p">:</span> <span class="mf">0.5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">shiftFactor</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">energies</span><span class="p">))),</span>
                            <span class="p">}</span>
                    <span class="n">spins</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">spindict</span> <span class="p">)</span>
                <span class="n">Jdict</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="s1">&#39;J&#39;</span><span class="p">:</span> <span class="n">J</span><span class="p">,</span>
                        <span class="s1">&#39;gfact&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">projectileSpin</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">targetSpin</span><span class="o">+</span><span class="mi">1</span><span class="p">)),</span>
                        <span class="s1">&#39;channelSpins&#39;</span><span class="p">:</span> <span class="n">spins</span><span class="p">,</span>
                        <span class="p">}</span>
                <span class="n">Js</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">Jdict</span> <span class="p">)</span>

            <span class="n">Ldict</span> <span class="o">=</span> <span class="p">{</span> <span class="s1">&#39;L&#39;</span><span class="p">:</span> <span class="n">L</span><span class="p">,</span> <span class="s1">&#39;Js&#39;</span><span class="p">:</span> <span class="n">Js</span> <span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Ls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">Ldict</span> <span class="p">)</span>

        <span class="c1"># for each L, gfactors should sum to 2*L+1.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">missingGfactor</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ls</span><span class="p">:</span>
            <span class="n">gsum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span> <span class="p">[</span><span class="n">J</span><span class="p">[</span><span class="s1">&#39;gfact&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">J</span><span class="p">[</span><span class="s1">&#39;channelSpins&#39;</span><span class="p">])</span> <span class="k">for</span> <span class="n">J</span> <span class="ow">in</span> <span class="n">L</span><span class="p">[</span><span class="s1">&#39;Js&#39;</span><span class="p">]]</span> <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">missingGfactor</span><span class="p">[</span><span class="n">L</span><span class="p">[</span><span class="s1">&#39;L&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">L</span><span class="p">[</span><span class="s1">&#39;L&#39;</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span> <span class="o">-</span> <span class="n">gsum</span>

        <span class="c1"># for energy grid generation:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_energies</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span> <span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;energy&#39;</span><span class="p">)</span> <span class="p">]</span>
        <span class="n">totalWidths</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span> <span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;totalWidth&#39;</span><span class="p">)</span> <span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">totalWidths</span><span class="p">):</span> <span class="c1"># total widths aren&#39;t specified in Reich_Moore case</span>
            <span class="n">totalWidths</span> <span class="o">=</span> <span class="p">(</span> <span class="n">table</span><span class="p">[</span><span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;neutronWidth&#39;</span><span class="p">)]</span> <span class="o">+</span> <span class="n">table</span><span class="p">[</span><span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;captureWidth&#39;</span><span class="p">)]</span>
                    <span class="o">+</span> <span class="n">table</span><span class="p">[</span><span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;fissionWidth&#39;</span><span class="p">)]</span> <span class="o">+</span> <span class="n">table</span><span class="p">[</span><span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;fissionWidthB&#39;</span><span class="p">)]</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_widths</span> <span class="o">=</span> <span class="n">totalWidths</span></div>

<div class="viewcode-block" id="RRBaseClass.getAPByChannel"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.getAPByChannel">[docs]</a>    <span class="k">def</span> <span class="nf">getAPByChannel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">trueOrEffective</span><span class="o">=</span><span class="s1">&#39;true&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;get the channel radius, rho. If L is specified try to get L-dependent value&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">calculateChannelRadius</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="mf">0.123</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">targetMass_amu</span><span class="o">**</span><span class="p">(</span> <span class="mf">1.</span> <span class="o">/</span> <span class="mf">3.</span> <span class="p">)</span> <span class="o">+</span> <span class="mf">0.08</span>  <span class="c1"># eq. D.14 in ENDF manual, a in b^-1/2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">scatteringRadius</span><span class="o">.</span><span class="n">isEnergyDependent</span><span class="p">():</span>
                <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">scatteringRadius</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s1">&#39;10**-12*cm&#39;</span><span class="p">)</span>   <span class="c1"># a in b^-1/2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">scatteringRadius</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span> <span class="s1">&#39;10**-12*cm&#39;</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="n">c</span><span class="o">.</span><span class="n">l</span> <span class="p">)</span>   <span class="c1"># a in b^-1/2</span>
        <span class="k">return</span> <span class="n">a</span></div>

<div class="viewcode-block" id="RRBaseClass.rho"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.rho">[docs]</a>    <span class="k">def</span> <span class="nf">rho</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;get the channel radius, rho. If L is specified try to get L-dependent value&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">calculateChannelRadius</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="mf">0.123</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">targetMass_amu</span><span class="o">**</span><span class="p">(</span> <span class="mf">1.</span> <span class="o">/</span> <span class="mf">3.</span> <span class="p">)</span> <span class="o">+</span> <span class="mf">0.08</span>  <span class="c1"># eq. D.14 in ENDF manual, a in b^-1/2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">scatteringRadius</span><span class="o">.</span><span class="n">isEnergyDependent</span><span class="p">():</span>
                <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">scatteringRadius</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s1">&#39;10**-12*cm&#39;</span><span class="p">,</span> <span class="n">energyGrid</span><span class="o">=</span><span class="n">E</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>   <span class="c1"># a in b^-1/2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">scatteringRadius</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span> <span class="s1">&#39;10**-12*cm&#39;</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="n">L</span> <span class="p">)</span>   <span class="c1"># a in b^-1/2</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">*</span> <span class="n">a</span> <span class="c1"># dimensionless</span></div>

<div class="viewcode-block" id="RRBaseClass.generateEnergyGrid"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.generateEnergyGrid">[docs]</a>    <span class="k">def</span> <span class="nf">generateEnergyGrid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create an initial energy grid by merging a rough mesh for the entire region (~10 points / decade)</span>
<span class="sd">        with a denser grid around each resonance. For the denser grid, multiply the total resonance width by</span>
<span class="sd">        the &#39;resonancePos&#39; array defined below. &quot;&quot;&quot;</span>
        <span class="n">energies</span><span class="p">,</span> <span class="n">widths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_energies</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_widths</span>
        <span class="n">thresholds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_thresholds&#39;</span><span class="p">):</span>
            <span class="n">thresholds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_thresholds</span>
        <span class="n">lowBound</span><span class="p">,</span> <span class="n">highBound</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lowerBound</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">upperBound</span>
        <span class="c1"># ignore negative resonances</span>
        <span class="k">for</span> <span class="n">lidx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">energies</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">energies</span><span class="p">[</span><span class="n">lidx</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="k">break</span>
        <span class="n">energies</span> <span class="o">=</span> <span class="n">energies</span><span class="p">[</span><span class="n">lidx</span><span class="p">:]</span>
        <span class="n">widths</span> <span class="o">=</span> <span class="n">widths</span><span class="p">[</span><span class="n">lidx</span><span class="p">:]</span>
        <span class="c1"># generate grid for a single peak, should be good to 1% using linear interpolation:</span>
        <span class="n">resonancePos</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="mf">0.000e+00</span><span class="p">,</span> <span class="mf">1.000e-03</span><span class="p">,</span> <span class="mf">2.000e-03</span><span class="p">,</span> <span class="mf">3.000e-03</span><span class="p">,</span> <span class="mf">4.000e-03</span><span class="p">,</span> <span class="mf">5.000e-03</span><span class="p">,</span> <span class="mf">6.000e-03</span><span class="p">,</span> <span class="mf">7.000e-03</span><span class="p">,</span> <span class="mf">8.000e-03</span><span class="p">,</span> <span class="mf">9.000e-03</span><span class="p">,</span> <span class="mf">1.000e-02</span><span class="p">,</span> <span class="mf">2.000e-02</span><span class="p">,</span>
            <span class="mf">3.000e-02</span><span class="p">,</span> <span class="mf">4.000e-02</span><span class="p">,</span> <span class="mf">5.000e-02</span><span class="p">,</span> <span class="mf">6.000e-02</span><span class="p">,</span> <span class="mf">7.000e-02</span><span class="p">,</span> <span class="mf">8.000e-02</span><span class="p">,</span> <span class="mf">9.000e-02</span><span class="p">,</span> <span class="mf">1.000e-01</span><span class="p">,</span> <span class="mf">1.100e-01</span><span class="p">,</span> <span class="mf">1.200e-01</span><span class="p">,</span> <span class="mf">1.300e-01</span><span class="p">,</span> <span class="mf">1.400e-01</span><span class="p">,</span>
            <span class="mf">1.500e-01</span><span class="p">,</span> <span class="mf">1.600e-01</span><span class="p">,</span> <span class="mf">1.700e-01</span><span class="p">,</span> <span class="mf">1.800e-01</span><span class="p">,</span> <span class="mf">1.900e-01</span><span class="p">,</span> <span class="mf">2.000e-01</span><span class="p">,</span> <span class="mf">2.100e-01</span><span class="p">,</span> <span class="mf">2.200e-01</span><span class="p">,</span> <span class="mf">2.300e-01</span><span class="p">,</span> <span class="mf">2.400e-01</span><span class="p">,</span> <span class="mf">2.500e-01</span><span class="p">,</span> <span class="mf">2.600e-01</span><span class="p">,</span>
            <span class="mf">2.800e-01</span><span class="p">,</span> <span class="mf">3.000e-01</span><span class="p">,</span> <span class="mf">3.200e-01</span><span class="p">,</span> <span class="mf">3.400e-01</span><span class="p">,</span> <span class="mf">3.600e-01</span><span class="p">,</span> <span class="mf">3.800e-01</span><span class="p">,</span> <span class="mf">4.000e-01</span><span class="p">,</span> <span class="mf">4.200e-01</span><span class="p">,</span> <span class="mf">4.400e-01</span><span class="p">,</span> <span class="mf">4.600e-01</span><span class="p">,</span> <span class="mf">4.800e-01</span><span class="p">,</span> <span class="mf">5.000e-01</span><span class="p">,</span>
            <span class="mf">5.500e-01</span><span class="p">,</span> <span class="mf">6.000e-01</span><span class="p">,</span> <span class="mf">6.500e-01</span><span class="p">,</span> <span class="mf">7.000e-01</span><span class="p">,</span> <span class="mf">7.500e-01</span><span class="p">,</span> <span class="mf">8.000e-01</span><span class="p">,</span> <span class="mf">8.500e-01</span><span class="p">,</span> <span class="mf">9.000e-01</span><span class="p">,</span> <span class="mf">9.500e-01</span><span class="p">,</span> <span class="mf">1.000e+00</span><span class="p">,</span> <span class="mf">1.050e+00</span><span class="p">,</span> <span class="mf">1.100e+00</span><span class="p">,</span>
            <span class="mf">1.150e+00</span><span class="p">,</span> <span class="mf">1.200e+00</span><span class="p">,</span> <span class="mf">1.250e+00</span><span class="p">,</span> <span class="mf">1.300e+00</span><span class="p">,</span> <span class="mf">1.350e+00</span><span class="p">,</span> <span class="mf">1.400e+00</span><span class="p">,</span> <span class="mf">1.450e+00</span><span class="p">,</span> <span class="mf">1.500e+00</span><span class="p">,</span> <span class="mf">1.550e+00</span><span class="p">,</span> <span class="mf">1.600e+00</span><span class="p">,</span> <span class="mf">1.650e+00</span><span class="p">,</span> <span class="mf">1.700e+00</span><span class="p">,</span>
            <span class="mf">1.750e+00</span><span class="p">,</span> <span class="mf">1.800e+00</span><span class="p">,</span> <span class="mf">1.850e+00</span><span class="p">,</span> <span class="mf">1.900e+00</span><span class="p">,</span> <span class="mf">1.950e+00</span><span class="p">,</span> <span class="mf">2.000e+00</span><span class="p">,</span> <span class="mf">2.050e+00</span><span class="p">,</span> <span class="mf">2.100e+00</span><span class="p">,</span> <span class="mf">2.150e+00</span><span class="p">,</span> <span class="mf">2.200e+00</span><span class="p">,</span> <span class="mf">2.250e+00</span><span class="p">,</span> <span class="mf">2.300e+00</span><span class="p">,</span>
            <span class="mf">2.350e+00</span><span class="p">,</span> <span class="mf">2.400e+00</span><span class="p">,</span> <span class="mf">2.450e+00</span><span class="p">,</span> <span class="mf">2.500e+00</span><span class="p">,</span> <span class="mf">2.600e+00</span><span class="p">,</span> <span class="mf">2.700e+00</span><span class="p">,</span> <span class="mf">2.800e+00</span><span class="p">,</span> <span class="mf">2.900e+00</span><span class="p">,</span> <span class="mf">3.000e+00</span><span class="p">,</span> <span class="mf">3.100e+00</span><span class="p">,</span> <span class="mf">3.200e+00</span><span class="p">,</span> <span class="mf">3.300e+00</span><span class="p">,</span>
            <span class="mf">3.400e+00</span><span class="p">,</span> <span class="mf">3.600e+00</span><span class="p">,</span> <span class="mf">3.800e+00</span><span class="p">,</span> <span class="mf">4.000e+00</span><span class="p">,</span> <span class="mf">4.200e+00</span><span class="p">,</span> <span class="mf">4.400e+00</span><span class="p">,</span> <span class="mf">4.600e+00</span><span class="p">,</span> <span class="mf">4.800e+00</span><span class="p">,</span> <span class="mf">5.000e+00</span><span class="p">,</span> <span class="mf">5.200e+00</span><span class="p">,</span> <span class="mf">5.400e+00</span><span class="p">,</span> <span class="mf">5.600e+00</span><span class="p">,</span>
            <span class="mf">5.800e+00</span><span class="p">,</span> <span class="mf">6.000e+00</span><span class="p">,</span> <span class="mf">6.200e+00</span><span class="p">,</span> <span class="mf">6.400e+00</span><span class="p">,</span> <span class="mf">6.500e+00</span><span class="p">,</span> <span class="mf">6.800e+00</span><span class="p">,</span> <span class="mf">7.000e+00</span><span class="p">,</span> <span class="mf">7.500e+00</span><span class="p">,</span> <span class="mf">8.000e+00</span><span class="p">,</span> <span class="mf">8.500e+00</span><span class="p">,</span> <span class="mf">9.000e+00</span><span class="p">,</span> <span class="mf">9.500e+00</span><span class="p">,</span>
            <span class="mf">1.000e+01</span><span class="p">,</span> <span class="mf">1.050e+01</span><span class="p">,</span> <span class="mf">1.100e+01</span><span class="p">,</span> <span class="mf">1.150e+01</span><span class="p">,</span> <span class="mf">1.200e+01</span><span class="p">,</span> <span class="mf">1.250e+01</span><span class="p">,</span> <span class="mf">1.300e+01</span><span class="p">,</span> <span class="mf">1.350e+01</span><span class="p">,</span> <span class="mf">1.400e+01</span><span class="p">,</span> <span class="mf">1.450e+01</span><span class="p">,</span> <span class="mf">1.500e+01</span><span class="p">,</span> <span class="mf">1.550e+01</span><span class="p">,</span>
            <span class="mf">1.600e+01</span><span class="p">,</span> <span class="mf">1.700e+01</span><span class="p">,</span> <span class="mf">1.800e+01</span><span class="p">,</span> <span class="mf">1.900e+01</span><span class="p">,</span> <span class="mf">2.000e+01</span><span class="p">,</span> <span class="mf">2.100e+01</span><span class="p">,</span> <span class="mf">2.200e+01</span><span class="p">,</span> <span class="mf">2.300e+01</span><span class="p">,</span> <span class="mf">2.400e+01</span><span class="p">,</span> <span class="mf">2.500e+01</span><span class="p">,</span> <span class="mf">2.600e+01</span><span class="p">,</span> <span class="mf">2.700e+01</span><span class="p">,</span>
            <span class="mf">2.800e+01</span><span class="p">,</span> <span class="mf">2.900e+01</span><span class="p">,</span> <span class="mf">3.000e+01</span><span class="p">,</span> <span class="mf">3.100e+01</span><span class="p">,</span> <span class="mf">3.200e+01</span><span class="p">,</span> <span class="mf">3.300e+01</span><span class="p">,</span> <span class="mf">3.400e+01</span><span class="p">,</span> <span class="mf">3.600e+01</span><span class="p">,</span> <span class="mf">3.800e+01</span><span class="p">,</span> <span class="mf">4.000e+01</span><span class="p">,</span> <span class="mf">4.200e+01</span><span class="p">,</span> <span class="mf">4.400e+01</span><span class="p">,</span>
            <span class="mf">4.600e+01</span><span class="p">,</span> <span class="mf">4.800e+01</span><span class="p">,</span> <span class="mf">5.000e+01</span><span class="p">,</span> <span class="mf">5.300e+01</span><span class="p">,</span> <span class="mf">5.600e+01</span><span class="p">,</span> <span class="mf">5.900e+01</span><span class="p">,</span> <span class="mf">6.200e+01</span><span class="p">,</span> <span class="mf">6.600e+01</span><span class="p">,</span> <span class="mf">7.000e+01</span><span class="p">,</span> <span class="mf">7.400e+01</span><span class="p">,</span> <span class="mf">7.800e+01</span><span class="p">,</span> <span class="mf">8.200e+01</span><span class="p">,</span>
            <span class="mf">8.600e+01</span><span class="p">,</span> <span class="mf">9.000e+01</span><span class="p">,</span> <span class="mf">9.400e+01</span><span class="p">,</span> <span class="mf">9.800e+01</span><span class="p">,</span> <span class="mf">1.020e+02</span><span class="p">,</span> <span class="mf">1.060e+02</span><span class="p">,</span> <span class="mf">1.098e+02</span><span class="p">,</span> <span class="mf">1.140e+02</span><span class="p">,</span> <span class="mf">1.180e+02</span><span class="p">,</span> <span class="mf">1.232e+02</span><span class="p">,</span> <span class="mf">1.260e+02</span><span class="p">,</span> <span class="mf">1.300e+02</span><span class="p">,</span>
            <span class="mf">1.382e+02</span><span class="p">,</span> <span class="mf">1.550e+02</span><span class="p">,</span> <span class="mf">1.600e+02</span><span class="p">,</span> <span class="mf">1.739e+02</span><span class="p">,</span> <span class="mf">1.800e+02</span><span class="p">,</span> <span class="mf">1.951e+02</span><span class="p">,</span> <span class="mf">2.000e+02</span><span class="p">,</span> <span class="mf">2.100e+02</span><span class="p">,</span> <span class="mf">2.189e+02</span><span class="p">,</span> <span class="mf">2.300e+02</span><span class="p">,</span> <span class="mf">2.456e+02</span><span class="p">,</span> <span class="mf">2.500e+02</span><span class="p">,</span>
            <span class="mf">2.600e+02</span><span class="p">,</span> <span class="mf">2.756e+02</span><span class="p">,</span> <span class="mf">3.092e+02</span><span class="p">,</span> <span class="mf">3.200e+02</span><span class="p">,</span> <span class="mf">3.469e+02</span><span class="p">,</span> <span class="mf">3.600e+02</span><span class="p">,</span> <span class="mf">3.892e+02</span><span class="p">,</span> <span class="mf">4.000e+02</span><span class="p">,</span> <span class="mf">4.200e+02</span><span class="p">,</span> <span class="mf">4.367e+02</span><span class="p">,</span> <span class="mf">4.600e+02</span><span class="p">,</span> <span class="mf">4.800e+02</span><span class="p">,</span>
            <span class="mf">5.000e+02</span><span class="p">,</span> <span class="mf">6.000e+02</span><span class="p">,</span> <span class="mf">7.000e+02</span><span class="p">,</span> <span class="mf">8.000e+02</span><span class="p">,</span> <span class="mf">9.000e+02</span><span class="p">,</span> <span class="mf">1.000e+03</span> <span class="p">])</span>

        <span class="n">grid</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># get the midpoints (on log10 scale) between each resonance:</span>
        <span class="c1"># emid = [lowBound] + list(10**( ( numpy.log10(energies[1:])+numpy.log10(energies[:-1]) ) / 2.0)) + [highBound]</span>
        <span class="c1"># or get midpoints on linear scale:</span>
        <span class="n">emid</span> <span class="o">=</span> <span class="p">[</span><span class="n">lowBound</span><span class="p">]</span> <span class="o">+</span> <span class="p">[(</span><span class="n">e1</span><span class="o">+</span><span class="n">e2</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span> <span class="k">for</span> <span class="n">e1</span><span class="p">,</span><span class="n">e2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">energies</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span><span class="n">energies</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])]</span> <span class="o">+</span> <span class="p">[</span><span class="n">highBound</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">e</span><span class="p">,</span><span class="n">w</span><span class="p">,</span><span class="n">lowedge</span><span class="p">,</span><span class="n">highedge</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">energies</span><span class="p">,</span><span class="n">widths</span><span class="p">,</span><span class="n">emid</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">emid</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">e</span><span class="o">-</span><span class="n">w</span><span class="o">*</span><span class="n">resonancePos</span>
            <span class="n">grid</span> <span class="o">+=</span> <span class="p">[</span><span class="n">lowedge</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">points</span><span class="o">&gt;</span><span class="n">lowedge</span><span class="p">])</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">e</span><span class="o">+</span><span class="n">w</span><span class="o">*</span><span class="n">resonancePos</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">grid</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">points</span><span class="o">&lt;</span><span class="n">highedge</span><span class="p">])</span>
        <span class="c1"># also add rough grid, to cover any big gaps between resonances, should give at least 10 points per decade:</span>
        <span class="n">npoints</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">highBound</span><span class="p">)</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">lowBound</span><span class="p">)</span> <span class="p">)</span> <span class="o">*</span> <span class="mi">10</span>
        <span class="n">grid</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">lowBound</span><span class="p">),</span><span class="n">numpy</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">highBound</span><span class="p">),</span> <span class="n">npoints</span><span class="p">)</span> <span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">grid</span> <span class="o">+=</span> <span class="p">[</span><span class="n">lowBound</span><span class="p">,</span> <span class="n">highBound</span><span class="p">,</span> <span class="mf">0.0253</span><span class="p">]</span>   <span class="c1"># region boundaries + thermal</span>
        <span class="c1"># if threshold reactions present, add dense grid at and above threshold</span>
        <span class="k">for</span> <span class="n">threshold</span> <span class="ow">in</span> <span class="n">thresholds</span><span class="p">:</span>
            <span class="n">grid</span> <span class="o">+=</span> <span class="p">[</span><span class="n">threshold</span><span class="p">]</span>
            <span class="n">grid</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span> <span class="n">threshold</span> <span class="o">+</span> <span class="n">resonancePos</span> <span class="o">*</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">2</span> <span class="p">)</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">grid</span><span class="p">))</span>
        <span class="c1"># toss any points outside of energy bounds:</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span> <span class="n">grid</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">lowBound</span><span class="p">)</span> <span class="p">:</span> <span class="n">grid</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">highBound</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span> <span class="p">]</span>
        <span class="k">return</span> <span class="n">grid</span></div>

<div class="viewcode-block" id="RRBaseClass.setResonanceParametersByChannel"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.setResonanceParametersByChannel">[docs]</a>    <span class="k">def</span> <span class="nf">setResonanceParametersByChannel</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">multipleSScheme</span><span class="o">=</span><span class="s1">&#39;ENDF&#39;</span><span class="p">,</span> <span class="n">useReichMooreApproximation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">Ein</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">warnOnly</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reorganize member data into channels (relies heavily on groundwork in sortLandJ).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nResonances</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">resonanceParameters</span><span class="o">.</span><span class="n">table</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lMax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">LvaluesNeededForConvergence</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channelConstantsBc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">allowedSs</span> <span class="o">=</span> <span class="n">getAllowedTotalSpins</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">projectileSpin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">targetSpin</span><span class="p">,</span> <span class="n">useFactor2Trick</span><span class="o">=</span><span class="kc">False</span> <span class="p">)</span>
        <span class="n">warnings</span><span class="o">=</span><span class="p">[]</span>

        <span class="c1"># Make a unified table of resonance parameter data, convert to self.energyUnit if necessary</span>
        <span class="n">lList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;energy&#39;</span><span class="p">,</span><span class="s1">&#39;L&#39;</span><span class="p">,</span><span class="s1">&#39;J&#39;</span><span class="p">,</span><span class="s1">&#39;channelSpin&#39;</span><span class="p">,</span><span class="s1">&#39;totalWidth&#39;</span><span class="p">,</span><span class="s1">&#39;neutronWidth&#39;</span><span class="p">,</span><span class="s1">&#39;captureWidth&#39;</span><span class="p">,</span> <span class="s1">&#39;fissionWidth&#39;</span><span class="p">,</span><span class="s1">&#39;fissionWidthB&#39;</span><span class="p">)</span>
        <span class="n">EU</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span>
        <span class="n">units</span> <span class="o">=</span> <span class="p">(</span><span class="n">EU</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="n">EU</span><span class="p">,</span><span class="n">EU</span><span class="p">,</span><span class="n">EU</span><span class="p">,</span><span class="n">EU</span><span class="p">,</span><span class="n">EU</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">resonanceParameters</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">getColumn</span><span class="p">(</span> <span class="n">quant</span><span class="p">,</span><span class="n">unit</span> <span class="p">)</span> <span class="k">for</span> <span class="n">quant</span><span class="p">,</span><span class="n">unit</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">params</span><span class="p">,</span><span class="n">units</span><span class="p">)</span> <span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nResonances</span>

        <span class="k">def</span> <span class="nf">addOrUpdateDict</span><span class="p">(</span> <span class="n">theDict</span><span class="p">,</span> <span class="n">theKey</span><span class="p">,</span> <span class="n">theValue</span> <span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">theKey</span> <span class="ow">in</span> <span class="n">theDict</span><span class="p">:</span> <span class="n">theDict</span><span class="p">[</span> <span class="n">theKey</span> <span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">theDict</span><span class="p">[</span> <span class="n">theKey</span> <span class="p">][</span> <span class="n">theValue</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">]</span> <span class="o">=</span> <span class="n">theValue</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">particlePairs</span><span class="o">=</span><span class="p">{</span>
            <span class="s1">&#39;capture&#39;</span><span class="p">:(</span><span class="s1">&#39;gamma&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">getRootAncestor</span><span class="p">()</span><span class="o">.</span><span class="n">compound_nucleus</span><span class="p">),</span>
            <span class="s1">&#39;elastic&#39;</span><span class="p">:(</span><span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">getRootAncestor</span><span class="p">()</span><span class="o">.</span><span class="n">projectile</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">getRootAncestor</span><span class="p">()</span><span class="o">.</span><span class="n">target</span><span class="p">)}</span>
        <span class="n">pA102</span> <span class="o">=</span> <span class="n">particlePairs</span><span class="p">[</span><span class="s1">&#39;capture&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">pB102</span> <span class="o">=</span> <span class="n">particlePairs</span><span class="p">[</span><span class="s1">&#39;capture&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">pA2</span> <span class="o">=</span> <span class="n">particlePairs</span><span class="p">[</span><span class="s1">&#39;elastic&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">pB2</span> <span class="o">=</span> <span class="n">particlePairs</span><span class="p">[</span><span class="s1">&#39;elastic&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Now make the dictionary of channels</span>
        <span class="n">channelDict</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">iR</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">nResonances</span> <span class="p">):</span>
            <span class="n">ER</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">iR</span><span class="p">]</span>
            <span class="n">L</span> <span class="o">=</span>  <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">iR</span><span class="p">]</span>
            <span class="n">J</span> <span class="o">=</span>  <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">iR</span><span class="p">]</span>
            <span class="n">S</span> <span class="o">=</span>  <span class="kc">None</span> <span class="c1"># not given in MLBW, RM or RML, I just list it here for completeness</span>
            <span class="n">GT</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="n">iR</span><span class="p">]</span>
            <span class="n">GN</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="n">iR</span><span class="p">]</span>
            <span class="n">GG</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">6</span><span class="p">][</span><span class="n">iR</span><span class="p">]</span>
            <span class="n">GF</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">7</span><span class="p">][</span><span class="n">iR</span><span class="p">]</span>
            <span class="n">GX</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">8</span><span class="p">][</span><span class="n">iR</span><span class="p">]</span>
            <span class="n">JisAllowed</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lMax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">lMax</span><span class="p">,</span> <span class="n">L</span> <span class="p">)</span>
            <span class="k">if</span> <span class="n">L</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lList</span><span class="p">:</span> <span class="n">lList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
            <span class="n">allowedSByThisJl</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">SS</span> <span class="ow">in</span> <span class="n">allowedSs</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">)</span> <span class="ow">in</span> <span class="n">getAllowedTotalSpins</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="n">SS</span><span class="p">,</span> <span class="n">useFactor2Trick</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
                    <span class="n">JisAllowed</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">allowedSByThisJl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">SS</span> <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">JisAllowed</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">warnOnly</span><span class="p">:</span>
                    <span class="kn">from</span> <span class="nn">fudge.gnd</span> <span class="k">import</span> <span class="n">warning</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">warning</span><span class="o">.</span><span class="n">invalidAngularMomentaCombination</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;all channels&#39;</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span> <span class="s2">&quot;Invalid total angular momentum and/or orbital momentum: cannot couple up to J = &quot;</span>
                                      <span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">J</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; with I = &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targetSpin</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;, i = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">projectileSpin</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; and L = &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">L</span><span class="p">)</span> <span class="p">)</span>
            <span class="n">gfact</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">)</span><span class="o">+</span><span class="mf">1.</span><span class="p">)</span><span class="o">/</span><span class="p">((</span><span class="mf">2.</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">projectileSpin</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">targetSpin</span><span class="o">+</span><span class="mf">1.</span><span class="p">))</span>

            <span class="c1"># Way recommended by NJOY:</span>
            <span class="c1">#   * One of valid S&#39;s get width, other(s) get zero width</span>
            <span class="c1">#   * Zero width channels left in sum to get potential scattering correct</span>
            <span class="c1">#   * Gets good (cs from U) to (cs from Fudge) comparison; good (cs from U) to (cs from BB)</span>
            <span class="k">if</span> <span class="n">multipleSScheme</span> <span class="o">==</span> <span class="s1">&#39;NJOY&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">allowedSByThisJl</span><span class="p">:</span>
                    <span class="n">addOrUpdateDict</span><span class="p">(</span> <span class="n">channelDict</span><span class="p">,</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;elastic&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">allowedSByThisJl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">gfact</span><span class="p">,</span> <span class="n">pA2</span><span class="p">,</span> <span class="n">pB2</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">NEUTRONCHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span> <span class="p">),</span> <span class="p">(</span> <span class="n">iR</span><span class="p">,</span> <span class="n">GN</span> <span class="p">)</span> <span class="p">)</span>
                    <span class="n">addOrUpdateDict</span><span class="p">(</span> <span class="n">channelDict</span><span class="p">,</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;capture&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">allowedSByThisJl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">gfact</span><span class="p">,</span> <span class="n">pA102</span><span class="p">,</span> <span class="n">pB102</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">GAMMACHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">useReichMooreApproximation</span> <span class="p">),</span> <span class="p">(</span> <span class="n">iR</span><span class="p">,</span> <span class="n">GG</span> <span class="p">)</span> <span class="p">)</span>
                    <span class="k">if</span> <span class="n">GF</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span> <span class="n">addOrUpdateDict</span><span class="p">(</span> <span class="n">channelDict</span><span class="p">,</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;fission&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">allowedSByThisJl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">gfact</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">FISSIONCHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span> <span class="p">),</span> <span class="p">(</span> <span class="n">iR</span><span class="p">,</span> <span class="n">GF</span> <span class="p">)</span> <span class="p">)</span>
                    <span class="k">if</span> <span class="n">GX</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span> <span class="n">addOrUpdateDict</span><span class="p">(</span> <span class="n">channelDict</span><span class="p">,</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;competitive&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">allowedSByThisJl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">gfact</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">COMPETATIVECHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span> <span class="p">),</span> <span class="p">(</span> <span class="n">iR</span><span class="p">,</span> <span class="n">GX</span> <span class="p">)</span> <span class="p">)</span>
                    <span class="k">for</span> <span class="n">SS</span> <span class="ow">in</span> <span class="n">allowedSByThisJl</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                        <span class="n">addOrUpdateDict</span><span class="p">(</span> <span class="n">channelDict</span><span class="p">,</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;elastic&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SS</span><span class="p">,</span> <span class="n">gfact</span><span class="p">,</span> <span class="n">pA2</span><span class="p">,</span> <span class="n">pB2</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">NEUTRONCHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span> <span class="p">),</span> <span class="p">(</span> <span class="n">iR</span><span class="p">,</span> <span class="mf">0.0</span> <span class="p">)</span> <span class="p">)</span>
                        <span class="n">addOrUpdateDict</span><span class="p">(</span> <span class="n">channelDict</span><span class="p">,</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;capture&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SS</span><span class="p">,</span> <span class="n">gfact</span><span class="p">,</span> <span class="n">pA102</span><span class="p">,</span> <span class="n">pB102</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">GAMMACHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">useReichMooreApproximation</span> <span class="p">),</span> <span class="p">(</span> <span class="n">iR</span><span class="p">,</span> <span class="mf">0.0</span> <span class="p">)</span> <span class="p">)</span>
                        <span class="k">if</span> <span class="n">GF</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span> <span class="n">addOrUpdateDict</span><span class="p">(</span> <span class="n">channelDict</span><span class="p">,</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;fission&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SS</span><span class="p">,</span> <span class="n">gfact</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">FISSIONCHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span> <span class="p">),</span> <span class="p">(</span> <span class="n">iR</span><span class="p">,</span> <span class="mf">0.0</span> <span class="p">)</span> <span class="p">)</span>
                        <span class="k">if</span> <span class="n">GX</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span> <span class="n">addOrUpdateDict</span><span class="p">(</span> <span class="n">channelDict</span><span class="p">,</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;competitive&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SS</span><span class="p">,</span> <span class="n">gfact</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">COMPETATIVECHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span> <span class="p">),</span> <span class="p">(</span> <span class="n">iR</span><span class="p">,</span> <span class="mf">0.0</span> <span class="p">)</span> <span class="p">)</span>

            <span class="c1"># Way mandated by ENDF manual:</span>
            <span class="c1">#   * Width divided between channels with valid S&#39;s based on sign of J:</span>
            <span class="c1">#       ** if J&gt;0, S is max possible value</span>
            <span class="c1">#       ** if J&lt;0, S is min possible value</span>
            <span class="c1">#   * All channels left in sum to get potential scattering correct</span>
            <span class="c1">#   * Gets poor (cs from U) to (cs from Fudge) comparison; poor (cs from U) to (cs from BB)</span>
            <span class="k">elif</span> <span class="n">multipleSScheme</span> <span class="o">==</span> <span class="s1">&#39;ENDF&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">allowedSByThisJl</span><span class="p">:</span>
                    <span class="n">allowedSByThisJl</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">allowedSByThisJl</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="n">SS</span><span class="o">=</span><span class="n">allowedSByThisJl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span> <span class="n">SS</span><span class="o">=</span><span class="n">allowedSByThisJl</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">)</span><span class="o">==</span><span class="n">J</span><span class="p">)]</span>
                    <span class="n">addOrUpdateDict</span><span class="p">(</span> <span class="n">channelDict</span><span class="p">,</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;elastic&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SS</span><span class="p">,</span> <span class="n">gfact</span><span class="p">,</span> <span class="n">pA2</span><span class="p">,</span> <span class="n">pB2</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">NEUTRONCHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span> <span class="p">),</span> <span class="p">(</span> <span class="n">iR</span><span class="p">,</span> <span class="n">GN</span> <span class="p">)</span> <span class="p">)</span>
                    <span class="n">addOrUpdateDict</span><span class="p">(</span> <span class="n">channelDict</span><span class="p">,</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;capture&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SS</span><span class="p">,</span> <span class="n">gfact</span><span class="p">,</span> <span class="n">pA102</span><span class="p">,</span> <span class="n">pB102</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">GAMMACHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">useReichMooreApproximation</span> <span class="p">),</span> <span class="p">(</span> <span class="n">iR</span><span class="p">,</span> <span class="n">GG</span> <span class="p">)</span> <span class="p">)</span>
                    <span class="k">if</span> <span class="n">GF</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span> <span class="n">addOrUpdateDict</span><span class="p">(</span> <span class="n">channelDict</span><span class="p">,</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;fission&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SS</span><span class="p">,</span> <span class="n">gfact</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">FISSIONCHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span> <span class="p">),</span> <span class="p">(</span> <span class="n">iR</span><span class="p">,</span> <span class="n">GF</span> <span class="p">)</span> <span class="p">)</span>
                    <span class="k">if</span> <span class="n">GX</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span> <span class="n">addOrUpdateDict</span><span class="p">(</span> <span class="n">channelDict</span><span class="p">,</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;competitive&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SS</span><span class="p">,</span> <span class="n">gfact</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">COMPETATIVECHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span> <span class="p">),</span> <span class="p">(</span> <span class="n">iR</span><span class="p">,</span> <span class="n">GX</span> <span class="p">)</span> <span class="p">)</span>

            <span class="c1"># Ignore problem:</span>
            <span class="c1">#   * Ignore spin of channels and the fact may be multiple valid spins</span>
            <span class="c1">#   * Gets best (cs from U) to (cs from Fudge) comparison; poor (cs from U) to (cs from BB)</span>
            <span class="k">else</span> <span class="p">:</span>
                <span class="n">addOrUpdateDict</span><span class="p">(</span> <span class="n">channelDict</span><span class="p">,</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;elastic&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">gfact</span><span class="p">,</span> <span class="n">pA2</span><span class="p">,</span> <span class="n">pB2</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">NEUTRONCHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span> <span class="p">),</span> <span class="p">(</span> <span class="n">iR</span><span class="p">,</span> <span class="n">GN</span> <span class="p">)</span> <span class="p">)</span>
                <span class="n">addOrUpdateDict</span><span class="p">(</span> <span class="n">channelDict</span><span class="p">,</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;capture&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">gfact</span><span class="p">,</span> <span class="n">pA102</span><span class="p">,</span> <span class="n">pB102</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">GAMMACHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">useReichMooreApproximation</span> <span class="p">),</span> <span class="p">(</span> <span class="n">iR</span><span class="p">,</span> <span class="n">GG</span> <span class="p">)</span> <span class="p">)</span>
                <span class="k">if</span> <span class="n">GF</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span> <span class="n">addOrUpdateDict</span><span class="p">(</span> <span class="n">channelDict</span><span class="p">,</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;fission&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">gfact</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">FISSIONCHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span> <span class="p">),</span> <span class="p">(</span> <span class="n">iR</span><span class="p">,</span> <span class="n">GF</span> <span class="p">)</span> <span class="p">)</span>
                <span class="k">if</span> <span class="n">GX</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span> <span class="n">addOrUpdateDict</span><span class="p">(</span> <span class="n">channelDict</span><span class="p">,</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;competitive&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">gfact</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">COMPETATIVECHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span> <span class="p">),</span> <span class="p">(</span> <span class="n">iR</span><span class="p">,</span> <span class="n">GX</span> <span class="p">)</span> <span class="p">)</span>

        <span class="c1"># Take care of extra l&#39;s needed to get potential scattering correct</span>
        <span class="c1"># Make a single elastic channel with a zero width resonance at the energy of the first real resonance</span>
        <span class="c1"># This won&#39;t add to the resonance scattering part, but it will make a potential scattering part.</span>
        <span class="c1"># We add in channels for all spins and total angular momenta to make sure get the angular momentum algebra correct.</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lMax</span><span class="o">+</span><span class="mi">1</span> <span class="p">):</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">allowedSs</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">getAllowedTotalSpins</span><span class="p">(</span> <span class="n">l</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">useFactor2Trick</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
                    <span class="n">newChannel</span> <span class="o">=</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">l</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="s1">&#39;elastic&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">projectileSpin</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">targetSpin</span><span class="o">+</span><span class="mi">1</span><span class="p">)),</span> <span class="n">pA2</span><span class="p">,</span> <span class="n">pB2</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">NEUTRONCHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span> <span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">newChannel</span> <span class="ow">in</span> <span class="n">channelDict</span><span class="p">:</span> <span class="n">addOrUpdateDict</span><span class="p">(</span> <span class="n">channelDict</span><span class="p">,</span> <span class="n">newChannel</span><span class="p">,</span> <span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">)</span>

        <span class="c1"># Set up the channel-&gt;resonance mappings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allChannels</span> <span class="o">=</span> <span class="n">channelDict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>  <span class="c1"># just the kept ones</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eliminatedChannels</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">allChannels</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">eliminated</span><span class="p">:</span>    <span class="bp">self</span><span class="o">.</span><span class="n">eliminatedChannels</span><span class="p">[</span> <span class="n">c</span> <span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">allChannels</span><span class="p">[</span> <span class="n">c</span> <span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>               <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span> <span class="n">c</span> <span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">allChannels</span><span class="p">[</span> <span class="n">c</span> <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">identityMatrix</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span> <span class="p">)</span>

        <span class="k">if</span> <span class="n">warnOnly</span><span class="p">:</span> <span class="k">return</span> <span class="n">warnings</span></div>

<div class="viewcode-block" id="RRBaseClass.resetResonanceParametersByChannel"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.resetResonanceParametersByChannel">[docs]</a>    <span class="k">def</span> <span class="nf">resetResonanceParametersByChannel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">multipleSScheme</span><span class="o">=</span><span class="s1">&#39;ENDF&#39;</span><span class="p">,</span> <span class="n">useReichMooreApproximation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">Ein</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span> <span class="k">pass</span></div>

<div class="viewcode-block" id="RRBaseClass.penetrationFactorByChannel"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.penetrationFactorByChannel">[docs]</a>    <span class="k">def</span> <span class="nf">penetrationFactorByChannel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">Ein</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">channelClass</span> <span class="ow">in</span> <span class="p">[</span><span class="n">FISSIONCHANNEL</span><span class="p">,</span> <span class="n">GAMMACHANNEL</span><span class="p">]:</span> <span class="k">return</span> <span class="mf">1.0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactor</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span><span class="n">Ein</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">))</span></div>

<div class="viewcode-block" id="RRBaseClass.phiByChannel"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.phiByChannel">[docs]</a>    <span class="k">def</span> <span class="nf">phiByChannel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">Ein</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">channelClass</span> <span class="ow">in</span> <span class="p">[</span><span class="n">FISSIONCHANNEL</span><span class="p">,</span> <span class="n">GAMMACHANNEL</span><span class="p">]:</span> <span class="k">return</span> <span class="mf">0.0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">(</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span><span class="n">Ein</span><span class="p">,</span><span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">)</span> <span class="p">)</span></div>

<div class="viewcode-block" id="RRBaseClass.shiftFactorByChannel"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.shiftFactorByChannel">[docs]</a>    <span class="k">def</span> <span class="nf">shiftFactorByChannel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">Ein</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">channelClass</span> <span class="ow">in</span> <span class="p">[</span><span class="n">FISSIONCHANNEL</span><span class="p">,</span> <span class="n">GAMMACHANNEL</span><span class="p">]:</span> <span class="k">return</span> <span class="mf">0.0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shiftFactor</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span><span class="n">Ein</span><span class="p">,</span><span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">))</span></div>

<div class="viewcode-block" id="RRBaseClass.getChannelConstantsBc"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.getChannelConstantsBc">[docs]</a>    <span class="k">def</span> <span class="nf">getChannelConstantsBc</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span> <span class="s2">&quot;Override in derived classes if used&quot;</span> <span class="p">)</span></div>

<div class="viewcode-block" id="RRBaseClass.getRMatrix"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.getRMatrix">[docs]</a>    <span class="k">def</span> <span class="nf">getRMatrix</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">Ein</span> <span class="p">):</span> <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span> <span class="s2">&quot;Override in derived classes if used&quot;</span> <span class="p">)</span></div>

<div class="viewcode-block" id="RRBaseClass.getKMatrix"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.getKMatrix">[docs]</a>    <span class="k">def</span> <span class="nf">getKMatrix</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">Ein</span> <span class="p">):</span> <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span> <span class="s2">&quot;Override in derived classes if used&quot;</span> <span class="p">)</span></div>

<div class="viewcode-block" id="RRBaseClass.getAMatrix"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.getAMatrix">[docs]</a>    <span class="k">def</span> <span class="nf">getAMatrix</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">Ein</span> <span class="p">):</span> <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span> <span class="s2">&quot;Override in derived classes if used&quot;</span> <span class="p">)</span></div>

<div class="viewcode-block" id="RRBaseClass.getL0Matrix"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.getL0Matrix">[docs]</a>    <span class="k">def</span> <span class="nf">getL0Matrix</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">Ein</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the L0 matrix of Froehner:</span>

<span class="sd">            ..math::</span>
<span class="sd">                {\bf L^0}_{cc&#39;} = \delta_{cc&#39;} (L_c-B_c)</span>

<span class="sd">        where</span>

<span class="sd">            ..math::</span>
<span class="sd">                L_c = S_c + i P_c</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">channelConstantsBc</span> <span class="o">==</span> <span class="p">[]:</span> <span class="bp">self</span><span class="o">.</span><span class="n">channelConstantsBc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getChannelConstantsBc</span><span class="p">()</span>
        <span class="n">L0</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Ein</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">ic</span><span class="p">,</span><span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">):</span>
            <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span> <span class="n">Ein</span><span class="o">-</span><span class="n">c</span><span class="o">.</span><span class="n">Xi</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span> <span class="p">)</span>
            <span class="n">shift</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shiftFactor</span><span class="p">(</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="n">rho</span> <span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="n">penet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactor</span><span class="p">(</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="n">rho</span> <span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

            <span class="c1"># Note, you have to add the numpy.array&#39;s this way to make a complex number</span>
            <span class="c1"># because the numpy array trickery doesn&#39;t work with the complex() or</span>
            <span class="c1"># numpy.complex() constructors</span>
            <span class="n">L0</span><span class="p">[:,</span><span class="n">ic</span><span class="p">,</span><span class="n">ic</span><span class="p">]</span> <span class="o">=</span> <span class="n">shift</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span> <span class="n">penet</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">channelConstantsBc</span><span class="p">[</span> <span class="n">ic</span> <span class="p">]</span>
        <span class="k">return</span> <span class="n">L0</span></div>

<div class="viewcode-block" id="RRBaseClass.getXMatrix"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.getXMatrix">[docs]</a>    <span class="k">def</span> <span class="nf">getXMatrix</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">Ein</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the X matrix for use in computing W.  X is:</span>

<span class="sd">            ..math::</span>
<span class="sd">                {\bf X}_{cc&#39;} = P^{-1/2}_c ( ( {\bf I} - {\bf R}{\bf L^0} )^{-1}{\bf R} )_{cc&#39;} P_{c&#39;}^{-1/2}\delta_{JJ&#39;}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">L0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getL0Matrix</span><span class="p">(</span> <span class="n">Ein</span> <span class="p">)</span>
        <span class="n">penFact</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span> <span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ein</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span> <span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span> <span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ein</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span> <span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span> <span class="p">)</span>

        <span class="c1"># Precompute phase factor, sqrt(Penetrability)</span>
        <span class="k">for</span> <span class="n">ic</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="p">):</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">channelClass</span> <span class="ow">in</span> <span class="p">[</span><span class="n">NEUTRONCHANNEL</span><span class="p">,</span> <span class="n">CPCHANNEL</span><span class="p">]:</span> <span class="n">penFact</span><span class="p">[:,</span><span class="n">ic</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="n">L0</span><span class="p">[:,</span><span class="n">ic</span><span class="p">,</span><span class="n">ic</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span> <span class="p">)</span>

        <span class="c1"># Compute the (unscaled) X matrix</span>
        <span class="c1"># Hafta be real careful about combining numpy&#39;s broadcasting rules with numpy&#39;s linear algebra</span>
        <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getRMatrix</span><span class="p">(</span> <span class="n">Ein</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">iE</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Ein</span><span class="p">)):</span>
            <span class="n">thisR</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mat</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">iE</span><span class="p">])</span>
            <span class="n">thisL0</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mat</span><span class="p">(</span><span class="n">L0</span><span class="p">[</span><span class="n">iE</span><span class="p">])</span>
            <span class="n">X</span><span class="p">[</span><span class="n">iE</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">identityMatrix</span><span class="p">)</span> <span class="o">-</span> <span class="n">thisR</span> <span class="o">*</span> <span class="n">thisL0</span> <span class="p">)</span> <span class="o">*</span> <span class="n">thisR</span>

        <span class="c1"># Apply the sqrt(Penetrability) rescaling</span>
        <span class="k">for</span> <span class="n">ic1</span><span class="p">,</span> <span class="n">c1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="p">):</span>
            <span class="k">for</span> <span class="n">ic2</span><span class="p">,</span> <span class="n">c2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="p">):</span>
                <span class="k">if</span> <span class="n">c1</span><span class="o">.</span><span class="n">J</span> <span class="o">!=</span> <span class="n">c2</span><span class="o">.</span><span class="n">J</span><span class="p">:</span> <span class="k">continue</span>
                <span class="n">X</span><span class="p">[:,</span> <span class="n">ic1</span><span class="p">,</span> <span class="n">ic2</span><span class="p">]</span> <span class="o">*=</span> <span class="n">penFact</span><span class="p">[:,</span> <span class="n">ic1</span><span class="p">]</span> <span class="o">*</span> <span class="n">penFact</span><span class="p">[:,</span> <span class="n">ic2</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">X</span></div>

<div class="viewcode-block" id="RRBaseClass.getWMatrix"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.getWMatrix">[docs]</a>    <span class="k">def</span> <span class="nf">getWMatrix</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">Ein</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the W matrix for use in computing U.  W is:</span>

<span class="sd">            ..math::</span>
<span class="sd">                {\bf W} = {\bf I} + 2i{\bf X}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ein</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span> <span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span> <span class="p">)</span>
        <span class="n">W</span><span class="p">[</span> <span class="p">:,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span> <span class="p">)</span> <span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">W</span> <span class="o">+=</span> <span class="mf">2.0</span><span class="n">j</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">getXMatrix</span><span class="p">(</span> <span class="n">Ein</span> <span class="p">)</span>
        <span class="k">return</span> <span class="n">W</span></div>

<div class="viewcode-block" id="RRBaseClass.getEiPhis"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.getEiPhis">[docs]</a>    <span class="k">def</span> <span class="nf">getEiPhis</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">Ein</span><span class="p">,</span> <span class="n">useTabulatedScatteringRadius</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">enableExtraCoulombPhase</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The phase factor for the collision matrix:</span>

<span class="sd">            ..math::</span>
<span class="sd">                \Omega_c = e^{-\varphi_c}</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Precompute phase factor</span>
        <span class="n">eiphis</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ic</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="p">):</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">reaction</span> <span class="o">==</span> <span class="s1">&#39;elastic&#39;</span><span class="p">:</span>
                <span class="c1"># For calculating phi, default is to use tabulated scattering radius:</span>
                <span class="k">if</span> <span class="n">useTabulatedScatteringRadius</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">scatteringRadius</span><span class="o">.</span><span class="n">isEnergyDependent</span><span class="p">():</span>
                        <span class="n">rhohat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">scatteringRadius</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s1">&#39;10*fm&#39;</span><span class="p">,</span> <span class="n">Ein</span><span class="o">-</span><span class="n">c</span><span class="o">.</span><span class="n">Xi</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">(</span><span class="n">Ein</span><span class="o">-</span><span class="n">c</span><span class="o">.</span><span class="n">Xi</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">rhohat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">scatteringRadius</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s1">&#39;10*fm&#39;</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">(</span><span class="n">Ein</span><span class="o">-</span><span class="n">c</span><span class="o">.</span><span class="n">Xi</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span> <span class="n">rhohat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span><span class="n">Ein</span><span class="o">-</span><span class="n">c</span><span class="o">.</span><span class="n">Xi</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">)</span>
                <span class="n">phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">(</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="n">rhohat</span> <span class="p">)</span>
                <span class="n">eiphis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span> <span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phi</span> <span class="p">)</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">eiphis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span> <span class="n">Ein</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">return</span> <span class="n">eiphis</span></div>

<div class="viewcode-block" id="RRBaseClass.getScatteringMatrixU"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.getScatteringMatrixU">[docs]</a>    <span class="k">def</span> <span class="nf">getScatteringMatrixU</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">Ein</span><span class="p">,</span> <span class="n">useTabulatedScatteringRadius</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">enableExtraCoulombPhase</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the scattering matrix using</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make sure all channels are open at all requested energies</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">is_open</span><span class="p">(</span><span class="n">Ein</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">]):</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;One or more channels are not open on all energies in requested energy grid&quot;</span><span class="p">)</span>

        <span class="c1"># Initialize lists and matrices</span>
        <span class="n">eiphis</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">getEiPhis</span><span class="p">(</span> <span class="n">Ein</span><span class="p">,</span>
                                  <span class="n">useTabulatedScatteringRadius</span><span class="o">=</span><span class="n">useTabulatedScatteringRadius</span><span class="p">,</span>
                                  <span class="n">enableExtraCoulombPhase</span><span class="o">=</span><span class="n">enableExtraCoulombPhase</span> <span class="p">)</span>
        <span class="n">W</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getWMatrix</span><span class="p">(</span> <span class="n">Ein</span> <span class="p">)</span>

        <span class="c1"># This adds in the phase factors to get us U</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ein</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span> <span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">ic1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span> <span class="p">):</span>
            <span class="k">for</span> <span class="n">ic2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span> <span class="p">):</span>
                <span class="n">U</span><span class="p">[:,</span> <span class="n">ic1</span><span class="p">,</span> <span class="n">ic2</span> <span class="p">]</span> <span class="o">=</span> <span class="n">W</span><span class="p">[:,</span> <span class="n">ic1</span><span class="p">,</span> <span class="n">ic2</span> <span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">eiphis</span><span class="p">[</span><span class="n">ic1</span><span class="p">][:]</span> <span class="o">*</span> <span class="n">eiphis</span><span class="p">[</span><span class="n">ic2</span><span class="p">][:])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">U</span></div>

<div class="viewcode-block" id="RRBaseClass.getScatteringMatrixT"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.getScatteringMatrixT">[docs]</a>    <span class="k">def</span> <span class="nf">getScatteringMatrixT</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">Ein</span><span class="p">,</span> <span class="n">useTabulatedScatteringRadius</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">enableExtraCoulombPhase</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
        <span class="c1"># Make sure all channels are open at all requested energies</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">is_open</span><span class="p">(</span><span class="n">Ein</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">]):</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;One or more channels are not open on all energies in requested energy grid&quot;</span><span class="p">)</span>

        <span class="n">T</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ein</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span> <span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span> <span class="p">)</span>
        <span class="n">U</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getScatteringMatrixU</span><span class="p">(</span> <span class="n">Ein</span><span class="p">,</span>
                                       <span class="n">useTabulatedScatteringRadius</span><span class="o">=</span><span class="n">useTabulatedScatteringRadius</span><span class="p">,</span>
                                       <span class="n">enableExtraCoulombPhase</span><span class="o">=</span><span class="n">enableExtraCoulombPhase</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">ic1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span> <span class="p">):</span>
            <span class="k">for</span> <span class="n">ic2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span> <span class="p">):</span>
                <span class="n">T</span><span class="p">[:,</span> <span class="n">ic1</span><span class="p">,</span> <span class="n">ic2</span> <span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ic1</span><span class="o">==</span><span class="n">ic2</span><span class="p">)</span> <span class="o">-</span> <span class="n">U</span><span class="p">[:,</span> <span class="n">ic1</span><span class="p">,</span> <span class="n">ic2</span> <span class="p">]</span>
        <span class="k">return</span> <span class="n">T</span></div>

<div class="viewcode-block" id="RRBaseClass.getLMax"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.getLMax">[docs]</a>    <span class="k">def</span> <span class="nf">getLMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">maxLmax</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        LMax is determined by the behavior of the Blatt-Biedenharn Zbar coefficients.  Inside each one, there is</span>
<span class="sd">        a Racah coefficient and a Clebsh-Gordon coefficient.  The CG coefficient looks like this:</span>
<span class="sd">                ( l1 l2  L )</span>
<span class="sd">                (  0  0  0 )</span>
<span class="sd">        So, this means two things.  First, the CG coeff (and hence Zbar) will be zero if l1+l2+L=odd.</span>
<span class="sd">        Second, the maximum value of L will be l1max+l2max.  Hence, Lmax=2*lmax.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span> <span class="nb">max</span><span class="p">(</span> <span class="p">[</span> <span class="mi">2</span><span class="o">*</span><span class="n">xL</span><span class="p">[</span><span class="s1">&#39;L&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">xL</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ls</span> <span class="p">]</span> <span class="p">),</span> <span class="n">maxLmax</span> <span class="p">)</span></div>

<div class="viewcode-block" id="RRBaseClass.getParticleSpins"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.getParticleSpins">[docs]</a>    <span class="k">def</span> <span class="nf">getParticleSpins</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">rxn</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">rxn</span><span class="o">==</span><span class="s1">&#39;elastic&#39;</span><span class="p">:</span> <span class="c1"># easy peasy lemon-squeezy</span>
            <span class="n">spinA</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">projectileSpin</span>                          <span class="c1"># For neutron as a projectile, projSpin is 1/2</span>
            <span class="n">spinB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">targetSpin</span>                              <span class="c1"># Target spin from baseclass</span>

        <span class="k">elif</span> <span class="n">rxn</span><span class="o">==</span><span class="s1">&#39;capture&#39;</span><span class="p">:</span> <span class="c1"># easy peasy lemon-squeezy</span>
            <span class="n">spinA</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">projectileSpin</span><span class="o">+</span><span class="mf">0.5</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">projectileSpin</span><span class="o">-</span><span class="mf">0.5</span><span class="p">))</span>
            <span class="n">spinB</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targetSpin</span><span class="o">+</span><span class="mf">0.5</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targetSpin</span><span class="o">-</span><span class="mf">0.5</span><span class="p">))</span>

        <span class="k">elif</span> <span class="s1">&#39; + &#39;</span> <span class="ow">in</span> <span class="n">rxn</span><span class="p">:</span> <span class="c1"># gotta search</span>
            <span class="n">spinA</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">spinB</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">pa</span><span class="p">,</span><span class="n">pb</span><span class="o">=</span><span class="n">rxn</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; + &#39;</span><span class="p">)</span>
            <span class="k">def</span> <span class="nf">get_spin_as_float</span><span class="p">(</span><span class="n">_p</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">_p</span><span class="p">,</span><span class="s1">&#39;nucleus&#39;</span><span class="p">):</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">_p</span><span class="o">.</span><span class="n">nucleus</span><span class="o">.</span><span class="n">spin</span><span class="o">.</span><span class="n">float</span><span class="p">(</span><span class="s1">&#39;hbar&#39;</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span> <span class="n">err</span><span class="o">.</span><span class="n">message</span><span class="o">+</span><span class="s1">&#39; for particle &#39;</span><span class="o">+</span><span class="n">_p</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="n">_p</span><span class="o">.</span><span class="n">spin</span><span class="o">.</span><span class="n">float</span><span class="p">(</span><span class="s1">&#39;hbar&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pa</span> <span class="o">==</span> <span class="s1">&#39;photon&#39;</span><span class="p">:</span>
                <span class="n">spinB</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targetSpin</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targetSpin</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">pb</span> <span class="o">==</span> <span class="s1">&#39;photon&#39;</span><span class="p">:</span>
                <span class="n">spinA</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targetSpin</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targetSpin</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">getRootAncestor</span><span class="p">()</span><span class="o">.</span><span class="n">PoPs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">pa</span><span class="o">==</span><span class="n">p</span><span class="o">.</span><span class="n">id</span><span class="p">:</span> <span class="n">spinA</span><span class="o">=</span><span class="n">get_spin_as_float</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">pb</span><span class="o">==</span><span class="n">p</span><span class="o">.</span><span class="n">id</span><span class="p">:</span> <span class="n">spinB</span><span class="o">=</span><span class="n">get_spin_as_float</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

        <span class="k">elif</span> <span class="s2">&quot;competitive&quot;</span> <span class="ow">in</span> <span class="n">rxn</span><span class="p">:</span>
            <span class="n">spinA</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">projectileSpin</span>     <span class="c1"># doesn&#39;t matter anyway</span>
            <span class="n">spinB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">targetSpin</span>

        <span class="k">else</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot determine spins for reactants in reaction &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span><span class="o">%</span><span class="n">rxn</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">spinA</span><span class="p">,</span> <span class="n">spinB</span></div>

    <span class="nd">@blockwise</span>
<div class="viewcode-block" id="RRBaseClass.getAngularDistribution"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.getAngularDistribution">[docs]</a>    <span class="k">def</span> <span class="nf">getAngularDistribution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">keepL0Term</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">renormalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">outChannelNames</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="n">useTabulatedScatteringRadius</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">enableExtraCoulombPhase</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param numpy.array(type=float) E:</span>
<span class="sd">        :param bool keepL0Term:</span>
<span class="sd">        :param bool renormalize:</span>
<span class="sd">        :param str reactionp:</span>
<span class="sd">        :param bool useTabulatedScatteringRadius:</span>
<span class="sd">        :param bool enableExtraCoulombPhase:</span>
<span class="sd">        :return:</span>
<span class="sd">        :rtype: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">numericalFunctions</span> <span class="k">import</span> <span class="n">angularMomentumCoupling</span> <span class="k">as</span> <span class="n">nf_amc</span>

        <span class="c1"># Make sure the incident energies are in the correct form for vectorization</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">]:</span> <span class="n">E</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">E</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="n">E</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">E</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">),</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Make sure all channels are open at all requested energies</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resetResonanceParametersByChannel</span><span class="p">(</span> <span class="n">Ein</span><span class="o">=</span><span class="n">E</span> <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">is_open</span><span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">]):</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;One or more channels are not open on all energies in requested energy grid&quot;</span><span class="p">)</span>

        <span class="c1"># Get the names of the input channel and all output channels to consider</span>
        <span class="n">channelNames</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">reaction</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">])</span>
        <span class="n">inChannelName</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> + </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">projectile</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inChannelName</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">channelNames</span><span class="p">:</span>   <span class="c1"># FIXME change MLBW and R-M to label channels by particle pairs like LRF=7</span>
            <span class="k">if</span> <span class="s1">&#39;elastic&#39;</span> <span class="ow">in</span> <span class="n">channelNames</span><span class="p">:</span>
                <span class="n">inChannelName</span> <span class="o">=</span> <span class="s1">&#39;elastic&#39;</span>
        <span class="k">if</span> <span class="n">outChannelNames</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">outChannelNames</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">chan</span><span class="o">.</span><span class="n">reaction</span> <span class="k">for</span> <span class="n">chan</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">chan</span><span class="o">.</span><span class="n">eliminated</span> <span class="ow">and</span> <span class="n">chan</span><span class="o">.</span><span class="n">reaction</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;capture&#39;</span><span class="p">,</span><span class="s1">&#39;fission&#39;</span><span class="p">,</span><span class="s1">&#39;fissionA&#39;</span><span class="p">,</span><span class="s1">&#39;fissionB&#39;</span><span class="p">,</span><span class="s1">&#39;competitive&#39;</span><span class="p">]])</span>

        <span class="c1"># Set up variables, first the easy ones</span>
        <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>                                           <span class="c1"># Relative momentum, comes out in b^-1/2</span>
        <span class="n">B</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:[]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">outChannelNames</span><span class="p">}</span>                 <span class="c1"># List of Blatt-Biedenharn coefficients, used in Legendre series expansion of the angular distribution</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:[]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">outChannelNames</span><span class="p">}</span>
        <span class="n">relTol</span> <span class="o">=</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">8</span>                                           <span class="c1"># Relative tolerance used to decide when to cut off Legendre series</span>
        <span class="n">Lmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getLMax</span><span class="p">(</span> <span class="p">)</span>                                  <span class="c1"># Lmax also used to decide when to cut off Legendre series</span>

        <span class="c1"># Now, the T matrix, the most important variable of all...</span>
        <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getScatteringMatrixT</span><span class="p">(</span> <span class="n">E</span><span class="p">,</span>                       <span class="c1"># The scattering matrix</span>
                                       <span class="n">useTabulatedScatteringRadius</span><span class="o">=</span><span class="n">useTabulatedScatteringRadius</span><span class="p">,</span>
                                       <span class="n">enableExtraCoulombPhase</span><span class="o">=</span><span class="n">enableExtraCoulombPhase</span> <span class="p">)</span>

        <span class="c1"># The in channel stuff...</span>
        <span class="n">projSpin</span><span class="p">,</span> <span class="n">targSpin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getParticleSpins</span><span class="p">(</span><span class="n">inChannelName</span><span class="p">)</span>
        <span class="n">prefactor</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">k</span><span class="o">/</span><span class="n">k</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">projSpin</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">targSpin</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>       <span class="c1"># Prefactor for cross section, gets units, main energy dependence, and spin dep. prefactor</span>
        <span class="n">allowedSpins</span> <span class="o">=</span> <span class="n">getAllowedTotalSpins</span><span class="p">(</span> <span class="n">targSpin</span><span class="p">,</span>          <span class="c1"># Possible values of the total channel spin, based on the projectile spin (projSpin) and target spin (targSpin)</span>
                                             <span class="n">projSpin</span><span class="p">,</span>
                                             <span class="kc">False</span> <span class="p">)</span>
        <span class="n">incidentChannels</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">chan</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">chan</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">)</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">chan</span><span class="o">.</span><span class="n">eliminated</span> <span class="ow">and</span> <span class="n">chan</span><span class="o">.</span><span class="n">reaction</span> <span class="o">==</span> <span class="n">inChannelName</span><span class="p">]</span>

        <span class="c1"># Loop over out channels</span>
        <span class="k">for</span> <span class="n">reactionp</span> <span class="ow">in</span> <span class="n">outChannelNames</span><span class="p">:</span>
            <span class="n">ejectSpin</span><span class="p">,</span> <span class="n">resSpin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getParticleSpins</span><span class="p">(</span><span class="n">reactionp</span><span class="p">)</span>
            <span class="n">allowedSpinsp</span> <span class="o">=</span> <span class="n">getAllowedTotalSpins</span><span class="p">(</span> <span class="n">resSpin</span><span class="p">,</span>          <span class="c1"># Possible values of the total channel spin, based on the ejectile spin (ejectSpin) and residual nucleus spin (resSpin)</span>
                                                  <span class="n">ejectSpin</span><span class="p">,</span>
                                                  <span class="kc">False</span> <span class="p">)</span>
            <span class="n">outgoingChannels</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">chan</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">chan</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">)</span>
                                <span class="k">if</span> <span class="ow">not</span> <span class="n">chan</span><span class="o">.</span><span class="n">eliminated</span> <span class="ow">and</span> <span class="n">chan</span><span class="o">.</span><span class="n">reaction</span> <span class="o">==</span> <span class="n">reactionp</span><span class="p">]</span>

            <span class="c1"># Main algorithm</span>
            <span class="c1"># Some words on the looping over L here.  There are 3 reasons to keep looping:</span>
            <span class="c1">#   1. We have less than 3 Legendre moments (L=0,1,2).  At threshold we have L=0 only, but otherwise had better have more.</span>
            <span class="c1">#   2. If we hit LMax or all the biggest L moments are too small, then stop, otherwise keep going</span>
            <span class="c1">#   3. We end on an odd L index.  That means Lmax must be even because LMax = last L-1</span>
            <span class="c1"># By the way, we must have an even LMax.  See the getLMax() documentation for reasoning.</span>
            <span class="n">L</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="n">reactionp</span><span class="p">])</span><span class="o">&lt;=</span><span class="mi">3</span> <span class="ow">or</span> <span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="n">reactionp</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">&gt;=</span><span class="n">relTol</span><span class="o">*</span><span class="n">B</span><span class="p">[</span><span class="n">reactionp</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span> <span class="ow">and</span> <span class="n">L</span><span class="o">&lt;=</span><span class="n">Lmax</span> <span class="p">)</span> <span class="ow">or</span> <span class="n">L</span><span class="o">%</span><span class="mi">2</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">B</span><span class="p">[</span><span class="n">reactionp</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">E</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">S</span> <span class="ow">in</span> <span class="n">allowedSpins</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">Sp</span> <span class="ow">in</span> <span class="n">allowedSpinsp</span><span class="p">:</span>
                        <span class="n">spinFactor</span> <span class="o">=</span>  <span class="nb">pow</span><span class="p">(</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">S</span> <span class="o">-</span> <span class="n">Sp</span> <span class="p">)</span> <span class="o">/</span> <span class="mf">4.0</span>
                        <span class="k">for</span> <span class="n">i1</span><span class="p">,</span> <span class="n">c1</span> <span class="ow">in</span> <span class="n">incidentChannels</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">c1</span><span class="o">.</span><span class="n">s</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">spins_equal</span><span class="p">(</span><span class="n">c1</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">S</span><span class="p">):</span> <span class="k">continue</span> <span class="c1"># c1.s != S: continue</span>
                            <span class="k">for</span> <span class="n">i2</span><span class="p">,</span> <span class="n">c2</span> <span class="ow">in</span> <span class="n">incidentChannels</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">c2</span><span class="o">.</span><span class="n">s</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">spins_equal</span><span class="p">(</span><span class="n">c2</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">S</span><span class="p">):</span> <span class="k">continue</span> <span class="c1"># c2.s != S: continue</span>
                                <span class="n">Z</span> <span class="o">=</span> <span class="n">nf_amc</span><span class="o">.</span><span class="n">zbar_coefficient</span><span class="p">(</span> <span class="nb">int</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">c1</span><span class="o">.</span><span class="n">l</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">c1</span><span class="o">.</span><span class="n">J</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">c2</span><span class="o">.</span><span class="n">l</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">c2</span><span class="o">.</span><span class="n">J</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">S</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">L</span><span class="p">)</span> <span class="p">)</span>
                                <span class="k">if</span> <span class="n">Z</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span> <span class="k">continue</span>
                                <span class="k">for</span> <span class="n">i1p</span><span class="p">,</span> <span class="n">c1p</span> <span class="ow">in</span> <span class="n">outgoingChannels</span><span class="p">:</span>
                                    <span class="k">if</span> <span class="n">c1</span><span class="o">.</span><span class="n">J</span> <span class="o">!=</span> <span class="n">c1p</span><span class="o">.</span><span class="n">J</span><span class="p">:</span> <span class="k">continue</span>
                                    <span class="k">if</span> <span class="n">c1p</span><span class="o">.</span><span class="n">s</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">spins_equal</span><span class="p">(</span><span class="n">c1p</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">Sp</span><span class="p">):</span> <span class="k">continue</span> <span class="c1"># c1p.s != Sp: continue</span>
                                    <span class="k">for</span> <span class="n">i2p</span><span class="p">,</span> <span class="n">c2p</span> <span class="ow">in</span> <span class="n">outgoingChannels</span><span class="p">:</span>
                                        <span class="k">if</span> <span class="n">c2</span><span class="o">.</span><span class="n">J</span> <span class="o">!=</span> <span class="n">c2p</span><span class="o">.</span><span class="n">J</span><span class="p">:</span> <span class="k">continue</span>
                                        <span class="k">if</span> <span class="n">c2p</span><span class="o">.</span><span class="n">s</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">spins_equal</span><span class="p">(</span><span class="n">c2p</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">Sp</span><span class="p">):</span> <span class="k">continue</span> <span class="c1"># c2p.s != Sp: continue</span>
                                        <span class="n">Zp</span> <span class="o">=</span> <span class="n">nf_amc</span><span class="o">.</span><span class="n">zbar_coefficient</span><span class="p">(</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">c1p</span><span class="o">.</span><span class="n">l</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">c1p</span><span class="o">.</span><span class="n">J</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">c2p</span><span class="o">.</span><span class="n">l</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">c2p</span><span class="o">.</span><span class="n">J</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Sp</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">L</span><span class="p">)</span> <span class="p">)</span>
                                        <span class="k">if</span> <span class="n">Zp</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span> <span class="k">continue</span>
                                        <span class="n">thisB</span> <span class="o">=</span> <span class="n">spinFactor</span> <span class="o">*</span> <span class="n">Z</span> <span class="o">*</span> <span class="n">Zp</span> <span class="o">*</span> <span class="p">(</span> <span class="n">T</span><span class="p">[:,</span><span class="n">i1</span><span class="p">,</span><span class="n">i1p</span><span class="p">]</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span> <span class="o">*</span> <span class="n">T</span><span class="p">[:,</span><span class="n">i2</span><span class="p">,</span><span class="n">i2p</span><span class="p">]</span> <span class="p">)</span><span class="o">.</span><span class="n">real</span>
                                        <span class="n">B</span><span class="p">[</span><span class="n">reactionp</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">thisB</span><span class="p">[:,</span><span class="n">numpy</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
                <span class="n">L</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">for</span> <span class="n">l</span><span class="p">,</span><span class="n">coefs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span> <span class="n">B</span><span class="p">[</span><span class="n">reactionp</span><span class="p">]</span> <span class="p">):</span>
                <span class="n">results</span><span class="p">[</span><span class="n">reactionp</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">prefactor</span> <span class="o">/</span> <span class="p">(</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">l</span><span class="o">+</span><span class="mf">1.0</span> <span class="p">)</span> <span class="o">*</span> <span class="n">coefs</span> <span class="p">)</span>
            <span class="k">if</span> <span class="n">renormalize</span><span class="p">:</span>
                <span class="n">L0term</span><span class="o">=</span><span class="n">results</span><span class="p">[</span><span class="n">reactionp</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">L0term</span><span class="o">&lt;</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">16</span><span class="p">):</span> <span class="n">L0term</span><span class="p">[</span><span class="n">L0term</span><span class="o">&lt;</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">16</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">16</span> <span class="c1">#takes care of questionable behavior near threshold</span>
                <span class="n">results</span><span class="p">[</span><span class="n">reactionp</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span> <span class="n">x</span><span class="o">/</span><span class="n">L0term</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">results</span><span class="p">[</span><span class="n">reactionp</span><span class="p">]</span> <span class="p">]</span>

        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="RRBaseClass.getBackgroundRMatrix"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.getBackgroundRMatrix">[docs]</a>    <span class="k">def</span> <span class="nf">getBackgroundRMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Ein</span><span class="p">,</span> <span class="n">Emin</span><span class="p">,</span> <span class="n">Emax</span><span class="p">,</span> <span class="n">gamWidth</span><span class="p">,</span> <span class="n">pole_strength</span><span class="p">,</span> <span class="n">Rinf</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Froehner&#39;s background R matrix.  This could be vectorized for speed.  Not sure if it would be useful though.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Rbackground</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ein</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span> <span class="p">)</span>
        <span class="n">I</span> <span class="o">=</span> <span class="p">(</span><span class="n">Emax</span><span class="o">-</span><span class="n">Emin</span><span class="p">)</span>
        <span class="n">Eave</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">Emax</span><span class="o">+</span><span class="n">Emin</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">iEE</span><span class="p">,</span><span class="n">EE</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">Ein</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">EE</span> <span class="o">&lt;</span> <span class="n">Emin</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Ein=&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">EE</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; is below Emin=&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">Emin</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">EE</span> <span class="o">&gt;</span> <span class="n">Emax</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Ein=&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">EE</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; is above Emax=&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">Emax</span><span class="p">))</span>
            <span class="n">dE</span><span class="o">=</span><span class="n">EE</span><span class="o">-</span><span class="n">Eave</span>
            <span class="n">A</span> <span class="o">=</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">dE</span><span class="o">/</span><span class="n">I</span>
            <span class="n">B</span> <span class="o">=</span> <span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">I</span><span class="o">/</span><span class="mf">4.0</span><span class="o">-</span><span class="n">dE</span><span class="o">*</span><span class="n">dE</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">B</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">Rbackground</span><span class="p">[</span><span class="n">iEE</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="n">j</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">Rinf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">Rbackground</span><span class="p">[</span><span class="n">iEE</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="mf">2.0</span><span class="o">*</span><span class="n">pole_strength</span><span class="o">*</span><span class="nb">complex</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arctanh</span><span class="p">(</span><span class="n">A</span><span class="p">),</span> <span class="n">gamWidth</span><span class="o">*</span><span class="n">I</span><span class="o">/</span><span class="mf">4.0</span><span class="o">/</span><span class="n">B</span><span class="p">)</span><span class="o">+</span><span class="n">Rinf</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Rbackground</span><span class="p">[</span><span class="n">iEE</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="mf">2.0</span><span class="o">*</span><span class="n">pole_strength</span><span class="o">*</span><span class="nb">complex</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arctanh</span><span class="p">(</span><span class="n">A</span><span class="p">),</span> <span class="n">gamWidth</span><span class="o">*</span><span class="n">I</span><span class="o">/</span><span class="mf">4.0</span><span class="o">/</span><span class="n">B</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Rbackground</span></div>

<div class="viewcode-block" id="RRBaseClass.getAverageQuantities"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.getAverageQuantities">[docs]</a>    <span class="k">def</span> <span class="nf">getAverageQuantities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">resonancesPerBin</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="n">computeUncertainty</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes average widths and level spacings from the set of resonance parameters in self, on a per-channel basis</span>

<span class="sd">        The averages are computed in equal lethargy bins starting at the lowest resonance energy in a sequence up to the</span>
<span class="sd">        upperBound of the resonance region.  I tried to keep on average 10 resonances/logrithmic bin so I can get a</span>
<span class="sd">        reasonable average.</span>

<span class="sd">        :param resonancesPerBin: the number of resonances per logrithmic bin to aim for, on average</span>
<span class="sd">        :param computeUncertainty: toggle the calculation of the uncertainty of the quantities</span>
<span class="sd">        :return: a dictionary of results, sorted by channel</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">mean</span><span class="p">,</span><span class="n">var</span>
        <span class="kn">import</span> <span class="nn">pqu.PQU</span>
        <span class="n">results</span><span class="o">=</span><span class="p">{}</span>
        <span class="n">binScheme</span><span class="o">=</span><span class="s1">&#39;chunks&#39;</span> <span class="c1"># linspacing or logspacing</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span><span class="n">c</span><span class="p">])</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">results</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;energyGrid&#39;</span><span class="p">:[],</span><span class="s1">&#39;widths&#39;</span><span class="p">:[],</span><span class="s1">&#39;spacings&#39;</span><span class="p">:[]}</span>
                <span class="k">continue</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ERmin</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span> <span class="p">[</span> <span class="n">xx</span> <span class="k">for</span> <span class="n">xx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="n">xx</span><span class="o">&gt;</span><span class="mi">0</span> <span class="p">]</span> <span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span> <span class="n">ERmin</span><span class="o">=</span><span class="mf">1.0</span>

            <span class="n">res</span><span class="o">=</span><span class="p">[]</span>
            <span class="k">for</span> <span class="n">iR</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span><span class="n">c</span><span class="p">]:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_energies</span><span class="p">[</span><span class="n">iR</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="n">iR</span><span class="p">]))</span>
            <span class="n">res</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="n">resonancesPerBin</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">resonancesPerBin</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">resonancesPerBin</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="k">continue</span>

            <span class="k">if</span> <span class="n">binScheme</span><span class="o">==</span><span class="s1">&#39;logspacing&#39;</span><span class="p">:</span>
                <span class="n">bins</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span>
                    <span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">lowerBound</span><span class="p">,</span> <span class="mf">25.85e-3</span><span class="p">,</span> <span class="n">ERmin</span> <span class="p">)),</span>
                    <span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">upperBound</span><span class="p">),</span>
                    <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span><span class="n">c</span><span class="p">])</span><span class="o">//</span><span class="n">resonancesPerBin</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bins</span><span class="o">=</span><span class="p">[]</span>
                <span class="n">bins</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lowerBound</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">ichunk</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span><span class="o">//</span><span class="n">resonancesPerBin</span><span class="p">):</span>
                    <span class="n">thisBin</span><span class="o">=</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">ichunk</span><span class="o">*</span><span class="n">resonancesPerBin</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">res</span><span class="p">[</span><span class="n">ichunk</span><span class="o">*</span><span class="n">resonancesPerBin</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span>
                    <span class="k">if</span> <span class="n">thisBin</span> <span class="o">&gt;</span> <span class="n">bins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span><span class="n">bins</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">thisBin</span><span class="p">)</span>
                <span class="n">bins</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">upperBound</span><span class="p">)</span>
            <span class="n">results</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;energyGrid&#39;</span><span class="p">:</span><span class="n">bins</span><span class="p">,</span><span class="s1">&#39;widths&#39;</span><span class="p">:[</span><span class="mf">0.0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">bins</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span><span class="s1">&#39;spacings&#39;</span><span class="p">:[</span><span class="mf">0.0</span> <span class="k">for</span> <span class="n">xx</span> <span class="ow">in</span> <span class="n">bins</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]}</span>
            <span class="k">if</span> <span class="kc">False</span><span class="p">:</span> <span class="nb">print</span> <span class="n">c</span><span class="o">.</span><span class="n">reaction</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">J</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">upperBound</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lowerBound</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span><span class="n">c</span><span class="p">]),</span> <span class="n">resonancesPerBin</span>
            <span class="n">numResonancesUsed</span><span class="o">=</span><span class="mi">0</span>
            <span class="c1"># compute averages in a bin</span>
            <span class="k">for</span> <span class="n">i1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">spacingsList</span><span class="o">=</span><span class="p">[]</span>
                <span class="n">widthList</span><span class="o">=</span><span class="p">[]</span>
                <span class="n">lastER</span><span class="o">=</span><span class="kc">None</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">res</span><span class="p">:</span>
                    <span class="n">ER</span><span class="o">=</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">ER</span> <span class="o">&gt;=</span> <span class="n">bins</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">ER</span> <span class="o">&lt;=</span> <span class="n">bins</span><span class="p">[</span><span class="n">i1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">lastER</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">lastER</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">lowerBound</span> <span class="ow">and</span> <span class="n">ER</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">lowerBound</span><span class="p">:</span>
                            <span class="n">spacingsList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ER</span> <span class="o">-</span> <span class="n">lastER</span><span class="p">)</span>
                        <span class="n">widthList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">lastER</span> <span class="o">=</span> <span class="n">ER</span>
<span class="c1">#                ERList=[self._energies[iR] for iR in self.channels[c]]</span>
<span class="c1">#                ERList.sort()</span>
<span class="c1">#                for ER in ERList:</span>
<span class="c1">#                    if ER&gt;=bins[i1] and ER&lt;=bins[i1+1]:</span>
<span class="c1">#                        widthList.append(abs(self.channels[c][iR]))</span>
<span class="c1">#                        if lastER is not None and lastER&gt;self.lowerBound and ER&gt;self.lowerBound:</span>
<span class="c1">#                            spacingsList.append(ER-lastER)</span>
<span class="c1">#                        lastER=ER</span>
                <span class="n">actualResonancesPerBin</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">widthList</span><span class="p">)</span>
                <span class="n">numResonancesUsed</span><span class="o">+=</span><span class="n">actualResonancesPerBin</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spacingsList</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">computeUncertainty</span><span class="p">:</span>
                        <span class="n">results</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;spacings&#39;</span><span class="p">][</span><span class="n">i1</span><span class="p">]</span><span class="o">=</span><span class="n">pqu</span><span class="o">.</span><span class="n">PQU</span><span class="o">.</span><span class="n">PQU</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">mean</span><span class="p">(</span><span class="n">spacingsList</span><span class="p">),</span><span class="n">uncertainty</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var</span><span class="p">(</span><span class="n">spacingsList</span><span class="p">)),</span><span class="n">unit</span><span class="o">=</span><span class="s1">&#39;eV&#39;</span><span class="p">)</span>
                        <span class="n">results</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;widths&#39;</span><span class="p">][</span><span class="n">i1</span><span class="p">]</span><span class="o">=</span><span class="n">pqu</span><span class="o">.</span><span class="n">PQU</span><span class="o">.</span><span class="n">PQU</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">mean</span><span class="p">(</span><span class="n">widthList</span><span class="p">),</span><span class="n">uncertainty</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var</span><span class="p">(</span><span class="n">widthList</span><span class="p">)),</span><span class="n">unit</span><span class="o">=</span><span class="s1">&#39;eV&#39;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">results</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;spacings&#39;</span><span class="p">][</span><span class="n">i1</span><span class="p">]</span><span class="o">=</span><span class="n">pqu</span><span class="o">.</span><span class="n">PQU</span><span class="o">.</span><span class="n">PQU</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">mean</span><span class="p">(</span><span class="n">spacingsList</span><span class="p">),</span><span class="n">unit</span><span class="o">=</span><span class="s1">&#39;eV&#39;</span><span class="p">)</span>
                        <span class="n">results</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;widths&#39;</span><span class="p">][</span><span class="n">i1</span><span class="p">]</span><span class="o">=</span><span class="n">pqu</span><span class="o">.</span><span class="n">PQU</span><span class="o">.</span><span class="n">PQU</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">mean</span><span class="p">(</span><span class="n">widthList</span><span class="p">),</span><span class="n">unit</span><span class="o">=</span><span class="s1">&#39;eV&#39;</span><span class="p">)</span>
                    <span class="c1">#print results[c][&#39;widths&#39;][i1],widthList</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">widthList</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;spacings&#39;</span><span class="p">][</span><span class="n">i1</span><span class="p">]</span><span class="o">=</span><span class="n">pqu</span><span class="o">.</span><span class="n">PQU</span><span class="o">.</span><span class="n">PQU</span><span class="p">(</span><span class="n">value</span><span class="o">=-</span><span class="mi">1</span><span class="n">e9</span><span class="p">,</span><span class="n">unit</span><span class="o">=</span><span class="s1">&#39;eV&#39;</span><span class="p">)</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;widths&#39;</span><span class="p">][</span><span class="n">i1</span><span class="p">]</span><span class="o">=</span><span class="n">pqu</span><span class="o">.</span><span class="n">PQU</span><span class="o">.</span><span class="n">PQU</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">widthList</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">unit</span><span class="o">=</span><span class="s1">&#39;eV&#39;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">all</span><span class="p">([</span><span class="n">w</span><span class="o">==</span><span class="mf">0.0</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">widthList</span><span class="p">]):</span> <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;spacings&#39;</span><span class="p">][</span><span class="n">i1</span><span class="p">]</span><span class="o">=</span><span class="n">pqu</span><span class="o">.</span><span class="n">PQU</span><span class="o">.</span><span class="n">PQU</span><span class="p">(</span><span class="n">value</span><span class="o">=-</span><span class="mi">1</span><span class="n">e9</span><span class="p">,</span><span class="n">unit</span><span class="o">=</span><span class="s1">&#39;eV&#39;</span><span class="p">)</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;widths&#39;</span><span class="p">][</span><span class="n">i1</span><span class="p">]</span><span class="o">=</span><span class="n">pqu</span><span class="o">.</span><span class="n">PQU</span><span class="o">.</span><span class="n">PQU</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span><span class="n">unit</span><span class="o">=</span><span class="s1">&#39;eV&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="kc">False</span><span class="p">:</span> <span class="nb">print</span><span class="s1">&#39;    &#39;</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">bins</span><span class="p">[</span><span class="n">i1</span><span class="p">],</span> <span class="n">bins</span><span class="p">[</span><span class="n">i1</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">actualResonancesPerBin</span><span class="p">,</span><span class="n">numResonancesUsed</span><span class="p">,</span><span class="n">results</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;widths&#39;</span><span class="p">][</span><span class="n">i1</span><span class="p">],</span><span class="n">results</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;spacings&#39;</span><span class="p">][</span><span class="n">i1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="RRBaseClass.getTransmissionCoefficientsFromSumRule"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.getTransmissionCoefficientsFromSumRule">[docs]</a>    <span class="k">def</span> <span class="nf">getTransmissionCoefficientsFromSumRule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">resonancesPerBin</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="n">computeUncertainty</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use Moldauer&#39;s sum rule to extract the transmission coefficients directly from the RRR tables</span>
<span class="sd">            P.A. Moldauer Phys. Rev. Lett. 19, 1047-1048 (1967)</span>

<span class="sd">        :param computeUncertainty: toggle the calculation of the uncertainty of the transmission coefficients</span>
<span class="sd">        :return: a dictionary of results, sorted by channel</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">pqu.PQU</span>
        <span class="n">aves</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getAverageQuantities</span><span class="p">(</span><span class="n">resonancesPerBin</span><span class="o">=</span><span class="n">resonancesPerBin</span><span class="p">,</span><span class="n">computeUncertainty</span><span class="o">=</span><span class="n">computeUncertainty</span><span class="p">)</span>
        <span class="n">results</span><span class="o">=</span><span class="p">{}</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">aves</span><span class="p">:</span>
            <span class="n">results</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;Tc&#39;</span><span class="p">:[],</span><span class="s1">&#39;energyGrid&#39;</span><span class="p">:</span><span class="n">aves</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;energyGrid&#39;</span><span class="p">]}</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span><span class="n">c</span><span class="p">])</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="k">continue</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">aves</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;energyGrid&#39;</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">twoPiGOverD</span><span class="o">=</span><span class="mf">2.0</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">aves</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;widths&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">aves</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;spacings&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span> <span class="k">continue</span>
                <span class="k">if</span> <span class="n">twoPiGOverD</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">16</span><span class="p">:</span> <span class="n">results</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;Tc&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pqu</span><span class="o">.</span><span class="n">PQU</span><span class="o">.</span><span class="n">PQU</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span><span class="n">unit</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span> <span class="n">results</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;Tc&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">twoPiGOverD</span><span class="o">*</span><span class="n">twoPiGOverD</span><span class="o">*</span><span class="p">(</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span><span class="o">+</span><span class="mf">4.0</span><span class="o">/</span><span class="n">twoPiGOverD</span><span class="o">/</span><span class="n">twoPiGOverD</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="RRBaseClass.getPoleStrength"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.getPoleStrength">[docs]</a>    <span class="k">def</span> <span class="nf">getPoleStrength</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">computeUncertainty</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the neutron pole strength from the transmission coefficients</span>

<span class="sd">        ..math::</span>
<span class="sd">            s_c(E) = \rho_c(E)\overline{\Gamma_c}/2P_c = T_c(E)/4\pi P_c</span>

<span class="sd">        :param computeUncertainty:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">Tcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getTransmissionCoefficientsFromSumRule</span><span class="p">(</span><span class="n">computeUncertainty</span><span class="o">=</span><span class="n">computeUncertainty</span><span class="p">)</span>
        <span class="n">results</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">Tcs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">Tcs</span><span class="p">:</span>
            <span class="n">results</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;sc&#39;</span><span class="p">]</span><span class="o">=</span><span class="p">[]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span><span class="n">c</span><span class="p">])</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="k">continue</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Tcs</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;energyGrid&#39;</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">penFact</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactorByChannel</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">Tcs</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;energyGrid&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">penFact</span><span class="o">&gt;</span><span class="mf">0.0</span> <span class="ow">and</span> <span class="n">i</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;Tc&#39;</span><span class="p">]):</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;sc&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;Tc&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="mf">4.0</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">penFact</span><span class="p">)</span> <span class="p">)</span>
        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="RRBaseClass.getStrengthFunction"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.getStrengthFunction">[docs]</a>    <span class="k">def</span> <span class="nf">getStrengthFunction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">computeUncertainty</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">results</span><span class="o">=</span><span class="p">{}</span>
        <span class="n">sc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getPoleStrength</span><span class="p">(</span><span class="n">computeUncertainty</span><span class="o">=</span><span class="n">computeUncertainty</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">sc</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span><span class="n">c</span><span class="p">])</span><span class="o">==</span><span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">sc</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;sc&#39;</span><span class="p">])</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>  <span class="n">results</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">=-</span><span class="mi">1</span>
            <span class="k">elif</span> <span class="n">sc</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;sc&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mf">0.0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">sc</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;sc&#39;</span><span class="p">])</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="n">results</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">=</span><span class="n">sc</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;sc&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span> <span class="n">results</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">=</span><span class="n">sc</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;sc&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="RRBaseClass.getScatteringLength"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.getScatteringLength">[docs]</a>    <span class="k">def</span> <span class="nf">getScatteringLength</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Compute R&#39; in b**1/2, should be close to AP</span>

<span class="sd">        The potential scattering cross section sigPot = 4 Pi (R&#39;)^2, so we compute the potential scattering cross section at E=1e-5 eV</span>
<span class="sd">        :return:</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">E</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">PQU</span><span class="o">.</span><span class="n">PQU</span><span class="p">(</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;eV&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span><span class="p">)</span> <span class="p">])</span>
        <span class="n">sigPotL</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">c</span><span class="o">.</span><span class="n">isElastic</span><span class="p">:</span> <span class="k">continue</span>
            <span class="n">sigPotL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span> <span class="p">(</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">)</span> <span class="o">*</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">phiByChannel</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">E</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">(</span><span class="n">E</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="p">)</span>
        <span class="n">sigPot</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">sigPotL</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sigPot</span><span class="o">/</span><span class="mf">4.0</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="RRBaseClass.getReducedWidths"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.getReducedWidths">[docs]</a>    <span class="k">def</span> <span class="nf">getReducedWidths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">Emin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Emax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the list of widths to reduced widths:</span>

<span class="sd">            redWidth = width/2*penetrability</span>

<span class="sd">        :param widthList:</span>
<span class="sd">        :param channel:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">reducedWidthList</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">iR</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">]:</span>
            <span class="n">ER</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_energies</span><span class="p">[</span><span class="n">iR</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">Emin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ER</span> <span class="o">&lt;</span> <span class="n">Emin</span><span class="p">:</span> <span class="k">continue</span>
            <span class="k">if</span> <span class="n">Emax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ER</span> <span class="o">&gt;</span> <span class="n">Emax</span><span class="p">:</span> <span class="k">continue</span>
            <span class="n">reducedWidthList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">][</span><span class="n">iR</span><span class="p">]</span><span class="o">/</span><span class="mf">2.0</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactorByChannel</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span><span class="n">ER</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">reducedWidthList</span></div>

<div class="viewcode-block" id="RRBaseClass.getPorterThomasFitToWidths"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.getPorterThomasFitToWidths">[docs]</a>    <span class="k">def</span> <span class="nf">getPorterThomasFitToWidths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Emin</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">Emax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Perform a channel-by-channel fit of the histogram of widths to a Porter-Thomas distribution.</span>

<span class="sd">        :param verbose:</span>
<span class="sd">        :return:</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">try</span><span class="p">:</span> <span class="kn">import</span> <span class="nn">scipy.optimize</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="nb">print</span> <span class="s2">&quot;WARNING: scipy.optimize not imported, Porter-Thomas analysis not done&quot;</span>
            <span class="k">return</span> <span class="p">{}</span>
        <span class="k">try</span><span class="p">:</span> <span class="kn">import</span> <span class="nn">numpy</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="nb">print</span> <span class="s2">&quot;WARNING: numpy&#39;s histogram() and mean() functions not imported, Porter-Thomas analysis not done&quot;</span>
            <span class="k">return</span> <span class="p">{}</span>
        <span class="n">results</span><span class="o">=</span><span class="p">{}</span>

        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span> <span class="n">c</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">eliminated</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span> <span class="s1">&#39;    eliminated&#39;</span>
                <span class="n">results</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span><span class="mf">0.0</span><span class="p">,</span><span class="s1">&#39;ddof&#39;</span><span class="p">:</span><span class="mf">0.0</span><span class="p">}</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span><span class="n">c</span><span class="p">])</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span> <span class="s1">&#39;    not enough data&#39;</span>
                <span class="n">results</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span><span class="mf">1.0</span><span class="p">,</span><span class="s1">&#39;ddof&#39;</span><span class="p">:</span><span class="mf">0.0</span><span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">reducedWidthList</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getReducedWidths</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">Emin</span><span class="o">=</span><span class="n">Emin</span><span class="p">,</span> <span class="n">Emax</span><span class="o">=</span><span class="n">Emax</span><span class="p">)</span>
                <span class="n">aveWidth</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">reducedWidthList</span><span class="p">)</span>
                <span class="n">norm</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">reducedWidthList</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span> <span class="s1">&#39;    widths&#39;</span><span class="p">,</span> <span class="n">reducedWidthList</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">w</span><span class="o">==</span><span class="n">reducedWidthList</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">reducedWidthList</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span> <span class="s1">&#39;    widths identical&#39;</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span><span class="mf">1.0</span><span class="p">,</span><span class="s1">&#39;ddof&#39;</span><span class="p">:</span><span class="mf">0.0</span><span class="p">}</span>
                <span class="k">elif</span> <span class="n">aveWidth</span> <span class="o">==</span> <span class="mf">0.0</span> <span class="ow">or</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">aveWidth</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span> <span class="s1">&#39;    widths are zero or nan&#39;</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span><span class="mf">1.0</span><span class="p">,</span><span class="s1">&#39;ddof&#39;</span><span class="p">:</span><span class="mf">0.0</span><span class="p">}</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span> <span class="s1">&#39;    scaled widths&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">w</span><span class="o">/</span><span class="n">aveWidth</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">reducedWidthList</span><span class="p">]</span>
                    <span class="n">hist</span><span class="p">,</span> <span class="n">bin_edges</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">histogram</span><span class="p">([</span><span class="n">w</span><span class="o">/</span><span class="n">aveWidth</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">reducedWidthList</span><span class="p">])</span>
                    <span class="c1">#if verbose:  print &#39;    hist&#39;,hist, any(hist)</span>
                    <span class="c1">#if verbose:  print &#39;    bins&#39;, bin_edges, any(bin_edges)</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span> <span class="s1">&#39;    fitting:&#39;</span>

                    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">hist</span><span class="p">):</span>

                        <span class="k">def</span> <span class="nf">PorterThomasDistribution</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">nu</span><span class="p">):</span>
                            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                            Porter-Thomas distribution</span>
<span class="sd">                            Froehner&#39;s eq. (277).</span>
<span class="sd">                            Really just a chi^2 distribution with nu degrees of freedom</span>

<span class="sd">                            :param y:</span>
<span class="sd">                            :param nu:</span>
<span class="sd">                            :return:</span>
<span class="sd">                            &quot;&quot;&quot;</span>
                            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span> <span class="s1">&#39;        y&#39;</span><span class="p">,</span><span class="n">y</span>
                            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span> <span class="s1">&#39;        norm&#39;</span><span class="p">,</span><span class="n">norm</span>
                            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span> <span class="s1">&#39;        nu&#39;</span><span class="p">,</span><span class="n">nu</span>
                            <span class="n">gam</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="n">nu</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">nu</span> <span class="o">&lt;</span> <span class="mf">2.0</span><span class="p">:</span>
                                <span class="n">ycut</span><span class="o">=</span><span class="nb">pow</span><span class="p">(</span><span class="mi">1</span><span class="n">e4</span><span class="o">*</span><span class="n">gam</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">nu</span><span class="o">/</span><span class="mf">2.0</span><span class="p">))</span>
                                <span class="n">y</span><span class="p">[</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">ycut</span><span class="p">]</span><span class="o">=</span><span class="n">ycut</span>
                            <span class="k">return</span> <span class="n">norm</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="nb">pow</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">nu</span><span class="o">/</span><span class="mf">2.0</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span><span class="o">/</span><span class="n">gam</span>

                        <span class="n">popt</span><span class="p">,</span><span class="n">pcov</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">curve_fit</span><span class="p">(</span> <span class="n">PorterThomasDistribution</span><span class="p">,</span> <span class="p">[(</span><span class="n">bin_edges</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">bin_edges</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">)],</span> <span class="n">hist</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">bounds</span><span class="o">=</span><span class="p">[</span><span class="mf">0.0</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">inf</span><span class="p">]</span> <span class="p">)</span> <span class="c1"># dump 1st bin, missing resonances there</span>
                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span> <span class="s1">&#39;    popt&#39;</span><span class="p">,</span><span class="n">popt</span>
                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span> <span class="s1">&#39;    pcov&#39;</span><span class="p">,</span><span class="n">pcov</span>
                        <span class="n">results</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span><span class="n">popt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="s1">&#39;ddof&#39;</span><span class="p">:</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">pcov</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span><span class="s1">&#39;bin_edges&#39;</span><span class="p">:</span><span class="n">bin_edges</span><span class="p">,</span><span class="s1">&#39;hist&#39;</span><span class="p">:</span><span class="n">hist</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">results</span></div></div>


<span class="c1">#### Single-level Breit-Wigner ###</span>
<div class="viewcode-block" id="SLBWcrossSection"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.SLBWcrossSection">[docs]</a><span class="k">class</span> <span class="nc">SLBWcrossSection</span><span class="p">(</span><span class="n">RRBaseClass</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    given a resonance region in SLBW format,</span>
<span class="sd">    create a class with all data required to reconstruct</span>

<span class="sd">    Note, the resonances in the SLBW format each correspond to different &quot;levels&quot; and so do not</span>
<span class="sd">    interfere.  This is unlike all of the other RRR formats.  So, while one resonance energy</span>
<span class="sd">    and one width go with one channel and all the channels associated with one resonance energy</span>
<span class="sd">    go together to make one reaction, the reactions for each resonance are added incoherently (no</span>
<span class="sd">    interference effects at all).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reactionSuite</span><span class="p">,</span> <span class="n">sectionIndex</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">enableAngDists</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SLBWcrossSection</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">reactionSuite</span><span class="p">,</span> <span class="n">sectionIndex</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sortLandJ</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;From </span><span class="si">%f</span><span class="s2"> to </span><span class="si">%f</span><span class="s2"> </span><span class="si">%s</span><span class="s2">, reconstructing using Single-level Breit-Wigner&quot;</span> <span class="o">%</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lowerBound</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">upperBound</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">enableAngDists</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">setResonanceParametersByChannel</span><span class="p">()</span>

<div class="viewcode-block" id="SLBWcrossSection.setResonanceParametersByChannel"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.SLBWcrossSection.setResonanceParametersByChannel">[docs]</a>    <span class="k">def</span> <span class="nf">setResonanceParametersByChannel</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">multipleSScheme</span><span class="o">=</span><span class="s1">&#39;ENDF&#39;</span><span class="p">,</span> <span class="n">useReichMooreApproximation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">Ein</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">warnOnly</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reorganize member data into channels (relies heavily on groundwork in sortLandJ).</span>

<span class="sd">        Note, unlike the getResonanceParametersByChannel() function in MLBW, RM or RML,</span>
<span class="sd">        the fact that different resonances are entirely different reactions means that the</span>
<span class="sd">        channelDicts have to have an additional layer of sorting that corresponds to the SLBW &quot;level&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># make a unified table of resonance parameter data, convert to self.energyUnit if necessary</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nResonances</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">resonanceParameters</span><span class="o">.</span><span class="n">table</span> <span class="p">)</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;energy&#39;</span><span class="p">,</span><span class="s1">&#39;L&#39;</span><span class="p">,</span><span class="s1">&#39;J&#39;</span><span class="p">,</span><span class="s1">&#39;channelSpin&#39;</span><span class="p">,</span><span class="s1">&#39;totalWidth&#39;</span><span class="p">,</span><span class="s1">&#39;neutronWidth&#39;</span><span class="p">,</span><span class="s1">&#39;captureWidth&#39;</span><span class="p">,</span>
                <span class="s1">&#39;fissionWidth&#39;</span><span class="p">,</span><span class="s1">&#39;fissionWidthB&#39;</span><span class="p">)</span>
        <span class="n">EU</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span>
        <span class="n">units</span> <span class="o">=</span> <span class="p">(</span><span class="n">EU</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="n">EU</span><span class="p">,</span><span class="n">EU</span><span class="p">,</span><span class="n">EU</span><span class="p">,</span><span class="n">EU</span><span class="p">,</span><span class="n">EU</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">resonanceParameters</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">getColumn</span><span class="p">(</span> <span class="n">quant</span><span class="p">,</span><span class="n">unit</span> <span class="p">)</span> <span class="k">for</span> <span class="n">quant</span><span class="p">,</span><span class="n">unit</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">params</span><span class="p">,</span><span class="n">units</span><span class="p">)</span> <span class="p">]</span>
        <span class="n">warnings</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nResonances</span>

        <span class="n">allowedSs</span> <span class="o">=</span> <span class="n">getAllowedTotalSpins</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">projectileSpin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">targetSpin</span><span class="p">,</span> <span class="n">useFactor2Trick</span><span class="o">=</span><span class="kc">False</span> <span class="p">)</span>

        <span class="c1"># Now make the dictionary of channels, grouped by independent level</span>
        <span class="n">channelDicts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">iR</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">nResonances</span> <span class="p">):</span>
            <span class="n">ER</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">iR</span><span class="p">]</span>
            <span class="n">L</span> <span class="o">=</span>  <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">iR</span><span class="p">]</span>
            <span class="n">J</span> <span class="o">=</span>  <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">iR</span><span class="p">]</span>
            <span class="n">S</span> <span class="o">=</span>  <span class="kc">None</span> <span class="c1"># not given in SLBW, I just list it here for completeness</span>
            <span class="n">GT</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="n">iR</span><span class="p">]</span>
            <span class="n">GN</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="n">iR</span><span class="p">]</span>
            <span class="n">GG</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">6</span><span class="p">][</span><span class="n">iR</span><span class="p">]</span>
            <span class="n">GF</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">7</span><span class="p">][</span><span class="n">iR</span><span class="p">]</span>
            <span class="n">GX</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">8</span><span class="p">][</span><span class="n">iR</span><span class="p">]</span>
            <span class="n">JisAllowed</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">allowedSByThisJl</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">SS</span> <span class="ow">in</span> <span class="n">allowedSs</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">)</span> <span class="ow">in</span> <span class="n">getAllowedTotalSpins</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="n">SS</span><span class="p">,</span> <span class="n">useFactor2Trick</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
                    <span class="n">JisAllowed</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">allowedSByThisJl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">SS</span> <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">JisAllowed</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">warnOnly</span><span class="p">:</span>
                    <span class="n">allowedSByThisJl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">SS</span> <span class="p">)</span>
                    <span class="kn">from</span> <span class="nn">fudge.gnd</span> <span class="k">import</span> <span class="n">warning</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">warning</span><span class="o">.</span><span class="n">invalidAngularMomentaCombination</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">SS</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;SLBW&#39;</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span> <span class="s2">&quot;Invalid total angular momentum and/or orbital momentum: cannot couple up to J = &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">J</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; with I = &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targetSpin</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;, i = 0.5 and L = &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">L</span><span class="p">)</span> <span class="p">)</span>
            <span class="n">gfact</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">projectileSpin</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">targetSpin</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">channelDict</span><span class="o">=</span><span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
            <span class="n">numAllowedSByThisJl</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="n">allowedSByThisJl</span> <span class="p">)</span>

            <span class="c1"># Way recommended by NJOY:</span>
            <span class="c1">#   * One of valid S&#39;s get width, other(s) get zero width</span>
            <span class="c1">#   * Zero width channels left in sum to get potential scattering correct</span>
            <span class="c1">#   * Gets good (cs from U) to (cs from Fudge) comparison; good (cs from U) to (cs from BB)</span>
            <span class="k">if</span> <span class="n">multipleSScheme</span> <span class="o">==</span> <span class="s1">&#39;NJOY&#39;</span><span class="p">:</span>
                <span class="n">channelDict</span><span class="p">[</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;elastic&#39;</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="n">allowedSByThisJl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">gfact</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">NEUTRONCHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span> <span class="p">)]</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span> <span class="n">ER</span><span class="p">,</span> <span class="n">GN</span> <span class="p">)</span> <span class="p">]</span>
                <span class="n">channelDict</span><span class="p">[</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;capture&#39;</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="n">allowedSByThisJl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">gfact</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">GAMMACHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span> <span class="p">)]</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span> <span class="n">ER</span><span class="p">,</span> <span class="n">GG</span> <span class="p">)</span> <span class="p">]</span>
                <span class="k">if</span> <span class="n">GF</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span> <span class="n">channelDict</span><span class="p">[</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;fission&#39;</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="n">allowedSByThisJl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">gfact</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">FISSIONCHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span> <span class="p">)]</span>     <span class="o">=</span> <span class="p">[</span> <span class="p">(</span> <span class="n">ER</span><span class="p">,</span> <span class="n">GF</span> <span class="p">)</span> <span class="p">]</span>
                <span class="k">if</span> <span class="n">GX</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span> <span class="n">channelDict</span><span class="p">[</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;competitive&#39;</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="n">allowedSByThisJl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">gfact</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">COMPETATIVECHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span> <span class="p">)]</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span> <span class="n">ER</span><span class="p">,</span> <span class="n">GX</span> <span class="p">)</span> <span class="p">]</span>
                <span class="k">for</span> <span class="n">SS</span> <span class="ow">in</span> <span class="n">allowedSByThisJl</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                    <span class="n">channelDict</span><span class="p">[</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;elastic&#39;</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="n">SS</span><span class="p">,</span> <span class="n">gfact</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">NEUTRONCHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span> <span class="p">)]</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span> <span class="n">ER</span><span class="p">,</span> <span class="mf">0.0</span> <span class="p">)</span> <span class="p">]</span>
                    <span class="n">channelDict</span><span class="p">[</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;capture&#39;</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="n">SS</span><span class="p">,</span> <span class="n">gfact</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">GAMMACHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span> <span class="p">)]</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span> <span class="n">ER</span><span class="p">,</span> <span class="mf">0.0</span> <span class="p">)</span> <span class="p">]</span>
                    <span class="k">if</span> <span class="n">GF</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span> <span class="n">channelDict</span><span class="p">[</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;fission&#39;</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="n">SS</span><span class="p">,</span> <span class="n">gfact</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">FISSIONCHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span> <span class="p">)]</span>     <span class="o">=</span> <span class="p">[</span> <span class="p">(</span> <span class="n">ER</span><span class="p">,</span> <span class="mf">0.0</span> <span class="p">)</span> <span class="p">]</span>
                    <span class="k">if</span> <span class="n">GX</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span> <span class="n">channelDict</span><span class="p">[</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;competitive&#39;</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="n">SS</span><span class="p">,</span> <span class="n">gfact</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">COMPETATIVECHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span> <span class="p">)]</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span> <span class="n">ER</span><span class="p">,</span> <span class="mf">0.0</span> <span class="p">)</span> <span class="p">]</span>

            <span class="c1"># Way mandated by ENDF manual:</span>
            <span class="c1">#   * Width divided between channels with valid S&#39;s based on sign of J:</span>
            <span class="c1">#       ** if J&gt;0, S is max possible value</span>
            <span class="c1">#       ** if J&lt;0, S is min possible value</span>
            <span class="c1">#   * All channels left in sum to get potential scattering correct</span>
            <span class="c1">#   * Gets poor (cs from U) to (cs from Fudge) comparison; poor (cs from U) to (cs from BB)</span>
            <span class="k">elif</span> <span class="n">multipleSScheme</span> <span class="o">==</span> <span class="s1">&#39;ENDF&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">allowedSByThisJl</span><span class="p">:</span>
                    <span class="n">allowedSByThisJl</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">allowedSByThisJl</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="n">SS</span><span class="o">=</span><span class="n">allowedSByThisJl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span> <span class="n">SS</span><span class="o">=</span><span class="n">allowedSByThisJl</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">)</span><span class="o">==</span><span class="n">J</span><span class="p">)]</span>
                    <span class="n">channelDict</span><span class="p">[</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;elastic&#39;</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="n">SS</span><span class="p">,</span> <span class="n">gfact</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">NEUTRONCHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span> <span class="p">)]</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span> <span class="n">ER</span><span class="p">,</span> <span class="n">GN</span><span class="o">/</span><span class="n">numAllowedSByThisJl</span> <span class="p">)</span> <span class="p">]</span>
                    <span class="n">channelDict</span><span class="p">[</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;capture&#39;</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="n">SS</span><span class="p">,</span> <span class="n">gfact</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">GAMMACHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span> <span class="p">)]</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span> <span class="n">ER</span><span class="p">,</span> <span class="n">GG</span><span class="o">/</span><span class="n">numAllowedSByThisJl</span> <span class="p">)</span> <span class="p">]</span>
                    <span class="k">if</span> <span class="n">GF</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span> <span class="n">channelDict</span><span class="p">[</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;fission&#39;</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="n">SS</span><span class="p">,</span> <span class="n">gfact</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">FISSIONCHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span> <span class="p">)]</span>     <span class="o">=</span> <span class="p">[</span> <span class="p">(</span> <span class="n">ER</span><span class="p">,</span> <span class="n">GF</span><span class="o">/</span><span class="n">numAllowedSByThisJl</span> <span class="p">)</span> <span class="p">]</span>
                    <span class="k">if</span> <span class="n">GX</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span> <span class="n">channelDict</span><span class="p">[</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;competitive&#39;</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="n">SS</span><span class="p">,</span> <span class="n">gfact</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">COMPETATIVECHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span> <span class="p">)]</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span> <span class="n">ER</span><span class="p">,</span> <span class="n">GX</span><span class="o">/</span><span class="n">numAllowedSByThisJl</span> <span class="p">)</span> <span class="p">]</span>

            <span class="c1"># Ignore problem:</span>
            <span class="c1">#   * Ignore spin of channels and the fact may be multiple valid spins</span>
            <span class="c1">#   * Gets best (cs from U) to (cs from Fudge) comparison; poor (cs from U) to (cs from BB)</span>
            <span class="k">else</span> <span class="p">:</span>
                <span class="n">channelDict</span><span class="p">[</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;elastic&#39;</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">gfact</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">NEUTRONCHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span> <span class="p">)]</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span> <span class="n">ER</span><span class="p">,</span> <span class="n">GN</span> <span class="p">)</span> <span class="p">]</span>
                <span class="n">channelDict</span><span class="p">[</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;capture&#39;</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">gfact</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">GAMMACHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span> <span class="p">)]</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span> <span class="n">ER</span><span class="p">,</span> <span class="n">GG</span> <span class="p">)</span> <span class="p">]</span>
                <span class="k">if</span> <span class="n">GF</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span> <span class="n">channelDict</span><span class="p">[</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;fission&#39;</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">gfact</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">FISSIONCHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span> <span class="p">)]</span>     <span class="o">=</span> <span class="p">[</span> <span class="p">(</span> <span class="n">ER</span><span class="p">,</span> <span class="n">GF</span> <span class="p">)</span> <span class="p">]</span>
                <span class="k">if</span> <span class="n">GX</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span> <span class="n">channelDict</span><span class="p">[</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;competitive&#39;</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">gfact</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">COMPETATIVECHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span> <span class="p">)]</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span> <span class="n">ER</span><span class="p">,</span> <span class="n">GX</span> <span class="p">)</span> <span class="p">]</span>
            <span class="n">channelDicts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">channelDict</span> <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="o">=</span> <span class="n">channelDicts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allChannels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">warnOnly</span><span class="p">:</span> <span class="k">return</span> <span class="n">warnings</span></div>

<div class="viewcode-block" id="SLBWcrossSection.getScatteringMatrixU"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.SLBWcrossSection.getScatteringMatrixU">[docs]</a>    <span class="k">def</span> <span class="nf">getScatteringMatrixU</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">Ein</span><span class="p">,</span> <span class="n">useTabulatedScatteringRadius</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">enableExtraCoulombPhase</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the scattering matrix</span>

<span class="sd">        Note, unlike the getScatteringMatrixU() function in other resonance classes,</span>
<span class="sd">        the fact that different resonances are entirely different reactions means that the</span>
<span class="sd">        channelDicts have to have an additional layer of sorting that corresponds to the SLBW &quot;level&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">(</span>
            <span class="p">[</span> <span class="p">(</span> <span class="n">iL</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span><span class="o">*</span><span class="p">[</span><span class="nb">complex</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)])</span> <span class="p">)</span> <span class="k">for</span> <span class="n">iL</span><span class="p">,</span><span class="n">cs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">)</span> <span class="p">]</span> <span class="p">)</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span><span class="n">Ein</span><span class="p">)</span>

        <span class="c1"># For calculating phi, default is to use tabulated scattering radius:</span>
        <span class="k">if</span> <span class="n">useTabulatedScatteringRadius</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">scatteringRadius</span><span class="o">.</span><span class="n">isEnergyDependent</span><span class="p">():</span>
                <span class="n">rhohat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">scatteringRadius</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s1">&#39;10*fm&#39;</span><span class="p">,</span> <span class="n">Ein</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">(</span><span class="n">Ein</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rhohat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">scatteringRadius</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s1">&#39;10*fm&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">(</span><span class="n">Ein</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="n">rhohat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span><span class="n">Ein</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">iL</span><span class="p">,</span><span class="n">channels</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">):</span>
            <span class="n">ER</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_energies</span><span class="p">[</span><span class="n">iL</span><span class="p">]</span>
            <span class="n">ERp</span> <span class="o">=</span> <span class="n">ER</span>
            <span class="n">GamTot</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">eiphis</span> <span class="o">=</span> <span class="p">[</span> <span class="p">]</span>
            <span class="n">sqrtgams</span> <span class="o">=</span> <span class="p">[</span> <span class="p">]</span> <span class="c1"># all are real</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">reaction</span> <span class="o">==</span> <span class="s1">&#39;elastic&#39;</span><span class="p">:</span>
                    <span class="n">Gam</span> <span class="o">=</span> <span class="p">(</span> <span class="n">channels</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactor</span><span class="p">(</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span> <span class="n">Ein</span><span class="p">,</span>       <span class="n">c</span><span class="o">.</span><span class="n">l</span> <span class="p">)</span> <span class="p">)</span> <span class="o">/</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactor</span><span class="p">(</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span> <span class="nb">abs</span><span class="p">(</span> <span class="n">ER</span> <span class="p">),</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
                    <span class="n">ERp</span> <span class="o">+=</span> <span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">shiftFactor</span><span class="p">(</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span> <span class="nb">abs</span><span class="p">(</span> <span class="n">ER</span> <span class="p">),</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span> <span class="p">)</span> <span class="p">)</span> <span class="o">-</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">shiftFactor</span><span class="p">(</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span> <span class="n">Ein</span><span class="p">,</span>       <span class="n">c</span><span class="o">.</span><span class="n">l</span> <span class="p">)</span> <span class="p">)</span>
                        <span class="p">)</span> <span class="o">*</span> <span class="n">channels</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactor</span><span class="p">(</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span> <span class="nb">abs</span><span class="p">(</span><span class="n">ER</span><span class="p">),</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
                    <span class="n">eiphis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span> <span class="nb">complex</span><span class="p">(</span> <span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">(</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="n">rhohat</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">Gam</span> <span class="o">=</span> <span class="n">channels</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">eiphis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="nb">complex</span><span class="p">(</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span> <span class="p">)</span> <span class="p">)</span>
                <span class="n">sqrtgams</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="n">Gam</span> <span class="p">)</span> <span class="p">)</span>
                <span class="n">GamTot</span> <span class="o">+=</span> <span class="n">Gam</span>
            <span class="k">for</span> <span class="n">i1</span><span class="p">,</span> <span class="n">c1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">channels</span><span class="p">):</span>
                <span class="n">denominator</span> <span class="o">=</span> <span class="nb">complex</span><span class="p">(</span> <span class="n">ERp</span> <span class="o">-</span> <span class="n">Ein</span><span class="p">,</span> <span class="o">-</span><span class="n">GamTot</span><span class="o">/</span><span class="mf">2.0</span> <span class="p">)</span> <span class="c1"># c1 &amp; c2 have same l</span>
                <span class="k">for</span> <span class="n">i2</span><span class="p">,</span> <span class="n">c2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">channels</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">c2</span><span class="o">.</span><span class="n">index</span> <span class="o">!=</span> <span class="n">c1</span><span class="o">.</span><span class="n">index</span><span class="p">:</span> <span class="k">continue</span>
                    <span class="n">U</span><span class="p">[</span><span class="n">iL</span><span class="p">][</span><span class="n">i1</span><span class="p">][</span><span class="n">i2</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">complex</span><span class="p">(</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">sqrtgams</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span><span class="o">*</span><span class="n">sqrtgams</span><span class="p">[</span><span class="n">i2</span><span class="p">]</span> <span class="p">)</span> <span class="o">/</span> <span class="n">denominator</span>
                    <span class="n">U</span><span class="p">[</span><span class="n">iL</span><span class="p">][</span><span class="n">i1</span><span class="p">][</span><span class="n">i2</span><span class="p">]</span> <span class="o">*=</span> <span class="n">eiphis</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span> <span class="o">*</span> <span class="n">eiphis</span><span class="p">[</span><span class="n">i2</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">U</span></div>

<div class="viewcode-block" id="SLBWcrossSection.getAngularDistribution"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.SLBWcrossSection.getAngularDistribution">[docs]</a>    <span class="k">def</span> <span class="nf">getAngularDistribution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span> <span class="p">):</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Angular distributions cannot be safely reconstructed using Single-Level Breit-Wigner approximation&quot;</span><span class="p">)</span></div>

    <span class="nd">@blockwise</span>
<div class="viewcode-block" id="SLBWcrossSection.getCrossSection"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.SLBWcrossSection.getCrossSection">[docs]</a>    <span class="k">def</span> <span class="nf">getCrossSection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">):</span>
        <span class="n">captureSum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">elasticSum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">fissionSum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
        <span class="c1"># for calculating phi, always use tabulated scattering radius:</span>
        <span class="n">rhohat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">scatteringRadius</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s1">&#39;10*fm&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ls</span><span class="p">:</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="s1">&#39;L&#39;</span><span class="p">]</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">rhohat</span><span class="p">)</span>
            <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactor</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">rho</span><span class="p">)</span>
            <span class="n">S</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">shiftFactor</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">rho</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">J</span> <span class="ow">in</span> <span class="n">L</span><span class="p">[</span><span class="s1">&#39;Js&#39;</span><span class="p">]:</span>
                <span class="n">gfactor</span> <span class="o">=</span> <span class="n">J</span><span class="p">[</span><span class="s1">&#39;gfact&#39;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">spin</span> <span class="ow">in</span> <span class="n">J</span><span class="p">[</span><span class="s1">&#39;channelSpins&#39;</span><span class="p">]:</span>
                    <span class="n">dE</span> <span class="o">=</span> <span class="p">(</span><span class="n">E</span><span class="o">-</span><span class="p">(</span><span class="n">spin</span><span class="p">[</span><span class="s1">&#39;energy&#39;</span><span class="p">]</span><span class="o">+</span><span class="n">spin</span><span class="p">[</span><span class="s1">&#39;neutronWidth&#39;</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">spin</span><span class="p">[</span><span class="s1">&#39;shiftFactor&#39;</span><span class="p">]</span><span class="o">-</span><span class="n">S</span><span class="p">)))</span>
                    <span class="n">totalWidth</span> <span class="o">=</span> <span class="n">P</span><span class="o">*</span><span class="n">spin</span><span class="p">[</span><span class="s1">&#39;neutronWidth&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">spin</span><span class="p">[</span><span class="s1">&#39;captureWidth&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">spin</span><span class="p">[</span><span class="s1">&#39;fissionWidth&#39;</span><span class="p">]</span>
                    <span class="n">denominator</span> <span class="o">=</span> <span class="n">dE</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">totalWidth</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="mi">4</span>
                    <span class="n">captureSum</span> <span class="o">+=</span> <span class="n">gfactor</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="p">(</span> <span class="n">P</span> <span class="o">*</span> <span class="n">spin</span><span class="p">[</span><span class="s1">&#39;neutronWidth&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">spin</span><span class="p">[</span><span class="s1">&#39;captureWidth&#39;</span><span class="p">]</span> <span class="p">)</span> <span class="o">/</span> <span class="n">denominator</span> <span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">fissionSum</span> <span class="o">+=</span> <span class="n">gfactor</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="p">(</span> <span class="n">P</span> <span class="o">*</span> <span class="n">spin</span><span class="p">[</span><span class="s1">&#39;neutronWidth&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">spin</span><span class="p">[</span><span class="s1">&#39;fissionWidth&#39;</span><span class="p">]</span> <span class="p">)</span> <span class="o">/</span> <span class="n">denominator</span> <span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">elasticSum</span> <span class="o">+=</span> <span class="n">gfactor</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="p">(</span> <span class="n">P</span><span class="o">*</span><span class="n">spin</span><span class="p">[</span><span class="s1">&#39;neutronWidth&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span> <span class="n">P</span><span class="o">*</span><span class="n">spin</span><span class="p">[</span><span class="s1">&#39;neutronWidth&#39;</span><span class="p">]</span>
                        <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">totalWidth</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">E</span><span class="o">-</span><span class="n">spin</span><span class="p">[</span><span class="s1">&#39;energy&#39;</span><span class="p">])</span> <span class="p">)</span> <span class="p">)</span>
                        <span class="o">/</span> <span class="n">denominator</span> <span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># numpy.sum(..., axis=1) returns row vector, so also convert first term to row vector:</span>
            <span class="n">elasticSum</span> <span class="o">+=</span> <span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>

        <span class="c1"># get common factor &#39;beta&#39; as a row vector:</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">(</span><span class="n">E</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">capture</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">captureSum</span>
        <span class="n">elastic</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">elasticSum</span>
        <span class="n">fission</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">fissionSum</span>
        <span class="k">for</span> <span class="n">reaction</span> <span class="ow">in</span> <span class="p">(</span><span class="n">capture</span><span class="p">,</span><span class="n">elastic</span><span class="p">,</span><span class="n">fission</span><span class="p">):</span>
            <span class="n">reaction</span><span class="p">[</span> <span class="n">reaction</span><span class="o">&lt;=</span><span class="mi">0</span> <span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">total</span> <span class="o">=</span> <span class="n">elastic</span> <span class="o">+</span> <span class="n">capture</span> <span class="o">+</span> <span class="n">fission</span>
        <span class="n">nonelastic</span> <span class="o">=</span> <span class="n">capture</span> <span class="o">+</span> <span class="n">fission</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;total&#39;</span><span class="p">:</span><span class="n">total</span><span class="p">,</span> <span class="s1">&#39;elastic&#39;</span><span class="p">:</span><span class="n">elastic</span><span class="p">,</span> <span class="s1">&#39;capture&#39;</span><span class="p">:</span><span class="n">capture</span><span class="p">,</span> <span class="s1">&#39;fission&#39;</span><span class="p">:</span><span class="n">fission</span><span class="p">,</span> <span class="s1">&#39;nonelastic&#39;</span><span class="p">:</span><span class="n">nonelastic</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="SLBWcrossSection.getScatteringLength"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.SLBWcrossSection.getScatteringLength">[docs]</a>    <span class="k">def</span> <span class="nf">getScatteringLength</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Compute R&#39; in b**1/2, should be close to AP</span>

<span class="sd">        The potential scattering cross section sigPot = 4 Pi (R&#39;)^2, so we compute the potential scattering cross section at E=1e-5 eV</span>
<span class="sd">        :return:</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">E</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">PQU</span><span class="o">.</span><span class="n">PQU</span><span class="p">(</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;eV&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span><span class="p">)</span> <span class="p">])</span>
        <span class="n">sigPotL</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">c</span><span class="o">.</span><span class="n">isElastic</span><span class="p">:</span> <span class="k">continue</span>
                <span class="n">sigPotL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span> <span class="p">(</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">)</span> <span class="o">*</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">phiByChannel</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">E</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">(</span><span class="n">E</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="p">)</span>
        <span class="n">sigPot</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">sigPotL</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sigPot</span><span class="o">/</span><span class="mf">4.0</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div></div>

<span class="c1">#### Multi-level Breit-Wigner ###</span>
<div class="viewcode-block" id="MLBWcrossSection"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.MLBWcrossSection">[docs]</a><span class="k">class</span> <span class="nc">MLBWcrossSection</span><span class="p">(</span><span class="n">RRBaseClass</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a resonance region in MLBW format,</span>
<span class="sd">    create a class with all data required to reconstruct</span>

<span class="sd">    Only the elastic channel differs from SLBW</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reactionSuite</span><span class="p">,</span> <span class="n">sectionIndex</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">enableAngDists</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MLBWcrossSection</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">reactionSuite</span><span class="p">,</span> <span class="n">sectionIndex</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sortLandJ</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;From </span><span class="si">%f</span><span class="s2"> to </span><span class="si">%f</span><span class="s2"> </span><span class="si">%s</span><span class="s2">, reconstructing using Multi-level Breit-Wigner&quot;</span> <span class="o">%</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lowerBound</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">upperBound</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">enableAngDists</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">setResonanceParametersByChannel</span><span class="p">()</span>

<div class="viewcode-block" id="MLBWcrossSection.getChannelConstantsBc"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.MLBWcrossSection.getChannelConstantsBc">[docs]</a>    <span class="k">def</span> <span class="nf">getChannelConstantsBc</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For ENDF&#39;s MLBW, should be :math:`B_c = S_\\ell(|E_\\lambda|)`</span>
<span class="sd">        where :math:`\\ell` is the channel angular momentum and :math:`\\lambda` is the resonances index for the channel</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span> <span class="s2">&quot;write me&quot;</span> <span class="p">)</span></div>

<div class="viewcode-block" id="MLBWcrossSection.getScatteringMatrixU"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.MLBWcrossSection.getScatteringMatrixU">[docs]</a>    <span class="k">def</span> <span class="nf">getScatteringMatrixU</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">Ein</span><span class="p">,</span> <span class="n">useTabulatedScatteringRadius</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">enableExtraCoulombPhase</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the scattering matrix.  We could have used the generic U function in the base class,</span>
<span class="sd">        but Froehner has &quot;simplifications&quot; that we took advantage of here (that and I don&#39;t know what the</span>
<span class="sd">        R matrix is exactly in the case of MLBW).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize lists and matrices</span>
        <span class="n">sqrtGam</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ein</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nResonances</span> <span class="p">)</span> <span class="p">)</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ein</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span> <span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span> <span class="p">)</span>
        <span class="n">U</span><span class="p">[</span> <span class="p">:,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span> <span class="p">)</span> <span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">Gtots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nResonances</span> <span class="o">*</span> <span class="p">[</span> <span class="mf">0.0</span> <span class="p">]</span>
        <span class="n">ERp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_energies</span> <span class="p">)</span>
        <span class="n">eiphis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getEiPhis</span><span class="p">(</span>  <span class="n">Ein</span><span class="p">,</span> <span class="n">useTabulatedScatteringRadius</span> <span class="o">=</span> <span class="n">useTabulatedScatteringRadius</span> <span class="p">)</span>

        <span class="c1"># Precompute sqrt(Gamma) and sum up to get the total Gamma</span>
        <span class="c1"># Total Gamma may be different from what is given in the ENDF data file</span>
        <span class="c1"># Also, work out energy shifts</span>
        <span class="k">for</span> <span class="n">ic</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="p">):</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">reaction</span> <span class="o">==</span> <span class="s1">&#39;elastic&#39;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">iR</span><span class="p">,</span> <span class="n">G</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">ER</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_energies</span><span class="p">[</span><span class="n">iR</span><span class="p">]</span>
                    <span class="n">Gam</span> <span class="o">=</span> <span class="p">(</span> <span class="n">G</span> <span class="o">*</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactor</span><span class="p">(</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span> <span class="n">Ein</span><span class="p">,</span>       <span class="n">c</span><span class="o">.</span><span class="n">l</span> <span class="p">)</span> <span class="p">)</span> <span class="o">/</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactor</span><span class="p">(</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span> <span class="nb">abs</span><span class="p">(</span> <span class="n">ER</span> <span class="p">),</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
                    <span class="n">ERp</span><span class="p">[</span><span class="n">iR</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">shiftFactor</span><span class="p">(</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span> <span class="nb">abs</span><span class="p">(</span> <span class="n">ER</span> <span class="p">),</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span> <span class="p">)</span> <span class="p">)</span> <span class="o">-</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">shiftFactor</span><span class="p">(</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span> <span class="n">Ein</span><span class="p">,</span>       <span class="n">c</span><span class="o">.</span><span class="n">l</span> <span class="p">)</span> <span class="p">)</span>
                        <span class="p">)</span> <span class="o">*</span> <span class="n">G</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactor</span><span class="p">(</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span> <span class="nb">abs</span><span class="p">(</span><span class="n">ER</span><span class="p">),</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">)</span> <span class="p">)</span>
                    <span class="n">sqrtGam</span><span class="p">[</span> <span class="p">:,</span> <span class="n">ic</span><span class="p">,</span> <span class="n">iR</span> <span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Gam</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
                    <span class="n">Gtots</span><span class="p">[</span> <span class="n">iR</span> <span class="p">]</span> <span class="o">+=</span> <span class="n">Gam</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">iR</span><span class="p">,</span> <span class="n">G</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">ER</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_energies</span><span class="p">[</span><span class="n">iR</span><span class="p">]</span>
                    <span class="n">sqrtGam</span><span class="p">[</span> <span class="p">:,</span> <span class="n">ic</span><span class="p">,</span> <span class="n">iR</span> <span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">G</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
                    <span class="n">Gtots</span><span class="p">[</span> <span class="n">iR</span> <span class="p">]</span> <span class="o">+=</span> <span class="n">G</span>

        <span class="c1"># If the width in the ENDF file is bigger than the sum of parts, there is a competitive width</span>
        <span class="c1"># otherwise, the ENDF value is wrong, use the one we get from the sum of parts</span>
        <span class="k">for</span> <span class="n">iR</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">nResonances</span> <span class="p">):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">Gtots</span><span class="p">[</span> <span class="n">iR</span> <span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_widths</span><span class="p">[</span> <span class="n">iR</span> <span class="p">]</span>
            <span class="n">Gtots</span><span class="p">[</span> <span class="n">iR</span> <span class="p">][</span> <span class="n">mask</span> <span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_widths</span><span class="p">[</span> <span class="n">iR</span> <span class="p">]</span>

        <span class="c1"># Compute the denominator</span>
        <span class="n">DEN</span> <span class="o">=</span> <span class="n">ERp</span> <span class="o">-</span> <span class="n">Ein</span> <span class="o">-</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Gtots</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span>

        <span class="c1"># Compute U itself.  Can we accelerate this with numpy routines?</span>
        <span class="k">for</span> <span class="n">i1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span> <span class="p">):</span>
            <span class="k">for</span> <span class="n">i2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">i1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span> <span class="p">):</span>
                <span class="n">U</span><span class="p">[:,</span><span class="n">i1</span><span class="p">,</span><span class="n">i2</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="n">sqrtGam</span><span class="p">[:,</span><span class="n">i1</span><span class="p">,:]</span> <span class="o">*</span> <span class="n">sqrtGam</span><span class="p">[:,</span><span class="n">i2</span><span class="p">,:]</span> <span class="o">/</span> <span class="n">DEN</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span> <span class="p">)</span>
                <span class="n">U</span><span class="p">[:,</span><span class="n">i1</span><span class="p">,</span><span class="n">i2</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span><span class="n">eiphis</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span> <span class="o">*</span> <span class="n">eiphis</span><span class="p">[</span><span class="n">i2</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                <span class="n">U</span><span class="p">[:,</span><span class="n">i2</span><span class="p">,</span><span class="n">i1</span><span class="p">]</span> <span class="o">=</span> <span class="n">U</span><span class="p">[:,</span><span class="n">i1</span><span class="p">,</span><span class="n">i2</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">U</span></div>

    <span class="nd">@blockwise</span>
<div class="viewcode-block" id="MLBWcrossSection.getCrossSection"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.MLBWcrossSection.getCrossSection">[docs]</a>    <span class="k">def</span> <span class="nf">getCrossSection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">):</span>
        <span class="n">captureSum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">elasticSum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">fissionSum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
        <span class="c1"># for phi:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">scatteringRadius</span><span class="o">.</span><span class="n">isEnergyDependent</span><span class="p">():</span>
            <span class="n">rhohat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">scatteringRadius</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s1">&#39;10*fm&#39;</span><span class="p">,</span> <span class="n">E</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]))[:,</span><span class="n">numpy</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rhohat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">scatteringRadius</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s1">&#39;10*fm&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ls</span><span class="p">:</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="s1">&#39;L&#39;</span><span class="p">]</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">rhohat</span><span class="p">)</span>
            <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactor</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">rho</span><span class="p">)</span>
            <span class="n">S</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">shiftFactor</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">rho</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">J</span> <span class="ow">in</span> <span class="n">L</span><span class="p">[</span><span class="s1">&#39;Js&#39;</span><span class="p">]:</span>
                <span class="n">gfactor</span> <span class="o">=</span> <span class="n">J</span><span class="p">[</span><span class="s1">&#39;gfact&#39;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">spin</span> <span class="ow">in</span> <span class="n">J</span><span class="p">[</span><span class="s1">&#39;channelSpins&#39;</span><span class="p">]:</span>
                    <span class="n">dE</span> <span class="o">=</span> <span class="p">(</span><span class="n">E</span><span class="o">-</span><span class="p">(</span><span class="n">spin</span><span class="p">[</span><span class="s1">&#39;energy&#39;</span><span class="p">]</span><span class="o">+</span><span class="n">spin</span><span class="p">[</span><span class="s1">&#39;neutronWidth&#39;</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">spin</span><span class="p">[</span><span class="s1">&#39;shiftFactor&#39;</span><span class="p">]</span><span class="o">-</span><span class="n">S</span><span class="p">)))</span>
                    <span class="n">totalWidth</span> <span class="o">=</span> <span class="n">P</span><span class="o">*</span><span class="n">spin</span><span class="p">[</span><span class="s1">&#39;neutronWidth&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">spin</span><span class="p">[</span><span class="s1">&#39;captureWidth&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">spin</span><span class="p">[</span><span class="s1">&#39;fissionWidth&#39;</span><span class="p">]</span>
                    <span class="n">denominator</span> <span class="o">=</span> <span class="n">dE</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">totalWidth</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="mi">4</span>
                    <span class="n">commonFactor</span> <span class="o">=</span> <span class="n">P</span> <span class="o">*</span> <span class="n">spin</span><span class="p">[</span><span class="s1">&#39;neutronWidth&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">denominator</span>
                    <span class="n">captureSum</span> <span class="o">+=</span> <span class="n">gfactor</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="n">commonFactor</span> <span class="o">*</span> <span class="n">spin</span><span class="p">[</span><span class="s1">&#39;captureWidth&#39;</span><span class="p">]</span> <span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">fissionSum</span> <span class="o">+=</span> <span class="n">gfactor</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="n">commonFactor</span> <span class="o">*</span> <span class="n">spin</span><span class="p">[</span><span class="s1">&#39;fissionWidth&#39;</span><span class="p">]</span> <span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

                    <span class="c1"># simple elastic method, Eq D.19 - D.21 in ENDF 102. This has numerical issues, however:</span>
                    <span class="c1"># U_nn = numpy.exp(-2*1j*phi[:,0]) * (1 + numpy.sum( 1j*P*spin[&#39;neutronWidth&#39;] /</span>
                    <span class="c1">#     (spin[&#39;energy&#39;]-E-1j*totalWidth/2) , axis=1))</span>
                    <span class="c1"># elasticSum += gfactor * abs( (1-U_nn)**2 )</span>

                    <span class="c1"># Instead of the above, use the following from RECENT:</span>
                    <span class="n">elasticTerm1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="n">totalWidth</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="n">commonFactor</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span> <span class="p">)</span>
                    <span class="n">elasticTerm2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="n">dE</span> <span class="o">*</span> <span class="n">commonFactor</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span> <span class="p">)</span>
                    <span class="n">sin2ps</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">sinps2</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span>
                    <span class="n">elasticSum</span> <span class="o">+=</span> <span class="n">gfactor</span> <span class="o">*</span> <span class="p">((</span><span class="n">sinps2</span><span class="o">-</span><span class="n">elasticTerm1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">sin2ps</span><span class="o">+</span><span class="n">elasticTerm2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">if</span> <span class="kc">True</span><span class="p">:</span> <span class="c1">#addMissingGfactor:</span>
                <span class="n">elasticSum</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">missingGfactor</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>

        <span class="c1"># get common factor &#39;beta&#39; as a row vector:</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">(</span><span class="n">E</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">capture</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">captureSum</span>
        <span class="n">elastic</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">elasticSum</span>
        <span class="n">fission</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">fissionSum</span>
        <span class="k">for</span> <span class="n">reaction</span> <span class="ow">in</span> <span class="p">(</span><span class="n">capture</span><span class="p">,</span><span class="n">elastic</span><span class="p">,</span><span class="n">fission</span><span class="p">):</span>
            <span class="n">reaction</span><span class="p">[</span> <span class="n">reaction</span><span class="o">&lt;=</span><span class="mi">0</span> <span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">total</span> <span class="o">=</span> <span class="n">elastic</span> <span class="o">+</span> <span class="n">capture</span> <span class="o">+</span> <span class="n">fission</span>
        <span class="n">nonelastic</span> <span class="o">=</span> <span class="n">capture</span> <span class="o">+</span> <span class="n">fission</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;total&#39;</span><span class="p">:</span><span class="n">total</span><span class="p">,</span> <span class="s1">&#39;elastic&#39;</span><span class="p">:</span><span class="n">elastic</span><span class="p">,</span> <span class="s1">&#39;capture&#39;</span><span class="p">:</span><span class="n">capture</span><span class="p">,</span> <span class="s1">&#39;fission&#39;</span><span class="p">:</span><span class="n">fission</span><span class="p">,</span> <span class="s1">&#39;nonelastic&#39;</span><span class="p">:</span><span class="n">nonelastic</span><span class="p">}</span></div></div>


<span class="c1">###### Reich_Moore and R-Matrix Limited ######</span>

<span class="c1"># some helper functions:</span>

<div class="viewcode-block" id="getR_S"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.getR_S">[docs]</a><span class="k">def</span> <span class="nf">getR_S</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">Eres</span><span class="p">,</span> <span class="n">captureWidth</span><span class="p">,</span> <span class="n">widths</span><span class="p">,</span> <span class="n">penetrabilities</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Both versions of Reich_Moore formalisms (LRF=3 and 7) rely on building the complex matrix &#39;R&#39;.</span>
<span class="sd">    Here we break it up into the real component R and the imaginary component S,</span>
<span class="sd">    which represent symmetric and anti-symmetric scattering respectively</span>

<span class="sd">    matrix elements R[i,j] and S[i,j] =</span>

<span class="sd">    (summed over resonances) partialWidth[i]*partialWidth[j] * coefficient/(dE**2+captureWidth**2),</span>

<span class="sd">    for the ith/jth open channel. For S, the coefficient is &#39;dE&#39;, for R &#39;captureWidth&#39;</span>
<span class="sd">    and partialWidth[i] = widths[i] * penetrabilities[i]</span>

<span class="sd">        ( widths[i] is a row vector of resonance widths, and penetrabilities[i] is a column vector</span>
<span class="sd">        of the penetrability for each incident energy )</span>

<span class="sd">    After computing R and S, invert using invertMatrices to find RI and SI such that (I+R+jS)*(I+RI+jSI) = I</span>
<span class="sd">    where I is the identity matrix, and j = sqrt(-1)</span>

<span class="sd">    Incident energy dependence appears in both in E and the penetrabilities</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">NE</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>         <span class="c1"># number of energies</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">widths</span><span class="p">)</span>   <span class="c1"># dimension of matrix at each energy</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># use wrapped c version if available:</span>
        <span class="kn">import</span> <span class="nn">getScatteringMatrices</span>
        <span class="c1"># convert any constant width/penetrability data to array w/correct dimensions:</span>
        <span class="n">nRes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Eres</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">widths</span><span class="p">[</span><span class="n">i1</span><span class="p">])</span> <span class="o">!=</span> <span class="n">nRes</span><span class="p">:</span>
                <span class="n">widths</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">nRes</span><span class="p">))</span> <span class="o">*</span> <span class="n">widths</span><span class="p">[</span><span class="n">i1</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">penetrabilities</span><span class="p">[</span><span class="n">i1</span><span class="p">])</span> <span class="o">!=</span> <span class="n">NE</span><span class="p">:</span>
                <span class="n">penetrabilities</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">NE</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">penetrabilities</span><span class="p">[</span><span class="n">i1</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">R</span><span class="p">,</span> <span class="n">S</span> <span class="o">=</span> <span class="n">getScatteringMatrices</span><span class="o">.</span><span class="n">getScatteringMatrices</span><span class="p">(</span> <span class="n">E</span><span class="p">,</span> <span class="n">Eres</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">captureWidth</span><span class="p">,</span>
                <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">widths</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">penetrabilities</span><span class="p">)</span> <span class="p">)</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="c1"># can&#39;t import c version, so use numpy (memory-intensive)</span>
        <span class="c1"># define some common factors.</span>
        <span class="c1"># These are all 2d arrays with len(E) rows, len(Eres) columns:</span>
        <span class="n">dE</span> <span class="o">=</span> <span class="n">Eres</span> <span class="o">-</span> <span class="n">E</span>
        <span class="n">DEN</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">dE</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">captureWidth</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">captOverDEN</span> <span class="o">=</span> <span class="n">captureWidth</span><span class="o">*</span><span class="n">DEN</span>
        <span class="n">dEoverDEN</span> <span class="o">=</span> <span class="n">dE</span><span class="o">*</span><span class="n">DEN</span>
        <span class="k">del</span> <span class="n">dE</span><span class="p">,</span> <span class="n">DEN</span>

        <span class="n">R</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">NE</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">dim</span><span class="p">))</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">NE</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">dim</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">dim</span><span class="p">):</span>
                <span class="n">width_ij</span> <span class="o">=</span> <span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">widths</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">p_ij</span> <span class="o">=</span> <span class="n">penetrabilities</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">penetrabilities</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">R</span><span class="p">[:,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_ij</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="n">width_ij</span> <span class="o">*</span> <span class="n">captOverDEN</span> <span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">S</span><span class="p">[:,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_ij</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="n">width_ij</span> <span class="o">*</span> <span class="n">dEoverDEN</span> <span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="c1"># symmetrize:</span>
                <span class="n">R</span><span class="p">[:,</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">R</span><span class="p">[:,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
                <span class="n">S</span><span class="p">[:,</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="p">[:,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">captOverDEN</span><span class="p">,</span> <span class="n">dEoverDEN</span>

    <span class="k">return</span> <span class="n">R</span><span class="p">,</span><span class="n">S</span></div>


<div class="viewcode-block" id="invertMatrices"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.invertMatrices">[docs]</a><span class="k">def</span> <span class="nf">invertMatrices</span><span class="p">(</span> <span class="n">R</span><span class="p">,</span> <span class="n">S</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    find RI and SI such that (I+R+jS)*(I+RI+jSI) = I,</span>
<span class="sd">    where I is the identity matrix, and j = sqrt(-1)</span>

<span class="sd">    for more info, see comments for subroutine FROBNS3 in recent.f</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">R</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">S</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">NE</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">dim</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">shape</span>

    <span class="k">if</span> <span class="n">dim</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="c1"># only have neutron width (and &#39;eliminated&#39; capture width).</span>
        <span class="c1"># Can obtain quicker solution by manually inverting:</span>
        <span class="n">DET</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">S</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">SI</span> <span class="o">=</span> <span class="o">-</span><span class="n">S</span><span class="o">/</span><span class="n">DET</span>
        <span class="n">RI</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">R</span><span class="o">*</span><span class="p">(</span><span class="n">R</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">DET</span>
        <span class="k">return</span> <span class="n">RI</span><span class="p">,</span><span class="n">SI</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># have competition and/or fission, must invert matrices:</span>
        <span class="k">def</span> <span class="nf">dotproduct</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
            <span class="c1"># helper function: dotproduct(A,B,C) == numpy.dot(A, numpy.dot(B,C))</span>
            <span class="k">def</span> <span class="nf">quickdot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
                <span class="c1"># take dot product of two Nx(MxM) arrays (containing MxM matrices):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span> <span class="p">)</span>
                <span class="n">dim</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
                        <span class="n">result</span><span class="p">[:,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="n">a</span><span class="p">[:,</span><span class="n">i</span><span class="p">,:]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[:,:,</span><span class="n">j</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span> <span class="p">)</span>
                <span class="k">return</span> <span class="n">result</span>
            <span class="k">return</span> <span class="n">reduce</span><span class="p">(</span> <span class="n">quickdot</span><span class="p">,</span> <span class="n">args</span> <span class="p">)</span>

        <span class="k">def</span> <span class="nf">vectorInv</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
            <span class="c1"># invert all MxM matrices in Nx(MxM) array</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">dim</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                <span class="n">arrinv</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="n">det</span> <span class="o">=</span> <span class="p">(</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">arrinv</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">det</span>
                <span class="n">arrinv</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">det</span>
                <span class="n">arrinv</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">det</span>
                <span class="n">arrinv</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">det</span>
                <span class="k">return</span> <span class="n">arrinv</span>
            <span class="k">elif</span> <span class="n">dim</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
                <span class="n">arrinv</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="n">det</span> <span class="o">=</span> <span class="p">(</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
                    <span class="o">-</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
                    <span class="o">+</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span> <span class="p">)</span>
                <span class="n">arrinv</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">det</span>
                <span class="n">arrinv</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">det</span>
                <span class="n">arrinv</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">det</span>
                <span class="n">arrinv</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">det</span>
                <span class="n">arrinv</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="n">det</span>
                <span class="n">arrinv</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">det</span>
                <span class="n">arrinv</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="n">det</span>
                <span class="n">arrinv</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">det</span>
                <span class="n">arrinv</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="n">det</span>
                <span class="k">return</span> <span class="n">arrinv</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span> <span class="p">)</span>
                <span class="n">NE</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NE</span><span class="p">):</span>
                    <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">return</span> <span class="n">result</span>

        <span class="n">identity</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="n">NE</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
            <span class="n">identity</span><span class="p">[:,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">invRplusI</span> <span class="o">=</span> <span class="n">vectorInv</span><span class="p">(</span> <span class="n">R</span> <span class="o">+</span> <span class="n">identity</span> <span class="p">)</span>
        <span class="n">SRS</span> <span class="o">=</span> <span class="n">dotproduct</span><span class="p">(</span> <span class="n">S</span><span class="p">,</span> <span class="n">invRplusI</span><span class="p">,</span> <span class="n">S</span> <span class="p">)</span>
        <span class="n">RI</span> <span class="o">=</span> <span class="n">dotproduct</span><span class="p">(</span> <span class="o">-</span><span class="n">vectorInv</span><span class="p">(</span> <span class="n">R</span><span class="o">+</span><span class="n">identity</span> <span class="o">+</span> <span class="n">SRS</span> <span class="p">),</span> <span class="n">R</span><span class="o">+</span><span class="n">SRS</span> <span class="p">)</span>
        <span class="n">SI</span> <span class="o">=</span> <span class="n">dotproduct</span><span class="p">(</span> <span class="o">-</span><span class="n">invRplusI</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">RI</span><span class="o">+</span><span class="n">identity</span> <span class="p">)</span>
        <span class="k">return</span> <span class="n">RI</span><span class="p">,</span> <span class="n">SI</span></div>


<span class="c1">#### Reich_Moore ####</span>
<div class="viewcode-block" id="RMcrossSection"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RMcrossSection">[docs]</a><span class="k">class</span> <span class="nc">RMcrossSection</span><span class="p">(</span><span class="n">RRBaseClass</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    simplified Reich_Moore (LRF=3 in ENDF)</span>
<span class="sd">    More complex than Breit-Wigner approximations, but we can still use same __init__</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reactionSuite</span><span class="p">,</span> <span class="n">sectionIndex</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">enableAngDists</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">RMcrossSection</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">reactionSuite</span><span class="p">,</span> <span class="n">sectionIndex</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sortLandJ</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;From </span><span class="si">%f</span><span class="s2"> to </span><span class="si">%f</span><span class="s2"> </span><span class="si">%s</span><span class="s2">, reconstructing using Reich_Moore (LRF=3)&quot;</span> <span class="o">%</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lowerBound</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">upperBound</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">enableAngDists</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">setResonanceParametersByChannel</span><span class="p">(</span> <span class="n">useReichMooreApproximation</span> <span class="o">=</span> <span class="kc">True</span> <span class="p">)</span>

<div class="viewcode-block" id="RMcrossSection.getChannelConstantsBc"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RMcrossSection.getChannelConstantsBc">[docs]</a>    <span class="k">def</span> <span class="nf">getChannelConstantsBc</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For ENDF&#39;s Reich-Moore, should be</span>

<span class="sd">            ..math::</span>
<span class="sd">                B_c = -\ell</span>

<span class="sd">        where $ell$ is the channel angular momentum</span>

<span class="sd">        what is not clearly stated in the ENDF manual is that Bc = 0 for this case</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span> <span class="mf">0.0</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="p">]</span></div>

<div class="viewcode-block" id="RMcrossSection.getL0Matrix"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RMcrossSection.getL0Matrix">[docs]</a>    <span class="k">def</span> <span class="nf">getL0Matrix</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">Ein</span><span class="p">,</span> <span class="n">Bc</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the L0 matrix of Froehner:</span>

<span class="sd">            ..math::</span>

<span class="sd">                {\bf L^0}_{cc&#39;} = \delta_{cc&#39;} (L_c-B_c)</span>

<span class="sd">        where</span>

<span class="sd">            ..math::</span>

<span class="sd">                L_c = S_c + i P_c</span>

<span class="sd">        But.... ENDF&#39;s RM formulation uses a shift of 0 and a Bc of 0!!!</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">L0</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Ein</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">ic</span><span class="p">,</span><span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">):</span>
            <span class="n">L0</span><span class="p">[:,</span><span class="n">ic</span><span class="p">,</span><span class="n">ic</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactor</span><span class="p">(</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span> <span class="n">Ein</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span> <span class="p">)</span> <span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">L0</span></div>

<div class="viewcode-block" id="RMcrossSection.getRMatrix"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RMcrossSection.getRMatrix">[docs]</a>    <span class="k">def</span> <span class="nf">getRMatrix</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">Ein</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The R matrix in the Reich-Moore approximation,</span>
<span class="sd">        :math:`R_{cc&#39;} = \sum_\lambda \frac{\gamma_{\lambda c}\gamma_{\lambda c&#39;}{E_\lambda - E - i\Gamma_{\lambda\gamma}/2}`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">R</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Ein</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span> <span class="p">)</span>

        <span class="c1"># Loop through all resonances</span>
        <span class="k">for</span> <span class="n">iR</span><span class="p">,</span> <span class="n">ER</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_energies</span> <span class="p">):</span>

            <span class="c1"># Extract the gamma width for the first gamma channel that has this resonance</span>
            <span class="n">gamWidth</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">cg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">eliminatedChannels</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">iR</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">eliminatedChannels</span><span class="p">[</span> <span class="n">cg</span> <span class="p">]:</span>
                    <span class="n">gamWidth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eliminatedChannels</span><span class="p">[</span> <span class="n">cg</span> <span class="p">][</span> <span class="n">iR</span> <span class="p">]</span>
                    <span class="k">if</span> <span class="n">gamWidth</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span> <span class="k">break</span>
            <span class="k">if</span> <span class="n">gamWidth</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="nb">print</span> <span class="bp">self</span><span class="o">.</span><span class="n">eliminatedChannels</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t find gamma for resonance at ER = </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ER</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span><span class="p">))</span>

            <span class="c1"># Precompute the reduced widths</span>
            <span class="n">redWidth</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">iR</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span> <span class="n">c</span> <span class="p">]:</span>
                    <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">reaction</span> <span class="o">==</span> <span class="s1">&#39;elastic&#39;</span><span class="p">:</span> <span class="n">pen</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactor</span><span class="p">(</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span> <span class="nb">abs</span><span class="p">(</span> <span class="n">ER</span> <span class="p">),</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span> <span class="p">)</span> <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>                       <span class="n">pen</span> <span class="o">=</span> <span class="mf">1.0</span>
                    <span class="n">redWidth</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">copysign</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="nb">abs</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span> <span class="n">c</span> <span class="p">][</span> <span class="n">iR</span> <span class="p">]</span> <span class="p">)</span> <span class="o">/</span>
                        <span class="p">(</span> <span class="mf">2.0</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span> <span class="n">pen</span> <span class="p">)</span> <span class="p">)</span> <span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span> <span class="n">c</span> <span class="p">][</span> <span class="n">iR</span> <span class="p">]</span> <span class="p">)</span> <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span> <span class="n">redWidth</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="mf">0.0</span> <span class="p">)</span>

            <span class="c1"># Loop through all channels to accumulate the R Matrix elements</span>
            <span class="k">for</span> <span class="n">ic1</span><span class="p">,</span> <span class="n">c1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">iR</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span> <span class="n">c1</span> <span class="p">]:</span> <span class="k">continue</span>
                <span class="k">for</span> <span class="n">ic2</span><span class="p">,</span> <span class="n">c2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="p">):</span>
                    <span class="k">if</span> <span class="n">ic2</span> <span class="o">&gt;</span> <span class="n">ic1</span><span class="p">:</span> <span class="k">break</span>     <span class="c1"># matrix is symmetric</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">iR</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span> <span class="n">c2</span> <span class="p">]:</span> <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">ER</span><span class="o">-</span><span class="n">Ein</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">)</span> <span class="ow">and</span> <span class="n">gamWidth</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span> <span class="s1">&#39;yikes! </span><span class="si">%s</span><span class="s1">  vs.  </span><span class="si">%s</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">c1</span><span class="p">),</span><span class="nb">str</span><span class="p">(</span><span class="n">c2</span><span class="p">)))</span>
                    <span class="n">dR</span> <span class="o">=</span> <span class="p">(</span><span class="n">redWidth</span><span class="p">[</span> <span class="n">ic1</span> <span class="p">]</span> <span class="o">*</span> <span class="n">redWidth</span><span class="p">[</span> <span class="n">ic2</span> <span class="p">]</span> <span class="o">/</span> <span class="p">(</span> <span class="n">ER</span><span class="o">-</span><span class="n">Ein</span> <span class="o">-</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">gamWidth</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="p">))</span>
                    <span class="n">R</span><span class="p">[:,</span> <span class="n">ic1</span><span class="p">,</span> <span class="n">ic2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dR</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">ic1</span> <span class="o">!=</span> <span class="n">ic2</span><span class="p">:</span>
                        <span class="n">R</span><span class="p">[:,</span> <span class="n">ic2</span><span class="p">,</span> <span class="n">ic1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dR</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">R</span></div>

    <span class="nd">@blockwise</span>
<div class="viewcode-block" id="RMcrossSection.getCrossSection"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RMcrossSection.getCrossSection">[docs]</a>    <span class="k">def</span> <span class="nf">getCrossSection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">):</span>
        <span class="n">elasticSum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">absorbtionSum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">fissionSum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">haveFission</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">resonanceParameters</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">getColumn</span><span class="p">(</span><span class="s1">&#39;fissionWidth&#39;</span><span class="p">,</span><span class="n">unit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="c1"># for calculating phi, always use tabulated scattering radius:</span>
        <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ls</span><span class="p">:</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="s1">&#39;L&#39;</span><span class="p">]</span>
            <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span><span class="n">E</span><span class="p">,</span><span class="n">l</span><span class="p">)</span>
            <span class="n">rhohat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">scatteringRadius</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s1">&#39;10*fm&#39;</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="n">l</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">rhohat</span><span class="p">)</span>
            <span class="n">P</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactor</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">rho</span><span class="p">)</span> <span class="p">)</span>

            <span class="k">for</span> <span class="n">J</span> <span class="ow">in</span> <span class="n">L</span><span class="p">[</span><span class="s1">&#39;Js&#39;</span><span class="p">]:</span>
                <span class="n">gfactor</span> <span class="o">=</span> <span class="n">J</span><span class="p">[</span><span class="s1">&#39;gfact&#39;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">spin</span> <span class="ow">in</span> <span class="n">J</span><span class="p">[</span><span class="s1">&#39;channelSpins&#39;</span><span class="p">]:</span>
                    <span class="n">captureWidth</span> <span class="o">=</span> <span class="n">spin</span><span class="p">[</span><span class="s1">&#39;captureWidth&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.5</span>
                    <span class="n">widths</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">penetrabilities</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="c1"># FIXME note that spin[&#39;neutronWidth&#39;] already includes the penetrablity (calculated at resonances)</span>
                    <span class="c1"># That got wrapped in during sortLandJ, but may wish to move it back to here for readability</span>
                    <span class="n">widths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="n">spin</span><span class="p">[</span><span class="s1">&#39;neutronWidth&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="p">)</span> <span class="p">)</span>
                    <span class="n">penetrabilities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">haveFission</span><span class="p">:</span>
                        <span class="n">fissWidthA</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">spin</span><span class="p">[</span><span class="s1">&#39;fissionWidth&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">))</span>
                        <span class="n">fissWidthB</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">spin</span><span class="p">[</span><span class="s1">&#39;fissionWidthB&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">))</span>
                        <span class="n">fissWidthA</span><span class="p">[</span> <span class="n">spin</span><span class="p">[</span><span class="s1">&#39;fissionWidth&#39;</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">0</span> <span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
                        <span class="n">fissWidthB</span><span class="p">[</span> <span class="n">spin</span><span class="p">[</span><span class="s1">&#39;fissionWidthB&#39;</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">0</span> <span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
                        <span class="n">widths</span> <span class="o">+=</span> <span class="p">[</span><span class="n">fissWidthA</span><span class="p">,</span> <span class="n">fissWidthB</span><span class="p">]</span>
                        <span class="n">penetrabilities</span> <span class="o">+=</span> <span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">]]),</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">]])]</span>

                        <span class="n">RI</span><span class="p">,</span><span class="n">SI</span> <span class="o">=</span> <span class="n">invertMatrices</span><span class="p">(</span>
                                <span class="o">*</span><span class="n">getR_S</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">spin</span><span class="p">[</span><span class="s1">&#39;energy&#39;</span><span class="p">],</span> <span class="n">captureWidth</span><span class="p">,</span> <span class="n">widths</span><span class="p">,</span> <span class="n">penetrabilities</span><span class="p">)</span>
                                <span class="p">)</span>

                        <span class="n">elasticSum</span> <span class="o">+=</span> <span class="n">gfactor</span> <span class="o">*</span> <span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">RI</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
                                <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">SI</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                        <span class="n">absorbtionSum</span> <span class="o">+=</span> <span class="o">-</span><span class="mi">4</span><span class="o">*</span><span class="n">gfactor</span> <span class="o">*</span> <span class="p">(</span><span class="n">RI</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">RI</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">SI</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                        <span class="n">fissionSum</span> <span class="o">+=</span> <span class="mi">4</span><span class="o">*</span><span class="n">gfactor</span> <span class="o">*</span> <span class="p">(</span><span class="n">RI</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">RI</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">SI</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">SI</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

                    <span class="k">else</span><span class="p">:</span> <span class="c1"># faster method when we don&#39;t have fission:</span>
                        <span class="n">RI</span><span class="p">,</span> <span class="n">SI</span> <span class="o">=</span> <span class="n">invertMatrices</span><span class="p">(</span>
                                <span class="o">*</span><span class="n">getR_S</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">spin</span><span class="p">[</span><span class="s1">&#39;energy&#39;</span><span class="p">],</span> <span class="n">captureWidth</span><span class="p">,</span> <span class="n">widths</span><span class="p">,</span> <span class="n">penetrabilities</span><span class="p">)</span>
                                <span class="p">)</span>
                        <span class="n">RI</span><span class="p">,</span> <span class="n">SI</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">RI</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">SI</span><span class="p">)</span>
                        <span class="n">elasticSum</span> <span class="o">+=</span> <span class="n">gfactor</span> <span class="o">*</span> <span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">RI</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
                                <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">SI</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                        <span class="n">absorbtionSum</span> <span class="o">+=</span> <span class="o">-</span><span class="mi">4</span><span class="o">*</span><span class="n">gfactor</span> <span class="o">*</span> <span class="p">(</span><span class="n">RI</span> <span class="o">+</span> <span class="n">RI</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">SI</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

            <span class="k">if</span> <span class="kc">True</span><span class="p">:</span> <span class="c1">#addMissingGfactor:</span>
                <span class="n">elasticSum</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">missingGfactor</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>

        <span class="c1"># get common factor &#39;beta&#39; as a row vector:</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">(</span><span class="n">E</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">elastic</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">elasticSum</span>
        <span class="n">absorbtion</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">absorbtionSum</span>
        <span class="n">fission</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">fissionSum</span>
        <span class="n">capture</span> <span class="o">=</span> <span class="n">absorbtion</span> <span class="o">-</span> <span class="n">fission</span>
        <span class="n">total</span> <span class="o">=</span> <span class="n">elastic</span> <span class="o">+</span> <span class="n">absorbtion</span>

        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;total&#39;</span><span class="p">:</span><span class="n">total</span><span class="p">,</span> <span class="s1">&#39;elastic&#39;</span><span class="p">:</span><span class="n">elastic</span><span class="p">,</span> <span class="s1">&#39;capture&#39;</span><span class="p">:</span><span class="n">capture</span><span class="p">,</span> <span class="s1">&#39;fission&#39;</span><span class="p">:</span><span class="n">fission</span><span class="p">,</span> <span class="s1">&#39;nonelastic&#39;</span><span class="p">:</span><span class="n">absorbtion</span><span class="p">}</span></div></div>


<span class="c1">#### R-Matrix Limited ####</span>
<div class="viewcode-block" id="RMatrixLimitedcrossSection"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RMatrixLimitedcrossSection">[docs]</a><span class="k">class</span> <span class="nc">RMatrixLimitedcrossSection</span><span class="p">(</span><span class="n">RRBaseClass</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    extended Reich_Moore (LRF=7 in ENDF)</span>
<span class="sd">    Here, resonances are sorted primarily by J: within each &#39;spin group&#39;, total J is conserved</span>
<span class="sd">    One or more competitive channels may be used in this case.</span>
<span class="sd">    Also, each resonance may have contributions from multiple l-waves</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reactionSuite</span><span class="p">,</span> <span class="n">sectionIndex</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">enableAngDists</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">RMatrixLimitedcrossSection</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">reactionSuite</span><span class="p">,</span> <span class="n">sectionIndex</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;From </span><span class="si">%f</span><span class="s2"> to </span><span class="si">%f</span><span class="s2"> </span><span class="si">%s</span><span class="s2">, reconstructing using R-Matrix Limited (LRF=7)&quot;</span> <span class="o">%</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lowerBound</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">upperBound</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span><span class="p">))</span>

        <span class="c1"># for RML, need to know what residual nuclei are produced by each channel:</span>
        <span class="n">thresholds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">rreac</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">resonanceReactions</span><span class="p">:</span>
            <span class="n">reaction</span> <span class="o">=</span> <span class="n">rreac</span><span class="o">.</span><span class="n">reactionLink</span><span class="o">.</span><span class="n">link</span>
            <span class="c1"># elastic, capture or competitive?</span>
            <span class="k">if</span> <span class="n">reaction</span> <span class="o">==</span> <span class="n">reactionSuite</span><span class="o">.</span><span class="n">getReaction</span><span class="p">(</span><span class="s1">&#39;capture&#39;</span><span class="p">):</span> <span class="n">rreac</span><span class="o">.</span><span class="n">tag</span> <span class="o">=</span> <span class="s1">&#39;capture&#39;</span>
            <span class="k">elif</span> <span class="n">reaction</span> <span class="o">==</span> <span class="n">reactionSuite</span><span class="o">.</span><span class="n">getReaction</span><span class="p">(</span><span class="s1">&#39;elastic&#39;</span><span class="p">):</span> <span class="n">rreac</span><span class="o">.</span><span class="n">tag</span> <span class="o">=</span> <span class="s1">&#39;elastic&#39;</span>
            <span class="k">elif</span> <span class="s1">&#39;fission&#39;</span> <span class="ow">in</span> <span class="n">rreac</span><span class="o">.</span><span class="n">label</span><span class="p">:</span> <span class="n">rreac</span><span class="o">.</span><span class="n">tag</span> <span class="o">=</span> <span class="n">rreac</span><span class="o">.</span><span class="n">label</span>
            <span class="k">else</span><span class="p">:</span> <span class="n">rreac</span><span class="o">.</span><span class="n">tag</span> <span class="o">=</span> <span class="s1">&#39;competitive&#39;</span>

            <span class="k">if</span> <span class="n">rreac</span><span class="o">.</span><span class="n">Q</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">Q</span> <span class="o">=</span> <span class="n">rreac</span><span class="o">.</span><span class="n">Q</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Q</span> <span class="o">=</span> <span class="n">reaction</span><span class="o">.</span><span class="n">getQ</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span><span class="p">)</span>
            <span class="c1"># adjust Q value for residual in excited state:</span>
            <span class="k">for</span> <span class="n">particle</span> <span class="ow">in</span> <span class="n">reaction</span><span class="o">.</span><span class="n">outputChannel</span><span class="o">.</span><span class="n">products</span><span class="p">:</span>
                <span class="k">if</span><span class="p">(</span> <span class="nb">hasattr</span><span class="p">(</span> <span class="n">particle</span><span class="p">,</span> <span class="s1">&#39;getLevelAsFloat&#39;</span> <span class="p">)</span> <span class="p">)</span> <span class="p">:</span> <span class="n">Q</span> <span class="o">-=</span> <span class="n">particle</span><span class="o">.</span><span class="n">getLevelAsFloat</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span> <span class="p">)</span>
            <span class="c1"># Xi = reaction threshold in the lab frame.</span>
            <span class="n">targetToProjectileMassRatio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">targetMass_amu</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">projectileMass_amu</span>
            <span class="n">Xi</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span> <span class="p">(</span><span class="n">targetToProjectileMassRatio</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">targetToProjectileMassRatio</span> <span class="p">)</span> <span class="o">*</span> <span class="n">Q</span>
            <span class="n">particles</span> <span class="o">=</span> <span class="n">reaction</span><span class="o">.</span><span class="n">outputChannel</span><span class="o">.</span><span class="n">products</span>
            <span class="n">rreac</span><span class="o">.</span><span class="n">reactionInfo</span> <span class="o">=</span> <span class="p">{</span> <span class="s1">&#39;Xi&#39;</span><span class="p">:</span><span class="n">Xi</span><span class="p">,</span> <span class="s1">&#39;particles&#39;</span><span class="p">:</span> <span class="n">particles</span> <span class="p">}</span>
            <span class="k">if</span> <span class="n">Xi</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">thresholds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Xi</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">sg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">spinGroups</span><span class="p">:</span>
            <span class="n">sg</span><span class="o">.</span><span class="n">energy</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">sg</span><span class="o">.</span><span class="n">resonanceParameters</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">getColumn</span><span class="p">(</span><span class="s1">&#39;energy&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span><span class="p">)</span> <span class="p">)</span>

            <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">sg</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
                <span class="n">resonanceReaction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">resonanceReactions</span><span class="p">[</span> <span class="n">channel</span><span class="o">.</span><span class="n">resonanceReaction</span> <span class="p">]</span>
                <span class="n">column</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">resonanceParameters</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span> <span class="n">channel</span><span class="o">.</span><span class="n">columnIndex</span> <span class="p">]</span>
                <span class="n">column</span><span class="o">.</span><span class="n">tag</span> <span class="o">=</span> <span class="n">resonanceReaction</span><span class="o">.</span><span class="n">tag</span>

        <span class="c1"># for energy grid generation:</span>
        <span class="n">energies</span><span class="p">,</span> <span class="n">totalWidths</span> <span class="o">=</span> <span class="p">[],[]</span>
        <span class="k">for</span> <span class="n">sg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">spinGroups</span><span class="p">:</span>
            <span class="n">energies</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span> <span class="n">sg</span><span class="o">.</span><span class="n">resonanceParameters</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">getColumn</span><span class="p">(</span><span class="s1">&#39;energy&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span><span class="p">)</span> <span class="p">)</span>
            <span class="n">widths</span> <span class="o">=</span> <span class="p">[</span><span class="n">sg</span><span class="o">.</span><span class="n">resonanceParameters</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">getColumn</span><span class="p">(</span> <span class="n">col</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span> <span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span>
                    <span class="n">sg</span><span class="o">.</span><span class="n">resonanceParameters</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="s1">&#39;energy&#39;</span><span class="p">]</span>
            <span class="n">totalWidths</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="n">widths</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span> <span class="p">)</span> <span class="p">)</span>
        <span class="n">zipped</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">energies</span><span class="p">,</span><span class="n">totalWidths</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_energies</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_widths</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">zipped</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_thresholds</span> <span class="o">=</span> <span class="n">thresholds</span>

        <span class="k">if</span> <span class="n">enableAngDists</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">setResonanceParametersByChannel</span><span class="p">()</span>

<div class="viewcode-block" id="RMatrixLimitedcrossSection.penetrationFactorByChannel"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RMatrixLimitedcrossSection.penetrationFactorByChannel">[docs]</a>    <span class="k">def</span> <span class="nf">penetrationFactorByChannel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">Ein</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">channelClass</span> <span class="ow">in</span> <span class="p">[</span><span class="n">FISSIONCHANNEL</span><span class="p">,</span> <span class="n">GAMMACHANNEL</span><span class="p">]:</span> <span class="k">return</span> <span class="mf">1.0</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span><span class="n">Ein</span><span class="o">-</span><span class="n">c</span><span class="o">.</span><span class="n">Xi</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">channelClass</span> <span class="o">==</span> <span class="n">CPCHANNEL</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">getCoulombWavefunctions</span>
            <span class="n">pA</span><span class="p">,</span> <span class="n">pB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">particlePairs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">reactionInfo</span><span class="p">[</span><span class="s1">&#39;particles&#39;</span><span class="p">]</span>
            <span class="n">eta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">(</span><span class="n">Ein</span><span class="o">-</span><span class="n">c</span><span class="o">.</span><span class="n">Xi</span><span class="p">,</span> <span class="n">pA</span><span class="p">,</span> <span class="n">pB</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">getCoulombWavefunctions</span><span class="o">.</span><span class="n">coulombPenetrationFactor</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span><span class="n">rho</span><span class="p">,</span><span class="n">eta</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactor</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="n">rho</span><span class="p">)</span></div>

<div class="viewcode-block" id="RMatrixLimitedcrossSection.phiByChannel"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RMatrixLimitedcrossSection.phiByChannel">[docs]</a>    <span class="k">def</span> <span class="nf">phiByChannel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">Ein</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">channelClass</span> <span class="ow">in</span> <span class="p">[</span><span class="n">FISSIONCHANNEL</span><span class="p">,</span> <span class="n">GAMMACHANNEL</span><span class="p">]:</span> <span class="k">return</span> <span class="mf">0.0</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rhohat</span><span class="p">(</span><span class="n">Ein</span><span class="o">-</span><span class="n">c</span><span class="o">.</span><span class="n">Xi</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">channelClass</span> <span class="o">==</span> <span class="n">CPCHANNEL</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">getCoulombWavefunctions</span>
            <span class="n">pA</span><span class="p">,</span> <span class="n">pB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">particlePairs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">reactionInfo</span><span class="p">[</span><span class="s1">&#39;particles&#39;</span><span class="p">]</span>
            <span class="n">eta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">(</span><span class="n">Ein</span><span class="o">-</span><span class="n">c</span><span class="o">.</span><span class="n">Xi</span><span class="p">,</span> <span class="n">pA</span><span class="p">,</span> <span class="n">pB</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">getCoulombWavefunctions</span><span class="o">.</span><span class="n">coulombPhi</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span><span class="n">rho</span><span class="p">,</span><span class="n">eta</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">(</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span><span class="n">Ein</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="p">)</span></div>

<div class="viewcode-block" id="RMatrixLimitedcrossSection.shiftFactorByChannel"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RMatrixLimitedcrossSection.shiftFactorByChannel">[docs]</a>    <span class="k">def</span> <span class="nf">shiftFactorByChannel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">Ein</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">channelClass</span> <span class="ow">in</span> <span class="p">[</span><span class="n">FISSIONCHANNEL</span><span class="p">,</span> <span class="n">GAMMACHANNEL</span><span class="p">]:</span> <span class="k">return</span> <span class="mf">0.0</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span><span class="n">Ein</span><span class="o">-</span><span class="n">c</span><span class="o">.</span><span class="n">Xi</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">channelClass</span> <span class="o">==</span> <span class="n">CPCHANNEL</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">getCoulombWavefunctions</span>
            <span class="n">pA</span><span class="p">,</span> <span class="n">pB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">particlePairs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">reactionInfo</span><span class="p">[</span><span class="s1">&#39;particles&#39;</span><span class="p">]</span>
            <span class="n">eta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">(</span><span class="n">Ein</span><span class="o">-</span><span class="n">c</span><span class="o">.</span><span class="n">Xi</span><span class="p">,</span> <span class="n">pA</span><span class="p">,</span> <span class="n">pB</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">getCoulombWavefunctions</span><span class="o">.</span><span class="n">coulombShiftFactor</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span><span class="n">rho</span><span class="p">,</span><span class="n">eta</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shiftFactor</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="n">rho</span><span class="p">)</span></div>

<div class="viewcode-block" id="RMatrixLimitedcrossSection.isElastic"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RMatrixLimitedcrossSection.isElastic">[docs]</a>    <span class="k">def</span> <span class="nf">isElastic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reactionDesignator</span><span class="p">):</span>
        <span class="n">rs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">getRootAncestor</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">rs</span><span class="o">.</span><span class="n">getReaction</span><span class="p">(</span><span class="n">reactionDesignator</span><span class="p">)</span> <span class="o">==</span> <span class="n">rs</span><span class="o">.</span><span class="n">getReaction</span><span class="p">(</span><span class="s1">&#39;elastic&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="RMatrixLimitedcrossSection.getLMax"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RMatrixLimitedcrossSection.getLMax">[docs]</a>    <span class="k">def</span> <span class="nf">getLMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maxLmax</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        LMax is determined by the behavior of the Blatt-Biedenharn Zbar coefficients.  Inside each one, there is</span>
<span class="sd">        a Racah coefficient and a Clebsh-Gordon coefficient.  The CG coefficient looks like this:</span>
<span class="sd">                ( l1 l2  L )</span>
<span class="sd">                (  0  0  0 )</span>
<span class="sd">        So, this means two things.  First, the CG coeff (and hence Zbar) will be zero if l1+l2+L=odd.</span>
<span class="sd">        Second, the maximum value of L will be l1max+l2max.  Hence, Lmax=2*lmax.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span> <span class="nb">max</span><span class="p">(</span> <span class="p">[</span> <span class="mi">2</span><span class="o">*</span><span class="n">c</span><span class="o">.</span><span class="n">l</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="p">]</span> <span class="p">),</span> <span class="n">maxLmax</span> <span class="p">)</span></div>

<div class="viewcode-block" id="RMatrixLimitedcrossSection.setResonanceParametersByChannel"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RMatrixLimitedcrossSection.setResonanceParametersByChannel">[docs]</a>    <span class="k">def</span> <span class="nf">setResonanceParametersByChannel</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">multipleSScheme</span><span class="o">=</span><span class="s1">&#39;ENDF&#39;</span><span class="p">,</span> <span class="n">useReichMooreApproximation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">Ein</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">warnOnly</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reorganize member data into channels</span>
<span class="sd">        :param multipleSScheme:  ignored, kept so has same signature as overridden function</span>
<span class="sd">        :param useReichMooreApproximation:  ignored, kept so has same signature as overridden function</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nResonances</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span> <span class="p">[</span> <span class="nb">len</span><span class="p">(</span> <span class="n">sg</span><span class="o">.</span><span class="n">resonanceParameters</span><span class="o">.</span><span class="n">table</span> <span class="p">)</span> <span class="k">for</span> <span class="n">sg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">spinGroups</span> <span class="p">]</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">JMax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span> <span class="p">[</span><span class="n">sg</span><span class="o">.</span><span class="n">spin</span> <span class="k">for</span> <span class="n">sg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">spinGroups</span><span class="p">]</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channelConstantsBc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">particlePairs</span><span class="o">=</span><span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scatteringRadiiTrue</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scatteringRadiiEffective</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">overrides</span><span class="o">=</span><span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">allowedSs</span> <span class="o">=</span> <span class="n">getAllowedTotalSpins</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">projectileSpin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">targetSpin</span><span class="p">,</span> <span class="n">useFactor2Trick</span><span class="o">=</span><span class="kc">False</span> <span class="p">)</span>
        <span class="n">warnings</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># The unified table of resonance parameter data</span>
        <span class="n">channelDict</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">def</span> <span class="nf">addOrUpdateDict</span><span class="p">(</span> <span class="n">theDict</span><span class="p">,</span> <span class="n">theKey</span><span class="p">,</span> <span class="n">theValue</span> <span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">theKey</span> <span class="ow">in</span> <span class="n">theDict</span><span class="p">:</span> <span class="n">theDict</span><span class="p">[</span> <span class="n">theKey</span> <span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">theDict</span><span class="p">[</span> <span class="n">theKey</span> <span class="p">][</span> <span class="n">theValue</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">]</span> <span class="o">=</span> <span class="n">theValue</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Pack the channels</span>
        <span class="n">channelIndex</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">sg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">spinGroups</span><span class="p">:</span>
            <span class="n">ERs</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">resonanceParameters</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">getColumn</span><span class="p">(</span> <span class="n">sg</span><span class="o">.</span><span class="n">resonanceParameters</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span> <span class="p">)</span>
            <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">sg</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
                <span class="n">pp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">resonanceReactions</span><span class="p">[</span> <span class="n">channel</span><span class="o">.</span><span class="n">resonanceReaction</span> <span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">eliminated</span> <span class="ow">or</span> <span class="n">pp</span><span class="o">.</span><span class="n">isFission</span><span class="p">()):</span>

                    <span class="n">Ia</span><span class="p">,</span> <span class="n">Ib</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getParticleSpins</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>

                    <span class="c1"># Check validity of channel spin</span>
                    <span class="k">if</span> <span class="n">channel</span><span class="o">.</span><span class="n">channelSpin</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">getAllowedTotalSpins</span><span class="p">(</span> <span class="n">Ia</span><span class="p">,</span> <span class="n">Ib</span><span class="p">,</span> <span class="n">useFactor2Trick</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
                        <span class="k">if</span> <span class="n">warnOnly</span><span class="p">:</span>
                            <span class="kn">from</span> <span class="nn">fudge.gnd</span> <span class="k">import</span> <span class="n">warning</span>
                            <span class="n">warnings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">warning</span><span class="o">.</span><span class="n">invalidSpinCombination</span><span class="p">(</span> <span class="n">Ia</span><span class="p">,</span> <span class="n">Ib</span><span class="p">,</span> <span class="n">channel</span><span class="o">.</span><span class="n">channelSpin</span><span class="p">,</span> <span class="n">channel</span><span class="o">.</span><span class="n">label</span><span class="p">))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span> <span class="s1">&#39;Invalid spin combination: cannot couple Ia = </span><span class="si">%s</span><span class="s1"> and Ib = </span><span class="si">%s</span><span class="s1"> up to S = </span><span class="si">%s</span><span class="s1"> for channel &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span>
                                    <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">Ia</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">Ib</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">channelSpin</span><span class="p">),</span> <span class="n">channel</span><span class="o">.</span><span class="n">label</span><span class="p">))</span>
                    <span class="c1"># Check the validity of total angular momenta</span>
                    <span class="k">if</span> <span class="n">sg</span><span class="o">.</span><span class="n">spin</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">getAllowedTotalSpins</span><span class="p">(</span> <span class="n">channel</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="n">channel</span><span class="o">.</span><span class="n">channelSpin</span><span class="p">,</span> <span class="n">useFactor2Trick</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
                        <span class="k">if</span> <span class="n">warnOnly</span><span class="p">:</span>
                            <span class="kn">from</span> <span class="nn">fudge.gnd</span> <span class="k">import</span> <span class="n">warning</span>
                            <span class="n">warnings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">warning</span><span class="o">.</span><span class="n">invalidAngularMomentaCombination</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="n">channel</span><span class="o">.</span><span class="n">channelSpin</span><span class="p">,</span> <span class="n">sg</span><span class="o">.</span><span class="n">spin</span><span class="p">,</span> <span class="n">channel</span><span class="o">.</span><span class="n">label</span><span class="p">))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span> <span class="s1">&#39;Invalid spin combination: cannot couple L = </span><span class="si">%s</span><span class="s1"> and S = </span><span class="si">%s</span><span class="s1"> up to J = </span><span class="si">%s</span><span class="s1"> for channel &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span>
                                    <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">L</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">channelSpin</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">sg</span><span class="o">.</span><span class="n">spin</span><span class="p">),</span> <span class="n">channel</span><span class="o">.</span><span class="n">label</span> <span class="p">)</span> <span class="p">)</span>

                    <span class="n">gfact</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">sg</span><span class="o">.</span><span class="n">spin</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">Ia</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">Ib</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">gfact</span> <span class="o">=</span> <span class="mf">1.0</span>

                <span class="c1"># Construct the channel designator</span>
                <span class="n">ps0</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">reactionInfo</span><span class="p">[</span><span class="s1">&#39;particles&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">ps1</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">reactionInfo</span><span class="p">[</span><span class="s1">&#39;particles&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="s1">&#39;photon&#39;</span> <span class="ow">in</span> <span class="p">[</span><span class="n">ps0</span><span class="p">,</span><span class="n">ps1</span><span class="p">]:</span>  <span class="n">channelClass</span> <span class="o">=</span> <span class="n">GAMMACHANNEL</span>
                <span class="k">elif</span> <span class="s1">&#39;gamma&#39;</span> <span class="ow">in</span> <span class="p">[</span><span class="n">ps0</span><span class="p">,</span><span class="n">ps1</span><span class="p">]:</span> <span class="n">channelClass</span> <span class="o">=</span> <span class="n">GAMMACHANNEL</span>
                <span class="k">elif</span> <span class="s1">&#39;n&#39;</span>  <span class="ow">in</span> <span class="p">[</span><span class="n">ps0</span><span class="p">,</span><span class="n">ps1</span><span class="p">]:</span>    <span class="n">channelClass</span> <span class="o">=</span> <span class="n">NEUTRONCHANNEL</span>
                <span class="k">elif</span> <span class="n">pp</span><span class="o">.</span><span class="n">isFission</span><span class="p">():</span>       <span class="n">channelClass</span> <span class="o">=</span> <span class="n">FISSIONCHANNEL</span>
                <span class="k">else</span><span class="p">:</span>                      <span class="n">channelClass</span> <span class="o">=</span> <span class="n">CPCHANNEL</span>
                <span class="n">c</span><span class="o">=</span><span class="n">ChannelDesignator</span><span class="p">(</span>
                    <span class="n">index</span><span class="o">=</span><span class="n">channelIndex</span><span class="p">,</span>
                    <span class="n">reaction</span><span class="o">=</span><span class="n">pp</span><span class="o">.</span><span class="n">label</span><span class="p">,</span>
                    <span class="n">l</span><span class="o">=</span><span class="n">channel</span><span class="o">.</span><span class="n">L</span><span class="p">,</span>
                    <span class="n">s</span><span class="o">=</span><span class="n">channel</span><span class="o">.</span><span class="n">channelSpin</span><span class="p">,</span>
                    <span class="n">J</span><span class="o">=</span><span class="n">sg</span><span class="o">.</span><span class="n">spin</span><span class="p">,</span>
                    <span class="n">gfact</span><span class="o">=</span><span class="n">gfact</span><span class="p">,</span>
                    <span class="n">particleA</span><span class="o">=</span><span class="n">ps0</span><span class="p">,</span>
                    <span class="n">particleB</span><span class="o">=</span><span class="n">ps1</span><span class="p">,</span>
                    <span class="n">Xi</span><span class="o">=</span><span class="n">pp</span><span class="o">.</span><span class="n">reactionInfo</span><span class="p">[</span><span class="s1">&#39;Xi&#39;</span><span class="p">],</span>
                    <span class="n">isElastic</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">isElastic</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">label</span><span class="p">),</span>
                    <span class="n">channelClass</span><span class="o">=</span><span class="n">channelClass</span><span class="p">,</span>
                    <span class="n">useRelativistic</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">relativisticKinematics</span><span class="p">,</span>
                    <span class="n">eliminated</span><span class="o">=</span><span class="n">pp</span><span class="o">.</span><span class="n">eliminated</span> <span class="p">)</span>
                <span class="n">channelIndex</span><span class="o">+=</span><span class="mi">1</span>

                <span class="c1"># Don&#39;t put closed channels onto lists</span>
                <span class="k">if</span> <span class="n">Ein</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">is_open</span><span class="p">(</span><span class="n">Ein</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">is_open</span><span class="p">(</span><span class="n">Ein</span><span class="p">)):</span>
                        <span class="nb">print</span> <span class="s2">&quot;WARNING: Rethink your grid!  Your grid straddles a threshold at </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> for channel </span><span class="si">%s</span><span class="s2">, l=</span><span class="si">%i</span><span class="s2">, s=</span><span class="si">%i</span><span class="s2">, J=</span><span class="si">%i</span><span class="s2">.&quot;</span><span class="o">%</span><span class="p">(</span>
                            <span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">Xi</span><span class="p">),</span><span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span><span class="p">,</span><span class="n">c</span><span class="o">.</span><span class="n">reaction</span><span class="p">,</span><span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span><span class="n">c</span><span class="o">.</span><span class="n">s</span><span class="p">,</span><span class="n">c</span><span class="o">.</span><span class="n">J</span><span class="p">)</span>
                    <span class="k">continue</span>

                <span class="c1"># Save the particle pair, helps finding them later</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">particlePairs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">=</span><span class="n">pp</span>

                <span class="c1"># Log the channels</span>
                <span class="k">if</span> <span class="n">channel</span><span class="o">.</span><span class="n">scatteringRadius</span> <span class="ow">or</span> <span class="n">channel</span><span class="o">.</span><span class="n">hardSphereRadius</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">overrides</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">=</span><span class="n">channel</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">overrides</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span>

                <span class="c1"># Now do the actual resonance packing</span>
                <span class="k">for</span> <span class="n">iR</span><span class="p">,</span> <span class="n">width</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sg</span><span class="o">.</span><span class="n">resonanceParameters</span><span class="o">.</span><span class="n">table</span><span class="p">[:,</span><span class="n">channel</span><span class="o">.</span><span class="n">columnIndex</span><span class="p">]):</span>
                    <span class="n">addOrUpdateDict</span><span class="p">(</span> <span class="n">channelDict</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_energies</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ERs</span><span class="p">[</span><span class="n">iR</span><span class="p">]),</span> <span class="n">width</span> <span class="p">)</span> <span class="p">)</span>

        <span class="c1"># Set up the channel-&gt;resonance mappings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allChannels</span> <span class="o">=</span> <span class="n">channelDict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>  <span class="c1"># just the kept ones</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eliminatedChannels</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">allChannels</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">eliminated</span><span class="p">:</span>    <span class="bp">self</span><span class="o">.</span><span class="n">eliminatedChannels</span><span class="p">[</span> <span class="n">c</span> <span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">allChannels</span><span class="p">[</span> <span class="n">c</span> <span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>               <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span> <span class="n">c</span> <span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">allChannels</span><span class="p">[</span> <span class="n">c</span> <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">identityMatrix</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span> <span class="p">)</span>

        <span class="k">if</span> <span class="n">warnOnly</span><span class="p">:</span> <span class="k">return</span> <span class="n">warnings</span></div>

<div class="viewcode-block" id="RMatrixLimitedcrossSection.resetResonanceParametersByChannel"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RMatrixLimitedcrossSection.resetResonanceParametersByChannel">[docs]</a>    <span class="k">def</span> <span class="nf">resetResonanceParametersByChannel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">multipleSScheme</span><span class="o">=</span><span class="s1">&#39;ENDF&#39;</span><span class="p">,</span> <span class="n">useReichMooreApproximation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">Ein</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">setResonanceParametersByChannel</span><span class="p">(</span> <span class="n">multipleSScheme</span><span class="o">=</span><span class="n">multipleSScheme</span><span class="p">,</span> <span class="n">useReichMooreApproximation</span><span class="o">=</span><span class="n">useReichMooreApproximation</span><span class="p">,</span> <span class="n">Ein</span><span class="o">=</span><span class="n">Ein</span> <span class="p">)</span></div>

<div class="viewcode-block" id="RMatrixLimitedcrossSection.getChannelConstantsBc"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RMatrixLimitedcrossSection.getChannelConstantsBc">[docs]</a>    <span class="k">def</span> <span class="nf">getChannelConstantsBc</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For ENDF&#39;s Reich-Moore, should be :math:`B_c = -\\ell`</span>
<span class="sd">        where :math:`\\ell` is the channel angular momentum, but the ENDF manual says nothing about it.</span>

<span class="sd">        There is a per-channel parameter BCH that we will interpret as :math:`B_c`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Bc</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
            <span class="n">pp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">particlePairs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">pp</span><span class="p">,</span><span class="s1">&#39;boundaryCondition&#39;</span><span class="p">):</span>  <span class="c1">#FIXME: this variable disappeared!</span>
                <span class="n">Bc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">boundaryCondition</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Bc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Bc</span></div>

<div class="viewcode-block" id="RMatrixLimitedcrossSection.getAPByChannel"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RMatrixLimitedcrossSection.getAPByChannel">[docs]</a>    <span class="k">def</span> <span class="nf">getAPByChannel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">trueOrEffective</span><span class="o">=</span><span class="s1">&#39;true&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">trueOrEffective</span><span class="o">==</span><span class="s1">&#39;true&#39;</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getChannelScatteringRadiiTrue</span><span class="p">()[</span><span class="n">c</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">trueOrEffective</span><span class="o">==</span><span class="s1">&#39;effective&#39;</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getChannelScatteringRadiiEffective</span><span class="p">()[</span><span class="n">c</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span> <span class="s2">&quot;trueOrEffective must be &#39;true&#39; or &#39;effective&#39;&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="RMatrixLimitedcrossSection.getChannelScatteringRadiiTrue"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RMatrixLimitedcrossSection.getChannelScatteringRadiiTrue">[docs]</a>    <span class="k">def</span> <span class="nf">getChannelScatteringRadiiTrue</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">APT</span><span class="o">=</span><span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">calculateChannelRadius</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="mf">0.123</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">targetMass_amu</span><span class="o">**</span><span class="p">(</span> <span class="mf">1.</span> <span class="o">/</span> <span class="mf">3.</span> <span class="p">)</span> <span class="o">+</span> <span class="mf">0.08</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">overrides</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">overrides</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">scatteringRadius</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">particlePairs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">scatteringRadius</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s1">&#39;10*fm&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">particlePairs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">scatteringRadius</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s1">&#39;10*fm&#39;</span><span class="p">)</span>
            <span class="n">APT</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">=</span><span class="n">a</span>
        <span class="k">return</span> <span class="n">APT</span></div>

<div class="viewcode-block" id="RMatrixLimitedcrossSection.getChannelScatteringRadiiEffective"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RMatrixLimitedcrossSection.getChannelScatteringRadiiEffective">[docs]</a>    <span class="k">def</span> <span class="nf">getChannelScatteringRadiiEffective</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">APE</span><span class="o">=</span><span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">overrides</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">overrides</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">hardSphereRadius</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">overrides</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">hardSphereRadius</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s1">&#39;10*fm&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">particlePairs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">hardSphereRadius</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">particlePairs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">hardSphereRadius</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s1">&#39;10*fm&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">particlePairs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">scatteringRadius</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s1">&#39;10*fm&#39;</span><span class="p">)</span>
            <span class="n">APE</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">=</span><span class="n">a</span>
        <span class="k">return</span> <span class="n">APE</span></div>

<div class="viewcode-block" id="RMatrixLimitedcrossSection.rho"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RMatrixLimitedcrossSection.rho">[docs]</a>    <span class="k">def</span> <span class="nf">rho</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Ein</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute :math:`\\rho_c(E) = a_c * k_c(E)`, using the true scattering radius.</span>
<span class="sd">        ENDF uses it for calculating shift and penetrabilities.</span>

<span class="sd">        :param Ein: incident energy in the lab frame (shifted by a threshold, if appropriate)</span>
<span class="sd">        :param c: the channel designator</span>
<span class="sd">        :return: the value of rho (dimensionless)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scatteringRadiiTrue</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">scatteringRadiiTrue</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getChannelScatteringRadiiTrue</span><span class="p">()</span>
        <span class="n">pA</span><span class="p">,</span><span class="n">pB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">particlePairs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">reactionInfo</span><span class="p">[</span><span class="s1">&#39;particles&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_competitive</span><span class="p">(</span><span class="n">Ein</span><span class="p">,</span> <span class="n">pA</span><span class="p">,</span> <span class="n">pB</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scatteringRadiiTrue</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="c1"># dimensionless</span></div>

<div class="viewcode-block" id="RMatrixLimitedcrossSection.rhohat"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RMatrixLimitedcrossSection.rhohat">[docs]</a>    <span class="k">def</span> <span class="nf">rhohat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Ein</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute :math:`\\hat{\\rho}_c(E) = a_c * k_c(E)`, using the effective scattering radius</span>
<span class="sd">        ENDF uses it for calculating the phase (but in truth, there should be no effective scattering radius).</span>
<span class="sd">        (Caleb uses self.k below, but I think it should be self.k_competitive for the sake of consistency)</span>

<span class="sd">        :param Ein: incident energy in the lab frame (shifted by a threshold, if appropriate)</span>
<span class="sd">        :param c: the channel designator</span>
<span class="sd">        :return: the value of rho (dimensionless)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scatteringRadiiEffective</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">scatteringRadiiEffective</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getChannelScatteringRadiiEffective</span><span class="p">()</span>
        <span class="n">pA</span><span class="p">,</span><span class="n">pB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">particlePairs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">reactionInfo</span><span class="p">[</span><span class="s1">&#39;particles&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_competitive</span><span class="p">(</span><span class="n">Ein</span><span class="p">,</span> <span class="n">pA</span><span class="p">,</span> <span class="n">pB</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scatteringRadiiEffective</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="c1"># dimensionless</span></div>

<div class="viewcode-block" id="RMatrixLimitedcrossSection.omega"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RMatrixLimitedcrossSection.omega">[docs]</a>    <span class="k">def</span> <span class="nf">omega</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">eta</span><span class="p">,</span><span class="n">L</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">L</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span> <span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">eta</span><span class="p">,</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">L</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="p">)</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">eta</span><span class="p">)</span></div>

<div class="viewcode-block" id="RMatrixLimitedcrossSection.getL0Matrix"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RMatrixLimitedcrossSection.getL0Matrix">[docs]</a>    <span class="k">def</span> <span class="nf">getL0Matrix</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">Ein</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the :math:`L^0` matrix of Froehner, :math:`{\\bf L^0}_{cc&#39;} = \\delta_{cc&#39;} (L_c-B_c)`</span>
<span class="sd">        where :math:`L_c = S_c + i P_c`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;channelConstantsBc&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">channelConstantsBc</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">channelConstantsBc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getChannelConstantsBc</span><span class="p">()</span>
        <span class="n">L0</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Ein</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span> <span class="p">)</span>

        <span class="k">for</span> <span class="n">ic</span><span class="p">,</span><span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">channelClass</span> <span class="ow">in</span> <span class="p">[</span><span class="n">FISSIONCHANNEL</span><span class="p">,</span> <span class="n">GAMMACHANNEL</span><span class="p">]:</span>
                <span class="n">shift</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">penet</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="k">elif</span> <span class="n">c</span><span class="o">.</span><span class="n">channelClass</span> <span class="o">==</span> <span class="n">CPCHANNEL</span><span class="p">:</span>
                <span class="kn">import</span> <span class="nn">getCoulombWavefunctions</span>
                <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span><span class="n">Ein</span><span class="o">-</span><span class="n">c</span><span class="o">.</span><span class="n">Xi</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
                <span class="n">pA</span><span class="p">,</span> <span class="n">pB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">particlePairs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">reactionInfo</span><span class="p">[</span><span class="s1">&#39;particles&#39;</span><span class="p">]</span>
                <span class="n">eta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">(</span><span class="n">Ein</span><span class="o">-</span><span class="n">c</span><span class="o">.</span><span class="n">Xi</span><span class="p">,</span> <span class="n">pA</span><span class="p">,</span> <span class="n">pB</span><span class="p">)</span>
                <span class="n">shift</span> <span class="o">=</span> <span class="n">getCoulombWavefunctions</span><span class="o">.</span><span class="n">coulombShiftFactor</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span><span class="n">rho</span><span class="p">,</span><span class="n">eta</span><span class="p">)</span>
                <span class="n">penet</span> <span class="o">=</span> <span class="n">getCoulombWavefunctions</span><span class="o">.</span><span class="n">coulombPenetrationFactor</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span><span class="n">rho</span><span class="p">,</span><span class="n">eta</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span><span class="n">Ein</span><span class="o">-</span><span class="n">c</span><span class="o">.</span><span class="n">Xi</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
                <span class="n">penet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactor</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="n">rho</span><span class="p">)</span>
                <span class="n">shift</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shiftFactor</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="n">rho</span><span class="p">)</span>

            <span class="c1"># ENDF appears to set Bc = Sc most of the time.  When that&#39;s not the case,</span>
            <span class="c1"># Bc is set to something non zero, so in that case, compute L0 correctly</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">channelConstantsBc</span><span class="p">[</span> <span class="n">ic</span> <span class="p">]</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">L0</span><span class="p">[:,</span><span class="n">ic</span><span class="p">,</span><span class="n">ic</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">shift</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">penet</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">channelConstantsBc</span><span class="p">[</span> <span class="n">ic</span> <span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">L0</span><span class="p">[:,</span><span class="n">ic</span><span class="p">,</span><span class="n">ic</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">penet</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">L0</span></div>

<div class="viewcode-block" id="RMatrixLimitedcrossSection.getRMatrix"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RMatrixLimitedcrossSection.getRMatrix">[docs]</a>    <span class="k">def</span> <span class="nf">getRMatrix</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">Ein</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The R matrix in the Reich-Moore approximation is :math:`R_{cc&#39;}=\\sum_\\lambda{\\gamma_{\\lambda c}\\gamma_{\\lambda c&#39;}/({E_\\lambda - E - i\\Gamma_{\\lambda\\gamma}/2})`</span>

<span class="sd">        :param Ein:</span>
<span class="sd">        :type Ein: numpy.array(type=float)</span>
<span class="sd">        :return:</span>
<span class="sd">        :rtype:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Ein</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span> <span class="p">)</span>

        <span class="c1"># Loop through all resonances</span>
        <span class="k">for</span> <span class="n">iR</span><span class="p">,</span> <span class="n">ER</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_energies</span> <span class="p">):</span>

            <span class="c1"># Extract the gamma width for the first gamma channel that has this resonance</span>
            <span class="n">gamWidth</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">cg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">eliminatedChannels</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">iR</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">eliminatedChannels</span><span class="p">[</span> <span class="n">cg</span> <span class="p">]:</span>
                    <span class="n">gamWidth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eliminatedChannels</span><span class="p">[</span> <span class="n">cg</span> <span class="p">][</span> <span class="n">iR</span> <span class="p">]</span>
                    <span class="k">if</span> <span class="n">gamWidth</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span> <span class="k">break</span>

            <span class="c1"># Precompute the reduced widths</span>
            <span class="n">redWidth</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ic</span><span class="p">,</span><span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">iR</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="n">iR</span><span class="p">]</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="n">width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="n">iR</span><span class="p">]</span>
                    <span class="n">shiftedER</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">abs</span><span class="p">(</span><span class="n">ER</span><span class="o">-</span><span class="n">c</span><span class="o">.</span><span class="n">Xi</span><span class="p">)])</span>
                    <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span><span class="n">shiftedER</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">channelClass</span> <span class="o">==</span> <span class="n">NEUTRONCHANNEL</span><span class="p">:</span>
                        <span class="n">pen</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactor</span><span class="p">(</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="n">rho</span> <span class="p">)</span>
                    <span class="k">elif</span> <span class="n">c</span><span class="o">.</span><span class="n">channelClass</span> <span class="o">==</span> <span class="n">CPCHANNEL</span><span class="p">:</span>
                        <span class="n">pA</span><span class="p">,</span> <span class="n">pB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">particlePairs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">reactionInfo</span><span class="p">[</span><span class="s1">&#39;particles&#39;</span><span class="p">]</span>
                        <span class="n">eta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">(</span><span class="n">shiftedER</span><span class="p">,</span> <span class="n">pA</span><span class="p">,</span> <span class="n">pB</span><span class="p">)</span>
                        <span class="n">pen</span> <span class="o">=</span> <span class="n">getCoulombWavefunctions</span><span class="o">.</span><span class="n">coulombPenetrationFactor</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">eta</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">pen</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">VERBOSE</span><span class="p">:</span> <span class="nb">print</span> <span class="n">iR</span><span class="p">,</span> <span class="n">ER</span><span class="o">-</span><span class="n">c</span><span class="o">.</span><span class="n">Xi</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">width</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;pen=</span><span class="si">%s</span><span class="s1"> for channel </span><span class="si">%s</span><span class="s1"> and resonance #</span><span class="si">%i</span><span class="s1">, but L0[</span><span class="si">%i</span><span class="s1">,</span><span class="si">%i</span><span class="s1">]=</span><span class="si">%s</span><span class="s1"> &#39;</span><span class="o">%</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">pen</span><span class="p">),</span><span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">),</span><span class="n">iR</span><span class="p">,</span><span class="n">ic</span><span class="p">,</span><span class="n">ic</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getL0Matrix</span><span class="p">(</span><span class="n">Ein</span><span class="o">-</span><span class="n">c</span><span class="o">.</span><span class="n">Xi</span><span class="p">)[:,</span><span class="n">ic</span><span class="p">,</span><span class="n">ic</span><span class="p">])))</span>
                    <span class="k">else</span><span class="p">:</span> <span class="n">pen</span> <span class="o">=</span> <span class="mf">1.0</span>
                    <span class="k">if</span> <span class="n">pen</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
                        <span class="n">redWidth</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">copysign</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">width</span><span class="o">/</span><span class="mf">2.0</span><span class="o">/</span><span class="n">pen</span><span class="p">)),</span> <span class="n">width</span> <span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">VERBOSE</span><span class="p">:</span> <span class="nb">print</span> <span class="n">iR</span><span class="p">,</span> <span class="n">ER</span><span class="o">-</span><span class="n">c</span><span class="o">.</span><span class="n">Xi</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">width</span>
                        <span class="n">redWidth</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="mf">0.0</span> <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>   <span class="n">redWidth</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="mf">0.0</span> <span class="p">)</span>

            <span class="c1"># Loop through all channels to accumulate the R Matrix elements</span>
            <span class="k">for</span> <span class="n">ic1</span><span class="p">,</span> <span class="n">c1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">iR</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span> <span class="n">c1</span> <span class="p">]:</span> <span class="k">continue</span>
                <span class="k">for</span> <span class="n">ic2</span><span class="p">,</span> <span class="n">c2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="p">):</span>
                    <span class="k">if</span> <span class="n">ic2</span> <span class="o">&gt;</span> <span class="n">ic1</span><span class="p">:</span> <span class="k">break</span>     <span class="c1"># matrix is symmetric</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">iR</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span> <span class="n">c2</span> <span class="p">]:</span> <span class="k">continue</span>
                    <span class="n">dR</span> <span class="o">=</span> <span class="p">(</span><span class="n">redWidth</span><span class="p">[</span> <span class="n">ic1</span> <span class="p">]</span> <span class="o">*</span> <span class="n">redWidth</span><span class="p">[</span> <span class="n">ic2</span> <span class="p">]</span> <span class="o">/</span> <span class="p">(</span> <span class="n">ER</span><span class="o">-</span><span class="n">Ein</span> <span class="o">-</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">gamWidth</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="p">))</span>
                    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dR</span><span class="p">)</span> <span class="p">):</span>
                        <span class="k">if</span> <span class="n">VERBOSE</span><span class="p">:</span> <span class="nb">print</span> <span class="n">redWidth</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;nan in R-matrix for channels </span><span class="si">%s</span><span class="s1"> and </span><span class="si">%s</span><span class="s1"> &#39;</span><span class="o">%</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">c1</span><span class="p">),</span><span class="nb">str</span><span class="p">(</span><span class="n">c2</span><span class="p">)))</span>
                    <span class="n">R</span><span class="p">[:,</span> <span class="n">ic1</span><span class="p">,</span> <span class="n">ic2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dR</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">ic1</span> <span class="o">!=</span> <span class="n">ic2</span><span class="p">:</span>
                        <span class="n">R</span><span class="p">[:,</span> <span class="n">ic2</span><span class="p">,</span> <span class="n">ic1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dR</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">R</span></div>

<div class="viewcode-block" id="RMatrixLimitedcrossSection.getScatteringMatrixT"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RMatrixLimitedcrossSection.getScatteringMatrixT">[docs]</a>    <span class="k">def</span> <span class="nf">getScatteringMatrixT</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">Ein</span><span class="p">,</span> <span class="n">useTabulatedScatteringRadius</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">enableExtraCoulombPhase</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param Ein:</span>
<span class="sd">        :type Ein: numpy.array(type=float)</span>
<span class="sd">        :param useTabulatedScatteringRadius:</span>
<span class="sd">        :type useTabulatedScatteringRadius: bool</span>
<span class="sd">        :param enableExtraCoulombPhase:</span>
<span class="sd">        :type enableExtraCoulombPhase: bool</span>
<span class="sd">        :return:</span>
<span class="sd">        :rtype:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make sure all channels are open at all requested energies</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">is_open</span><span class="p">(</span><span class="n">Ein</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">]):</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;One or more channels are not open on all energies in requested energy grid&quot;</span><span class="p">)</span>

        <span class="n">T</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ein</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span> <span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span> <span class="p">)</span>
        <span class="n">U</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getScatteringMatrixU</span><span class="p">(</span> <span class="n">Ein</span><span class="p">,</span>
                                       <span class="n">useTabulatedScatteringRadius</span><span class="o">=</span><span class="n">useTabulatedScatteringRadius</span><span class="p">,</span>
                                       <span class="n">enableExtraCoulombPhase</span><span class="o">=</span><span class="n">enableExtraCoulombPhase</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">ic1</span><span class="p">,</span> <span class="n">c1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="p">):</span>
            <span class="n">pA</span><span class="p">,</span> <span class="n">pB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">particlePairs</span><span class="p">[</span><span class="n">c1</span><span class="p">]</span><span class="o">.</span><span class="n">reactionInfo</span><span class="p">[</span><span class="s1">&#39;particles&#39;</span><span class="p">]</span>
            <span class="n">eta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">(</span><span class="n">Ein</span><span class="o">-</span><span class="n">c1</span><span class="o">.</span><span class="n">Xi</span><span class="p">,</span> <span class="n">pA</span><span class="p">,</span> <span class="n">pB</span><span class="p">)</span>
            <span class="n">wc</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">(</span><span class="n">eta</span><span class="p">,</span><span class="n">c1</span><span class="o">.</span><span class="n">l</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ic2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span> <span class="p">):</span>
                <span class="k">if</span> <span class="n">enableExtraCoulombPhase</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">ic1</span><span class="o">==</span><span class="n">ic2</span><span class="p">:</span> <span class="n">eTwoIWcDeltacc</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">2</span><span class="n">j</span><span class="o">*</span><span class="n">wc</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>        <span class="n">eTwoIWcDeltacc</span><span class="o">=</span><span class="mf">0.0</span><span class="n">j</span>
                    <span class="n">T</span><span class="p">[:,</span> <span class="n">ic1</span><span class="p">,</span> <span class="n">ic2</span><span class="p">]</span> <span class="o">=</span> <span class="n">eTwoIWcDeltacc</span>  <span class="o">-</span> <span class="n">U</span><span class="p">[:,</span> <span class="n">ic1</span><span class="p">,</span> <span class="n">ic2</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">T</span><span class="p">[:,</span> <span class="n">ic1</span><span class="p">,</span> <span class="n">ic2</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">ic1</span><span class="o">==</span><span class="n">ic2</span><span class="p">)</span> <span class="o">-</span> <span class="n">U</span><span class="p">[:,</span> <span class="n">ic1</span><span class="p">,</span> <span class="n">ic2</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">T</span></div>

<div class="viewcode-block" id="RMatrixLimitedcrossSection.getEiPhis"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RMatrixLimitedcrossSection.getEiPhis">[docs]</a>    <span class="k">def</span> <span class="nf">getEiPhis</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">Ein</span><span class="p">,</span> <span class="n">useTabulatedScatteringRadius</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">enableExtraCoulombPhase</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The phase factor for the collision matrix, :math:`\\Omega_c=e^{\\omega_c-\\varphi_c}`</span>

<span class="sd">        :param Ein:</span>
<span class="sd">        :type Ein: numpy.array(type=float)</span>
<span class="sd">        :param useTabulatedScatteringRadius:</span>
<span class="sd">        :type useTabulatedScatteringRadius: bool</span>
<span class="sd">        :param enableExtraCoulombPhase:</span>
<span class="sd">        :type enableExtraCoulombPhase: bool</span>
<span class="sd">        :return:</span>
<span class="sd">        :rtype:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Precompute phase factor</span>
        <span class="n">eiphis</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ic</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="p">):</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">channelClass</span> <span class="ow">in</span> <span class="p">[</span><span class="n">FISSIONCHANNEL</span><span class="p">,</span> <span class="n">GAMMACHANNEL</span><span class="p">]:</span>
                <span class="n">eiphis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span> <span class="n">Ein</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span> <span class="p">)</span> <span class="p">)</span>
            <span class="k">elif</span> <span class="n">c</span><span class="o">.</span><span class="n">channelClass</span> <span class="o">==</span> <span class="n">CPCHANNEL</span><span class="p">:</span>
                <span class="kn">import</span> <span class="nn">getCoulombWavefunctions</span>
                <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rhohat</span><span class="p">(</span><span class="n">Ein</span><span class="o">-</span><span class="n">c</span><span class="o">.</span><span class="n">Xi</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
                <span class="n">pA</span><span class="p">,</span> <span class="n">pB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">particlePairs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">reactionInfo</span><span class="p">[</span><span class="s1">&#39;particles&#39;</span><span class="p">]</span>
                <span class="n">eta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">(</span><span class="n">Ein</span><span class="o">-</span><span class="n">c</span><span class="o">.</span><span class="n">Xi</span><span class="p">,</span> <span class="n">pA</span><span class="p">,</span> <span class="n">pB</span><span class="p">)</span>
                <span class="n">phic</span> <span class="o">=</span> <span class="n">getCoulombWavefunctions</span><span class="o">.</span><span class="n">coulombPhi</span><span class="p">(</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">eta</span> <span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">phic</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;phi is NaN for channel </span><span class="si">%s</span><span class="s1">: </span><span class="si">%s</span><span class="s1"> &#39;</span><span class="o">%</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">),</span><span class="nb">str</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">Ein</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">-</span><span class="n">c</span><span class="o">.</span><span class="n">Xi</span><span class="p">,</span><span class="n">phic</span><span class="o">.</span><span class="n">flatten</span><span class="p">()))))</span>
                <span class="k">if</span> <span class="n">enableExtraCoulombPhase</span><span class="p">:</span>
                    <span class="n">wc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">(</span><span class="n">eta</span><span class="p">,</span><span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                    <span class="n">eiphis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">wc</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phic</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="p">)</span> <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">eiphis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span> <span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phic</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="p">)</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rhohat</span><span class="p">(</span><span class="n">Ein</span><span class="o">-</span><span class="n">c</span><span class="o">.</span><span class="n">Xi</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
                <span class="n">phic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">(</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="n">rho</span> <span class="p">)</span>
                <span class="n">eiphis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span> <span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phic</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">return</span> <span class="n">eiphis</span></div>

<div class="viewcode-block" id="RMatrixLimitedcrossSection.k_competitive"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RMatrixLimitedcrossSection.k_competitive">[docs]</a>    <span class="k">def</span> <span class="nf">k_competitive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Ex</span><span class="p">,</span> <span class="n">pA</span><span class="p">,</span> <span class="n">pB</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate k for any 2-body output channel.</span>

<span class="sd">        Note that if pA and pB are target and neutron, this reduces to self.k(E) as defined above</span>
<span class="sd">        in the resonanceReconstructionBaseClass</span>

<span class="sd">        :param Ex: incident energy - Xi (Xi is the lab frame reaction threshold) in eV</span>
<span class="sd">        :param pA: xParticle A</span>
<span class="sd">        :param pB: xParticle B</span>
<span class="sd">        :return: k in b**-1/2</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">particleA</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reactionSuite</span><span class="o">.</span><span class="n">PoPs</span><span class="p">[</span><span class="n">pA</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
        <span class="n">pA_mass</span> <span class="o">=</span> <span class="n">particleA</span><span class="o">.</span><span class="n">getMass</span><span class="p">(</span> <span class="s1">&#39;amu&#39;</span> <span class="p">)</span>
        <span class="n">particleB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reactionSuite</span><span class="o">.</span><span class="n">PoPs</span><span class="p">[</span><span class="n">pB</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
        <span class="n">pB_mass</span> <span class="o">=</span> <span class="n">particleB</span><span class="o">.</span><span class="n">getMass</span><span class="p">(</span> <span class="s1">&#39;amu&#39;</span> <span class="p">)</span>
        <span class="n">targ_mass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">targetMass_amu</span>

            <span class="c1"># sqrt(2*neutronMass)/hbar == 2.196807 (eV*barn)**-1/2. Thus for energy in eV, k is in b**-1/2</span>
            <span class="c1"># FIXME: remove cancelling mn/mn (one shows up inside the numeric constant)?</span>
        <span class="k">return</span> <span class="mf">2.196807122623e-3</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="n">pA_mass</span> <span class="o">*</span> <span class="n">pB_mass</span> <span class="o">/</span> <span class="p">(</span><span class="n">pB_mass</span> <span class="o">+</span> <span class="n">pA_mass</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">neutronMass_amu</span> <span class="o">*</span>
                <span class="n">targ_mass</span> <span class="o">/</span> <span class="p">(</span><span class="n">targ_mass</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">projectileMass_amu</span><span class="p">)</span> <span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Ex</span><span class="p">)</span></div>

<div class="viewcode-block" id="RMatrixLimitedcrossSection.eta"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RMatrixLimitedcrossSection.eta">[docs]</a>    <span class="k">def</span> <span class="nf">eta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Ex</span><span class="p">,</span> <span class="n">pA</span><span class="p">,</span> <span class="n">pB</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        eta, the  Sommerfeld parameter, given by :math:`\\eta = Z_A Z_B m_{red} \\alpha / ( \\hbar c k )`</span>

<span class="sd">        for competitive channels with 2 charged particles, parameter eta is used to find penetrability.</span>
<span class="sd">        eta is given in eq D.79 of ENDF manual and $e^2$ is the fine structure constant $\alpha$ and</span>
<span class="sd">        $m_{red}$ is the reduced mass.  eta is dimensionless.</span>

<span class="sd">        :param Ex: The incident energy</span>
<span class="sd">        :param pA: xParticle A</span>
<span class="sd">        :param pB: xParticle B</span>
<span class="sd">        :return:   the Sommerfeld parameter [dimensionless]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">particleA</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reactionSuite</span><span class="o">.</span><span class="n">PoPs</span><span class="p">[</span><span class="n">pA</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
        <span class="n">pA_z</span> <span class="o">=</span> <span class="n">miscPoPsModule</span><span class="o">.</span><span class="n">ZAInfo</span><span class="p">(</span> <span class="n">particleA</span> <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">particleB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reactionSuite</span><span class="o">.</span><span class="n">PoPs</span><span class="p">[</span><span class="n">pB</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
        <span class="n">pB_z</span> <span class="o">=</span> <span class="n">miscPoPsModule</span><span class="o">.</span><span class="n">ZAInfo</span><span class="p">(</span> <span class="n">particleB</span> <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">pA_z</span> <span class="o">*</span> <span class="n">pB_z</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">Ex</span><span class="p">)</span>

        <span class="n">pA_mass</span> <span class="o">=</span> <span class="n">particleA</span><span class="o">.</span><span class="n">getMass</span><span class="p">(</span> <span class="s1">&#39;amu&#39;</span> <span class="p">)</span>
        <span class="n">pB_mass</span> <span class="o">=</span> <span class="n">particleB</span><span class="o">.</span><span class="n">getMass</span><span class="p">(</span> <span class="s1">&#39;amu&#39;</span> <span class="p">)</span>
        <span class="n">mn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">projectileMass_amu</span>
        <span class="n">eSq_over_hbarSq</span> <span class="o">=</span> <span class="mf">3.4746085579272e-1</span>    <span class="c1"># ?, should be b**-1/2</span>
        <span class="n">k_comp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_competitive</span><span class="p">(</span><span class="n">Ex</span><span class="p">,</span> <span class="n">pA</span><span class="p">,</span> <span class="n">pB</span><span class="p">)</span> <span class="c1"># in b**-1/2</span>
        <span class="n">eta</span> <span class="o">=</span> <span class="p">(</span><span class="n">eSq_over_hbarSq</span> <span class="o">*</span> <span class="n">pA_z</span> <span class="o">*</span> <span class="n">pB_z</span> <span class="o">*</span> <span class="p">(</span><span class="n">pA_mass</span><span class="o">/</span><span class="n">mn</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">pB_mass</span><span class="o">/</span><span class="p">(</span><span class="n">pB_mass</span><span class="o">+</span><span class="n">pA_mass</span><span class="p">))</span> <span class="o">/</span> <span class="n">k_comp</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">eta</span></div>

    <span class="nd">@blockwise</span>
<div class="viewcode-block" id="RMatrixLimitedcrossSection.getCrossSection"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RMatrixLimitedcrossSection.getCrossSection">[docs]</a>    <span class="k">def</span> <span class="nf">getCrossSection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return reconstructed cross sections at incident energy E        </span>
<span class="sd">        :param E: incident energy (unit = self.energyUnit).  May be scalar or vector</span>
<span class="sd">        :return: dictionary with cross sections for each reaction.</span>
<span class="sd">            Cross sections are either scalar or vector, depending on type of parameter &#39;E&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">elasticSum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">absorbtionSum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">fissionSum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">nCompetitive</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="p">[</span><span class="n">ch</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">resonanceReactions</span> <span class="k">if</span> <span class="n">ch</span><span class="o">.</span><span class="n">tag</span><span class="o">==</span><span class="s1">&#39;competitive&#39;</span><span class="p">]</span> <span class="p">)</span>
        <span class="n">competitiveSum</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,]</span> <span class="o">*</span> <span class="n">nCompetitive</span>
        <span class="n">haveFission</span> <span class="o">=</span> <span class="nb">any</span><span class="p">([</span><span class="n">rreac</span><span class="o">.</span><span class="n">isFission</span><span class="p">()</span> <span class="k">for</span> <span class="n">rreac</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">resonanceReactions</span><span class="p">])</span>
        <span class="n">haveEliminated</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">for</span> <span class="n">sg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">spinGroups</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">spin</span>
            <span class="n">gfact</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span><span class="o">+</span><span class="mf">1.0</span><span class="p">)</span><span class="o">/</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">projectileSpin</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">targetSpin</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>

            <span class="n">widths</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">penetrabilities</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">phis</span> <span class="o">=</span> <span class="p">[]</span>    <span class="c1"># phi is l-dependant</span>
            <span class="n">Xis</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">thresholdIndices</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">chanIds</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">eliminatedWidth</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="n">sg</span><span class="o">.</span><span class="n">resonanceParameters</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">nRows</span> <span class="p">)</span>

            <span class="k">for</span> <span class="n">chan</span> <span class="ow">in</span> <span class="n">sg</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
                <span class="n">resonanceReaction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">resonanceReactions</span><span class="p">[</span> <span class="n">chan</span><span class="o">.</span><span class="n">resonanceReaction</span> <span class="p">]</span>
                <span class="n">chanWidths</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">sg</span><span class="o">.</span><span class="n">resonanceParameters</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">getColumn</span><span class="p">(</span><span class="n">chan</span><span class="o">.</span><span class="n">columnIndex</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span><span class="p">)</span> <span class="p">)</span>

                <span class="k">if</span> <span class="n">resonanceReaction</span><span class="o">.</span><span class="n">eliminated</span><span class="p">:</span>
                    <span class="n">eliminatedWidth</span> <span class="o">+=</span> <span class="n">chanWidths</span> <span class="o">/</span> <span class="mi">2</span>
                    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">eliminatedWidth</span><span class="p">):</span> <span class="n">haveEliminated</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">continue</span>
                <span class="k">elif</span> <span class="n">resonanceReaction</span><span class="o">.</span><span class="n">isFission</span><span class="p">():</span>
                    <span class="c1"># penetrability treated as 1 everywhere</span>
                    <span class="n">reducedWidths</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="nb">abs</span><span class="p">(</span><span class="n">chanWidths</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="p">)</span>
                    <span class="n">reducedWidths</span><span class="p">[</span> <span class="n">chanWidths</span><span class="o">&lt;</span><span class="mi">0</span> <span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="n">widths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">reducedWidths</span> <span class="p">)</span>
                    <span class="n">penetrabilities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">]])</span> <span class="p">)</span>
                    <span class="n">chanIds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">chan</span><span class="o">.</span><span class="n">resonanceReaction</span> <span class="p">)</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">l</span> <span class="o">=</span> <span class="n">chan</span><span class="o">.</span><span class="n">L</span>
                    <span class="n">pA</span><span class="p">,</span><span class="n">pB</span> <span class="o">=</span> <span class="n">resonanceReaction</span><span class="o">.</span><span class="n">reactionInfo</span><span class="p">[</span><span class="s1">&#39;particles&#39;</span><span class="p">]</span>
                    <span class="n">Xi</span> <span class="o">=</span> <span class="n">resonanceReaction</span><span class="o">.</span><span class="n">reactionInfo</span><span class="p">[</span><span class="s1">&#39;Xi&#39;</span><span class="p">]</span>
                    <span class="n">Xis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">Xi</span> <span class="p">)</span>
                    <span class="n">chanIds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">chan</span><span class="o">.</span><span class="n">resonanceReaction</span> <span class="p">)</span>

                    <span class="k">if</span> <span class="n">Xi</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># find index of first incident energy above threshold:</span>
                        <span class="kn">import</span> <span class="nn">bisect</span>
                        <span class="n">thresholdIndex</span> <span class="o">=</span> <span class="n">bisect</span><span class="o">.</span><span class="n">bisect</span><span class="p">(</span> <span class="n">E</span><span class="p">,</span> <span class="n">Xi</span> <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">thresholdIndex</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">thresholdIndices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">thresholdIndex</span> <span class="p">)</span>

                    <span class="c1"># channel radius:</span>
                    <span class="k">def</span> <span class="nf">rho</span><span class="p">(</span> <span class="n">Ex</span> <span class="p">):</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">calculateChannelRadius</span><span class="p">:</span>
                            <span class="n">a</span> <span class="o">=</span> <span class="mf">0.123</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">targetMass_amu</span><span class="o">**</span><span class="p">(</span> <span class="mf">1.</span> <span class="o">/</span> <span class="mf">3.</span> <span class="p">)</span> <span class="o">+</span> <span class="mf">0.08</span>
                        <span class="k">elif</span> <span class="n">chan</span><span class="o">.</span><span class="n">scatteringRadius</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">a</span> <span class="o">=</span> <span class="n">chan</span><span class="o">.</span><span class="n">scatteringRadius</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s1">&#39;10*fm&#39;</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">a</span> <span class="o">=</span> <span class="n">resonanceReaction</span><span class="o">.</span><span class="n">scatteringRadius</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s1">&#39;10*fm&#39;</span><span class="p">)</span>
                        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_competitive</span><span class="p">(</span><span class="n">Ex</span><span class="p">,</span> <span class="n">pA</span><span class="p">,</span> <span class="n">pB</span><span class="p">)</span> <span class="o">*</span> <span class="n">a</span>

                    <span class="c1"># rhohat, for calculating phase shift phi:</span>
                    <span class="k">if</span> <span class="n">chan</span><span class="o">.</span><span class="n">hardSphereRadius</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">rhohat</span> <span class="o">=</span> <span class="n">chan</span><span class="o">.</span><span class="n">hardSphereRadius</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s1">&#39;10*fm&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">resonanceReaction</span><span class="o">.</span><span class="n">hardSphereRadius</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">rhohat</span> <span class="o">=</span> <span class="n">resonanceReaction</span><span class="o">.</span><span class="n">hardSphereRadius</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s1">&#39;10*fm&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">rhohat</span> <span class="o">=</span> <span class="n">resonanceReaction</span><span class="o">.</span><span class="n">scatteringRadius</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s1">&#39;10*fm&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
                    <span class="n">phinow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">rhohat</span><span class="p">)</span>
                    <span class="n">phinow</span><span class="p">[</span> <span class="n">phinow</span><span class="o">/</span><span class="n">rhohat</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">6</span> <span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># see subroutine &#39;facphi&#39; in RECENT</span>
                    <span class="n">phis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">phinow</span> <span class="p">)</span>

                    <span class="c1"># penetrability:</span>
                    <span class="n">Ex1</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">sg</span><span class="o">.</span><span class="n">energy</span><span class="p">)</span><span class="o">-</span><span class="n">Xi</span><span class="p">)</span>    <span class="c1"># evaluated at resonances</span>
                    <span class="n">Ex2</span> <span class="o">=</span> <span class="n">E</span><span class="o">-</span><span class="n">Xi</span><span class="p">;</span> <span class="n">Ex2</span><span class="p">[</span><span class="n">Ex2</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>      <span class="c1"># evaluated at each incident energy</span>
                    <span class="n">eta1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">(</span><span class="n">Ex1</span><span class="p">,</span> <span class="n">pA</span><span class="p">,</span> <span class="n">pB</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">eta1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                        <span class="c1"># output channel has two charged particles, need Coulomb penetrability:</span>
                        <span class="n">penetrabilityAtResonances</span> <span class="o">=</span> <span class="n">getCoulombWavefunctions</span><span class="o">.</span><span class="n">coulombPenetrationFactor</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">rho</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">Ex1</span><span class="p">)),</span> <span class="n">eta1</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">thresholdIndex</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># threshold reaction</span>
                            <span class="n">eta2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span> <span class="n">Ex2</span> <span class="p">)</span>
                            <span class="n">eta2</span><span class="p">[</span> <span class="n">thresholdIndex</span><span class="p">:</span> <span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">(</span> <span class="n">Ex2</span><span class="p">[</span> <span class="n">thresholdIndex</span><span class="p">:</span> <span class="p">],</span> <span class="n">pA</span><span class="p">,</span> <span class="n">pB</span> <span class="p">)</span>

                            <span class="n">penetrabilityAtEin</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span> <span class="n">Ex2</span> <span class="p">)</span>
                            <span class="n">penetrabilityAtEin</span><span class="p">[</span> <span class="n">thresholdIndex</span><span class="p">:</span> <span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                                    <span class="n">getCoulombWavefunctions</span><span class="o">.</span><span class="n">coulombPenetrationFactor</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">rho</span><span class="p">(</span><span class="n">Ex2</span><span class="p">[</span> <span class="n">thresholdIndex</span><span class="p">:</span> <span class="p">]),</span>
                                    <span class="n">eta2</span><span class="p">[</span> <span class="n">thresholdIndex</span><span class="p">:</span> <span class="p">]</span> <span class="p">)</span> <span class="p">)</span>

                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">eta2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">(</span><span class="n">Ex2</span><span class="p">,</span> <span class="n">pA</span><span class="p">,</span> <span class="n">pB</span><span class="p">)</span>
                            <span class="n">penetrabilityAtEin</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="n">getCoulombWavefunctions</span><span class="o">.</span><span class="n">coulombPenetrationFactor</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">rho</span><span class="p">(</span><span class="n">Ex2</span><span class="p">),</span> <span class="n">eta2</span><span class="p">)</span> <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># no Coulomb contribution:</span>
                        <span class="n">penetrabilityAtResonances</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactor</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">rho</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">Ex1</span><span class="p">)))</span>
                        <span class="n">penetrabilityAtEin</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactor</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">rho</span><span class="p">(</span><span class="n">Ex2</span><span class="p">))</span> <span class="p">)</span>

                    <span class="n">reducedWidths</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="nb">abs</span><span class="p">(</span><span class="n">chanWidths</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">penetrabilityAtResonances</span><span class="p">)</span> <span class="p">)</span>
                    <span class="n">reducedWidths</span><span class="p">[</span> <span class="n">chanWidths</span><span class="o">&lt;</span><span class="mi">0</span> <span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="n">widths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">reducedWidths</span> <span class="p">)</span>
                    <span class="n">penetrabilities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">penetrabilityAtEin</span> <span class="p">)</span>

            <span class="c1"># are there any threshold reactions (negative Q-values)?</span>
            <span class="c1"># If so, we must break up the calculation above/below each threshold</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span> <span class="n">thresholdIndices</span> <span class="p">):</span>
                <span class="k">if</span> <span class="n">thresholdIndices</span> <span class="o">!=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">thresholdIndices</span><span class="p">):</span>
                    <span class="c1"># sort by increasing threshold</span>
                    <span class="p">(</span><span class="n">thresholdIndices</span><span class="p">,</span> <span class="n">chanIds</span><span class="p">,</span> <span class="n">widths</span><span class="p">,</span> <span class="n">penetrabilities</span><span class="p">)</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="nb">sorted</span><span class="p">(</span>
                        <span class="nb">zip</span><span class="p">(</span><span class="n">thresholdIndices</span><span class="p">,</span><span class="n">chanIds</span><span class="p">,</span><span class="n">widths</span><span class="p">,</span><span class="n">penetrabilities</span><span class="p">),</span>
                        <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">tmp</span><span class="p">:</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># sort only by threshold index (not by id or width)</span>
                    <span class="p">))</span>
                <span class="k">assert</span> <span class="n">thresholdIndices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
                <span class="n">thresholdIndices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">thresholdIndices</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">)]</span>

                <span class="n">RI</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">widths</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">widths</span><span class="p">)))</span>
                <span class="n">SI</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="n">RI</span><span class="o">.</span><span class="n">shape</span> <span class="p">)</span>

                <span class="n">threshSet</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">thresholdIndices</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">i1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">threshSet</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">low</span> <span class="o">=</span> <span class="n">threshSet</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span>
                    <span class="n">high</span> <span class="o">=</span> <span class="n">threshSet</span><span class="p">[</span><span class="n">i1</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">nOpen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="p">[</span><span class="n">th</span> <span class="k">for</span> <span class="n">th</span> <span class="ow">in</span> <span class="n">thresholdIndices</span> <span class="k">if</span> <span class="n">th</span><span class="o">-</span><span class="n">low</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">]</span> <span class="p">)</span>
                    <span class="n">RI_now</span><span class="p">,</span> <span class="n">SI_now</span> <span class="o">=</span> <span class="n">invertMatrices</span><span class="p">(</span>
                            <span class="o">*</span><span class="n">getR_S</span><span class="p">(</span> <span class="n">E</span><span class="p">[</span><span class="n">low</span><span class="p">:</span><span class="n">high</span><span class="p">],</span> <span class="n">sg</span><span class="o">.</span><span class="n">energy</span><span class="p">,</span> <span class="n">eliminatedWidth</span><span class="p">,</span>
                            <span class="n">widths</span><span class="p">[:</span><span class="n">nOpen</span><span class="p">],</span> <span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="n">low</span><span class="p">:</span><span class="n">high</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">penetrabilities</span><span class="p">[:</span><span class="n">nOpen</span><span class="p">]]</span> <span class="p">)</span>
                            <span class="p">)</span>
                    <span class="k">if</span> <span class="n">nOpen</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>  <span class="c1"># numpy insists on same number of dimensions for copy:</span>
                        <span class="n">RI_now</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">SI_now</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">RI_now</span><span class="p">),</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

                    <span class="n">RI</span><span class="p">[</span><span class="n">low</span><span class="p">:</span><span class="n">high</span><span class="p">,</span> <span class="p">:</span><span class="n">nOpen</span><span class="p">,</span> <span class="p">:</span><span class="n">nOpen</span><span class="p">]</span> <span class="o">=</span> <span class="n">RI_now</span>
                    <span class="n">SI</span><span class="p">[</span><span class="n">low</span><span class="p">:</span><span class="n">high</span><span class="p">,</span> <span class="p">:</span><span class="n">nOpen</span><span class="p">,</span> <span class="p">:</span><span class="n">nOpen</span><span class="p">]</span> <span class="o">=</span> <span class="n">SI_now</span>

            <span class="k">else</span><span class="p">:</span>   <span class="c1"># no threshold reactions</span>
                <span class="n">RI</span><span class="p">,</span><span class="n">SI</span> <span class="o">=</span> <span class="n">invertMatrices</span><span class="p">(</span>
                        <span class="o">*</span><span class="n">getR_S</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">sg</span><span class="o">.</span><span class="n">energy</span><span class="p">,</span> <span class="n">eliminatedWidth</span><span class="p">,</span> <span class="n">widths</span><span class="p">,</span> <span class="n">penetrabilities</span><span class="p">)</span>
                        <span class="p">)</span>

            <span class="c1"># reconstruct:</span>
            <span class="n">chanIds</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">chanIds</span> <span class="p">)</span>
            <span class="n">elasID</span> <span class="o">=</span> <span class="p">[</span><span class="n">tmp</span><span class="o">.</span><span class="n">label</span> <span class="k">for</span> <span class="n">tmp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">resonanceReactions</span> <span class="k">if</span> <span class="n">tmp</span><span class="o">.</span><span class="n">tag</span><span class="o">==</span><span class="s1">&#39;elastic&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">competitiveIDs</span> <span class="o">=</span> <span class="p">[</span><span class="n">tmp</span><span class="o">.</span><span class="n">label</span> <span class="k">for</span> <span class="n">tmp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">resonanceReactions</span> <span class="k">if</span> <span class="n">tmp</span><span class="o">.</span><span class="n">tag</span><span class="o">==</span><span class="s1">&#39;competitive&#39;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">chan</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">resonanceReactions</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">chan</span><span class="o">.</span><span class="n">eliminated</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="c1"># which matrix elements correspond to this channel?</span>
                <span class="n">thisChanIds</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span> <span class="n">chanIds</span><span class="o">==</span><span class="n">chan</span><span class="o">.</span><span class="n">label</span> <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">thisChanIds</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">id1</span><span class="p">,</span> <span class="n">id2</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">thisChanIds</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">thisChanIds</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">thisChanIds</span><span class="p">)</span> <span class="o">==</span> <span class="n">id2</span><span class="o">-</span><span class="n">id1</span>
                <span class="k">if</span> <span class="n">chan</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s1">&#39;elastic&#39;</span><span class="p">:</span>
                    <span class="n">elas</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">absorb</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="c1"># diagonal component</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">id1</span><span class="p">,</span><span class="n">id2</span><span class="p">):</span>
                        <span class="n">phi</span> <span class="o">=</span> <span class="n">phis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># convert to row vector</span>
                        <span class="n">sinsqr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
                        <span class="n">sincos</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
                        <span class="n">elas</span> <span class="o">+=</span> <span class="p">(</span> <span class="n">sinsqr</span> <span class="o">*</span> <span class="p">(</span><span class="n">sinsqr</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">RI</span><span class="p">[:,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="n">sincos</span> <span class="o">*</span> <span class="p">(</span><span class="n">sincos</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">SI</span><span class="p">[:,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">])</span> <span class="p">)</span>
                        <span class="n">absorb</span> <span class="o">+=</span> <span class="o">-</span><span class="n">RI</span><span class="p">[:,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span>
                    <span class="c1"># add cross-terms:</span>
                    <span class="n">elas</span> <span class="o">+=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="n">RI</span><span class="p">[:,</span><span class="n">id1</span><span class="p">:</span><span class="n">id2</span><span class="p">,</span><span class="n">id1</span><span class="p">:</span><span class="n">id2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">SI</span><span class="p">[:,</span><span class="n">id1</span><span class="p">:</span><span class="n">id2</span><span class="p">,</span><span class="n">id1</span><span class="p">:</span><span class="n">id2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>
                            <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">absorb</span> <span class="o">-=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="n">RI</span><span class="p">[:,</span><span class="n">id1</span><span class="p">:</span><span class="n">id2</span><span class="p">,</span><span class="n">id1</span><span class="p">:</span><span class="n">id2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">SI</span><span class="p">[:,</span><span class="n">id1</span><span class="p">:</span><span class="n">id2</span><span class="p">,</span><span class="n">id1</span><span class="p">:</span><span class="n">id2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>
                            <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">elasticSum</span> <span class="o">+=</span> <span class="n">gfact</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">elas</span>
                    <span class="n">absorbtionSum</span> <span class="o">+=</span> <span class="n">gfact</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">absorb</span>

                <span class="k">else</span><span class="p">:</span> <span class="c1"># competitive or fission:</span>
                    <span class="c1"># sum of cross-terms between this channel and elastic:</span>
                    <span class="n">elasticIds</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span> <span class="n">chanIds</span><span class="o">==</span><span class="n">elasID</span> <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">el1</span><span class="p">,</span> <span class="n">el2</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">elasticIds</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">elasticIds</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
                    <span class="n">comp</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">SI</span><span class="p">[:,</span><span class="n">id1</span><span class="p">:</span><span class="n">id2</span><span class="p">,</span><span class="n">el1</span><span class="p">:</span><span class="n">el2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">RI</span><span class="p">[:,</span><span class="n">id1</span><span class="p">:</span><span class="n">id2</span><span class="p">,</span><span class="n">el1</span><span class="p">:</span><span class="n">el2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>
                            <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">chan</span><span class="o">.</span><span class="n">isFission</span><span class="p">():</span>
                        <span class="n">fissionSum</span> <span class="o">+=</span> <span class="n">gfact</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">comp</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># may have more than one competitive: add to correct channel</span>
                        <span class="n">competitiveSum</span><span class="p">[</span> <span class="n">competitiveIDs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span> <span class="n">chan</span><span class="o">.</span><span class="n">label</span> <span class="p">)</span> <span class="p">]</span> <span class="o">+=</span> <span class="n">gfact</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">comp</span>

        <span class="c1"># get common factor &#39;beta&#39; as a row vector:</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">(</span><span class="n">E</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">elastic</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">elasticSum</span>
        <span class="n">competitive</span> <span class="o">=</span> <span class="p">[</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">comp</span> <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">competitiveSum</span> <span class="p">]</span>
        <span class="n">fission</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">fissionSum</span>
        <span class="k">if</span> <span class="n">haveEliminated</span><span class="p">:</span>
            <span class="n">absorbtion</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">absorbtionSum</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">absorbtion</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">competitive</span><span class="p">)</span> <span class="o">+</span> <span class="n">fission</span> <span class="c1"># more numerically stable in abscence of eliminated channel</span>
        <span class="n">total</span> <span class="o">=</span> <span class="n">elastic</span> <span class="o">+</span> <span class="n">absorbtion</span>

        <span class="n">retDict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;total&#39;</span><span class="p">:</span><span class="n">total</span><span class="p">,</span> <span class="s1">&#39;elastic&#39;</span><span class="p">:</span><span class="n">elastic</span><span class="p">,</span> <span class="s1">&#39;fission&#39;</span><span class="p">:</span><span class="n">fission</span><span class="p">,</span> <span class="s1">&#39;nonelastic&#39;</span><span class="p">:</span><span class="n">absorbtion</span><span class="p">}</span>
        <span class="n">competitiveNames</span> <span class="o">=</span> <span class="p">[</span><span class="n">ch</span><span class="o">.</span><span class="n">label</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">resonanceReactions</span> <span class="k">if</span> <span class="n">ch</span><span class="o">.</span><span class="n">tag</span><span class="o">==</span><span class="s1">&#39;competitive&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">competitiveNames</span><span class="p">,</span><span class="n">competitive</span><span class="p">):</span>
            <span class="n">retDict</span><span class="p">[</span> <span class="n">key</span> <span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">if</span> <span class="n">haveEliminated</span><span class="p">:</span>
            <span class="n">eliminatedReaction</span> <span class="o">=</span> <span class="p">[</span><span class="n">rr</span> <span class="k">for</span> <span class="n">rr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">resonanceReactions</span> <span class="k">if</span> <span class="n">rr</span><span class="o">.</span><span class="n">eliminated</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">eliminatedReaction</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Only 1 reaction can be eliminated in Reich-Moore approximation!&quot;</span><span class="p">)</span>
            <span class="n">retDict</span><span class="p">[</span><span class="n">eliminatedReaction</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">absorbtion</span> <span class="o">-</span> <span class="n">fission</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">competitive</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">retDict</span></div></div>


<span class="c1">##### unresolved resonance region. Only one formalism here: #####</span>
<div class="viewcode-block" id="URRPDFTable"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.URRPDFTable">[docs]</a><span class="k">class</span> <span class="nc">URRPDFTable</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Lightweight class for storage and IO of URR PDF&#39;s</span>

<span class="sd">    Test it as follows:</span>

<span class="sd">    &gt;&gt;&gt; import xs_pdf as xp</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; u=xp.URRPDFTable()</span>
<span class="sd">    &gt;&gt;&gt; u.eBins=xp.equal_bins(2,0.,4.)</span>
<span class="sd">    &gt;&gt;&gt; u.xsBins=xp.equal_bins(3,1.,1.5)</span>
<span class="sd">    &gt;&gt;&gt; u[&#39;capture&#39;]=np.zeros(shape=(2,3))</span>
<span class="sd">    &gt;&gt;&gt; u[&#39;capture&#39;][0,0]=1.</span>
<span class="sd">    &gt;&gt;&gt; u[&#39;capture&#39;][1,2]=2.</span>
<span class="sd">    &gt;&gt;&gt; print(u)</span>
<span class="sd">        {&quot;eBins&quot;: &quot;[ 0.  2.  4.]&quot;, &quot;urrPdf&quot;: {&quot;capture&quot;: &quot;[[ 1.  0.  0.]\n [ 0.  0.  2.]]&quot;}, &quot;xsBins&quot;: &quot;[ 1.          1.16666667  1.33333333  1.5       ]&quot;}</span>
<span class="sd">    &gt;&gt;&gt; u.save(&#39;junk.txt&#39;)</span>
<span class="sd">    &gt;&gt;&gt; v=xp.URRPDFTable()</span>
<span class="sd">    &gt;&gt;&gt; v.load(&#39;junk.txt&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(v)</span>
<span class="sd">        {&quot;eBins&quot;: &quot;[ 0.  2.  4.]&quot;, &quot;urrPdf&quot;: {&quot;capture&quot;: &quot;[[ 1.  0.  0.]\n [ 0.  0.  2.]]&quot;}, &quot;xsBins&quot;: &quot;[ 1.          1.16666667  1.33333333  1.5       ]&quot;}</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;eBins&#39;</span> <span class="ow">in</span> <span class="n">kwds</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">eBins</span><span class="o">=</span><span class="n">kwds</span><span class="p">[</span><span class="s1">&#39;eBins&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">eBins</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">if</span> <span class="s1">&#39;xsBins&#39;</span> <span class="ow">in</span> <span class="n">kwds</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">xsBins</span><span class="o">=</span><span class="n">kwds</span><span class="p">[</span><span class="s1">&#39;xsBins&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">xsBins</span><span class="o">=</span><span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">NSamples</span><span class="o">=</span><span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">isNormalized</span><span class="o">=</span><span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">NE</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span> <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eBins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
        <span class="k">except</span><span class="p">:</span> <span class="k">return</span> <span class="mi">0</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">NXS</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span> <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xsBins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
        <span class="k">except</span><span class="p">:</span> <span class="k">return</span> <span class="mi">0</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">XSmin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xsBins</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">XSmax</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xsBins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">Emin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">eBins</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">Emax</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">eBins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">eBinCenters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="bp">self</span><span class="o">.</span><span class="n">eBins</span><span class="p">[</span><span class="n">iE</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">eBins</span><span class="p">[</span><span class="n">iE</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="k">for</span> <span class="n">iE</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NE</span><span class="p">)])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">eBinWidths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="bp">self</span><span class="o">.</span><span class="n">eBins</span><span class="p">[</span><span class="n">iE</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">eBins</span><span class="p">[</span><span class="n">iE</span><span class="p">])</span> <span class="k">for</span> <span class="n">iE</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NE</span><span class="p">)])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">xsBinCenters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="bp">self</span><span class="o">.</span><span class="n">xsBins</span><span class="p">[</span><span class="n">iXS</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">xsBins</span><span class="p">[</span><span class="n">iXS</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="k">for</span> <span class="n">iXS</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NXS</span><span class="p">)])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">xsBinWidths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="bp">self</span><span class="o">.</span><span class="n">xsBins</span><span class="p">[</span><span class="n">iXS</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">xsBins</span><span class="p">[</span><span class="n">iXS</span><span class="p">])</span> <span class="k">for</span> <span class="n">iXS</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NXS</span><span class="p">)])</span>

<div class="viewcode-block" id="URRPDFTable.pdf_at_energy"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.URRPDFTable.pdf_at_energy">[docs]</a>    <span class="k">def</span> <span class="nf">pdf_at_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">key</span><span class="p">,</span><span class="n">E</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">fudge.core.math.pdf</span> <span class="k">import</span> <span class="n">UnivariatePDF</span>
        <span class="n">iE</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">E</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">eBins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
        <span class="k">return</span> <span class="n">UnivariatePDF</span><span class="p">(</span><span class="n">xGrid</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xsBins</span><span class="p">,</span> <span class="n">pdfTable</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">iE</span><span class="p">,:])</span></div>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">json</span>
        <span class="n">tmp</span><span class="o">=</span><span class="p">{</span>
            <span class="s1">&#39;eBins&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">eBins</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
            <span class="s1">&#39;xsBins&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">xsBins</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
            <span class="s1">&#39;urrPdf&#39;</span><span class="p">:{</span><span class="n">x</span><span class="p">:</span><span class="bp">self</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">},</span>
            <span class="s1">&#39;NSamples&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">NSamples</span><span class="p">,</span>
            <span class="s1">&#39;isNormalized&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">isNormalized</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>

<div class="viewcode-block" id="URRPDFTable.normalize"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.URRPDFTable.normalize">[docs]</a>    <span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Normalize the binned PDFs using numpy trickery&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isNormalized</span><span class="p">:</span> <span class="k">return</span>
        <span class="k">for</span> <span class="n">rxn</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">rxn</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;eBins&#39;</span><span class="p">,</span><span class="s1">&#39;xsBins&#39;</span><span class="p">]:</span> <span class="k">continue</span>
            <span class="k">for</span> <span class="n">iE</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NE</span><span class="p">):</span>
                <span class="n">thesum</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">rxn</span><span class="p">][</span><span class="n">iE</span><span class="p">,:])</span>
                <span class="k">if</span> <span class="n">thesum</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span><span class="k">continue</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">rxn</span><span class="p">][</span><span class="n">iE</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/=</span> <span class="n">thesum</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">rxn</span><span class="p">][</span><span class="n">iE</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xsBinWidths</span><span class="p">[:]</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">rxn</span><span class="p">][</span><span class="n">numpy</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">rxn</span><span class="p">])]</span><span class="o">=</span><span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">isNormalized</span><span class="o">=</span><span class="kc">True</span></div>

<div class="viewcode-block" id="URRPDFTable.save"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.URRPDFTable.save">[docs]</a>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span> <span class="s2">&quot;Saving URR PDF to </span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="n">fname</span>
        <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;}&#39;</span><span class="p">,</span><span class="s1">&#39;}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">))</span></div>

<div class="viewcode-block" id="URRPDFTable.load"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.URRPDFTable.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">json</span>
        <span class="n">tmp</span><span class="o">=</span><span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">))</span>
        <span class="c1">#def __read_float_list(s):</span>
        <span class="c1">#    return map(float,s.replace(&#39;]&#39;, &#39;&#39;).replace(&#39;[&#39;, &#39;&#39;).split())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">isNormalized</span><span class="o">=</span><span class="n">tmp</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;isNormalized&#39;</span><span class="p">,</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">NSamples</span><span class="o">=</span><span class="n">tmp</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;NSamples&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eBins</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="s1">&#39;eBins&#39;</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xsBins</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="s1">&#39;xsBins&#39;</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">x</span><span class="p">:</span><span class="n">numpy</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="s1">&#39;urrPdf&#39;</span><span class="p">][</span><span class="n">x</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">tmp</span><span class="p">[</span><span class="s1">&#39;urrPdf&#39;</span><span class="p">]})</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">NE</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">NXS</span><span class="p">))</span></div></div>

<div class="viewcode-block" id="URRcrossSection"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.URRcrossSection">[docs]</a><span class="k">class</span> <span class="nc">URRcrossSection</span><span class="p">(</span><span class="n">resonanceReconstructionBaseClass</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reactionSuite</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the URR management class</span>

<span class="sd">        :param reactionSuite: The reactionSuite this class is destined to be part of</span>
<span class="sd">        :param verbose: duh, verbosity flag</span>
<span class="sd">        :param kw: Python dict of keywords, currently none defined</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">URRcrossSection</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">reactionSuite</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>

        <span class="c1"># energy boundaries for this region:</span>
        <span class="n">urr</span> <span class="o">=</span> <span class="n">reactionSuite</span><span class="o">.</span><span class="n">resonances</span><span class="o">.</span><span class="n">unresolved</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reactionSuite</span> <span class="o">=</span> <span class="n">reactionSuite</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">URR</span> <span class="o">=</span> <span class="n">urr</span><span class="o">.</span><span class="n">evaluated</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lowerBound</span> <span class="o">=</span> <span class="n">urr</span><span class="o">.</span><span class="n">domainMin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">upperBound</span> <span class="o">=</span> <span class="n">urr</span><span class="o">.</span><span class="n">domainMax</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;Unresolved from </span><span class="si">%f</span><span class="s2"> to </span><span class="si">%f</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lowerBound</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">upperBound</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">levelSpacings</span><span class="o">=</span><span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">averageWidths</span><span class="o">=</span><span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">levelSpacingFuncs</span><span class="o">=</span><span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">averageWidthFuncs</span><span class="o">=</span><span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">DOFs</span><span class="o">=</span><span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">egrid</span><span class="o">=</span><span class="kc">None</span>

<div class="viewcode-block" id="URRcrossSection.getLastResolvedResonanceRegion"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.URRcrossSection.getLastResolvedResonanceRegion">[docs]</a>    <span class="k">def</span> <span class="nf">getLastResolvedResonanceRegion</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the highest energy resonance ENDF region in the resolved resonance region (which may contain more than one ENDF region)</span>

<span class="sd">        :return: The ENDF resolved resonance region, or None if there is no ENDF region in the data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reactionSuite</span><span class="o">.</span><span class="n">resonances</span><span class="o">.</span><span class="n">resolved</span><span class="p">:</span>
            <span class="c1"># For multiple regions, we need to do each region separately, then add them to the unified xs table &amp; egrid</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reactionSuite</span><span class="o">.</span><span class="n">resonances</span><span class="o">.</span><span class="n">resolved</span><span class="o">.</span><span class="n">multipleRegions</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reactionSuite</span><span class="o">.</span><span class="n">resonances</span><span class="o">.</span><span class="n">resolved</span><span class="o">.</span><span class="n">regions</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">evaluated</span>
            <span class="c1"># Single region, everything goes on unified grid</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reactionSuite</span><span class="o">.</span><span class="n">resonances</span><span class="o">.</span><span class="n">resolved</span><span class="o">.</span><span class="n">evaluated</span>
        <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="URRcrossSection.getLastResolvedResonanceEnergy"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.URRcrossSection.getLastResolvedResonanceEnergy">[docs]</a>    <span class="k">def</span> <span class="nf">getLastResolvedResonanceEnergy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">l</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">j</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the last resonance energy from the resolved region, that will start all the ladders in the URR</span>

<span class="sd">        :param l: orbital angular momentum of the resonance to find</span>
<span class="sd">        :param j: total angular momentum of the resonance to find</span>
<span class="sd">        :return: either the energy of the last resonance with requested (l,j) or None if it can&#39;t be found</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getLastResolvedResonanceRegion</span><span class="p">()</span><span class="o">.</span><span class="n">resonanceParameters</span><span class="o">.</span><span class="n">table</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">l</span> <span class="ow">and</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">==</span><span class="n">j</span><span class="p">:</span> <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="URRcrossSection.getWidthsAndSpacings"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.URRcrossSection.getWidthsAndSpacings">[docs]</a>    <span class="k">def</span> <span class="nf">getWidthsAndSpacings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">egrid</span><span class="p">,</span> <span class="n">interpolateWidths</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The ENDF URR tables give us the average resonance parameters, the average resonance spacing</span>
<span class="sd">        and the number of degrees of freedom, assuming that the widths are distributed by a chi^2</span>
<span class="sd">        probability density function with the given number of degrees of freedom.</span>

<span class="sd">        However, later we&#39;ll need the level densities.  Below we&#39;ll construct them from the</span>
<span class="sd">        average resonance spacing for each L, J.</span>

<span class="sd">        This function sets several member data as dicts (indexed by L &amp; J) of data and interpolateable functions::</span>

<span class="sd">            - levelSpacings: level spacings from ENDF::</span>

<span class="sd">                ..math::</span>
<span class="sd">                    D_{L,J}(E)</span>

<span class="sd">            - averageWidths: average widths from ENDF::</span>

<span class="sd">                ..math::</span>
<span class="sd">                    \Gamma_{L,J,c}</span>

<span class="sd">            - levelSpacingFuncs: level spacings from ENDF, turned into interpolation tables (using XYs.XYs1d instances)</span>
<span class="sd">            - levelDensityFuncs: level density as interpolation tables (using XYs.XYs1d instances), derived from level spacings</span>

<span class="sd">                ..math::</span>
<span class="sd">                    \rho_{L,J}(E)=1/D_{L,J}(E)</span>

<span class="sd">            - averageWidthFuncs: average widths from ENDF, turned into interpolation tables (using XYs.XYs1d instances)</span>
<span class="sd">            - DOFs: degrees of freedom from ENDF</span>

<span class="sd">        :param egrid: the grid to work on</span>
<span class="sd">        :param interpolateWidths: flag to determine whether to interpolate the resonance widths</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">numericalFunctions</span> <span class="k">import</span> <span class="n">pointwiseXY_C</span>

        <span class="k">def</span> <span class="nf">makeXYs</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">xUnit</span><span class="o">=</span><span class="s1">&#39;eV&#39;</span><span class="p">,</span><span class="n">xLabel</span><span class="o">=</span><span class="s1">&#39;energy_in&#39;</span><span class="p">,</span><span class="n">yUnit</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="n">yLabel</span><span class="o">=</span><span class="s2">&quot;crossSection&quot;</span><span class="p">,</span><span class="n">dataForm</span><span class="o">=</span><span class="s2">&quot;xys&quot;</span><span class="p">,</span><span class="n">accuracy</span><span class="o">=</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">8</span><span class="p">,</span>
                    <span class="n">interpolation</span><span class="o">=</span><span class="n">standardsModule</span><span class="o">.</span><span class="n">interpolation</span><span class="o">.</span><span class="n">linlinToken</span><span class="p">):</span>
            <span class="n">theAxes</span> <span class="o">=</span> <span class="n">axesModule</span><span class="o">.</span><span class="n">axes</span><span class="p">(</span> <span class="n">labelsUnits</span><span class="o">=</span><span class="p">{</span><span class="mi">1</span><span class="p">:(</span><span class="n">xLabel</span><span class="p">,</span><span class="n">xUnit</span><span class="p">),</span> <span class="mi">0</span><span class="p">:(</span><span class="n">yLabel</span><span class="p">,</span><span class="n">yUnit</span><span class="p">)}</span> <span class="p">)</span>
            <span class="k">return</span> <span class="n">XYsModule</span><span class="o">.</span><span class="n">XYs1d</span><span class="p">(</span> <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">,</span> <span class="n">dataForm</span> <span class="o">=</span> <span class="n">dataForm</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">theAxes</span><span class="p">,</span> <span class="n">interpolation</span> <span class="o">=</span> <span class="n">interpolation</span> <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">levelSpacings</span><span class="o">=</span><span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">averageWidths</span><span class="o">=</span><span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">levelSpacingFuncs</span><span class="o">=</span><span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">levelDensityFuncs</span><span class="o">=</span><span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">averageWidthFuncs</span><span class="o">=</span><span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">DOFs</span><span class="o">=</span><span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">URR</span><span class="o">.</span><span class="n">L_values</span><span class="p">:</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">L</span>
            <span class="k">for</span> <span class="n">J</span> <span class="ow">in</span> <span class="n">L</span><span class="o">.</span><span class="n">J_values</span><span class="p">:</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">J</span><span class="o">.</span><span class="n">J</span>

                <span class="c1"># dicts for widths and degrees of freedom.</span>
                <span class="c1"># widths may be constant or energy-dependent:</span>
                <span class="c1"># convert here from PhysicalQuantity to floats:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">levelSpacings</span><span class="p">[(</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span><span class="o">=</span><span class="kc">None</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">averageWidths</span><span class="p">[(</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span><span class="o">=</span><span class="p">{}</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">levelSpacingFuncs</span><span class="p">[(</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span><span class="o">=</span><span class="kc">None</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">levelDensityFuncs</span><span class="p">[(</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span><span class="o">=</span><span class="kc">None</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">averageWidthFuncs</span><span class="p">[(</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span><span class="o">=</span><span class="p">{}</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">DOFs</span><span class="p">[(</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span><span class="o">=</span><span class="p">{}</span>

                <span class="c1"># Set the widths and level spacings</span>
                <span class="k">for</span> <span class="n">wid</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;neutronWidth&#39;</span><span class="p">,</span><span class="s1">&#39;captureWidth&#39;</span><span class="p">,</span><span class="s1">&#39;fissionWidthA&#39;</span><span class="p">,</span><span class="s1">&#39;competitiveWidth&#39;</span><span class="p">,</span><span class="s1">&#39;levelSpacing&#39;</span><span class="p">):</span>

                    <span class="c1"># Suck a real column off the energy dependent width table or create a</span>
                    <span class="c1"># virtual column using the constant values in the constant width section</span>
                    <span class="n">column</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">constantWidths</span><span class="p">,</span> <span class="n">wid</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="k">if</span><span class="p">(</span> <span class="n">column</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="p">)</span> <span class="p">:</span>
                        <span class="n">column</span> <span class="o">=</span> <span class="n">column</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">egrid</span><span class="p">))</span>
                    <span class="k">elif</span> <span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">energyDependentWidths</span><span class="p">)</span>
                            <span class="ow">and</span> <span class="n">J</span><span class="o">.</span><span class="n">energyDependentWidths</span><span class="o">.</span><span class="n">getColumn</span><span class="p">(</span> <span class="n">wid</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span> <span class="p">)):</span>
                        <span class="k">if</span> <span class="n">interpolateWidths</span><span class="p">:</span>
                            <span class="n">Nenergies</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">energyDependentWidths</span><span class="o">.</span><span class="n">getColumn</span><span class="p">(</span><span class="s1">&#39;energy&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span><span class="p">))</span>
                            <span class="n">interp</span> <span class="o">=</span> <span class="n">pointwiseXY_C</span><span class="o">.</span><span class="n">pointwiseXY_C</span><span class="p">(</span>
                                <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">J</span><span class="o">.</span><span class="n">energyDependentWidths</span><span class="o">.</span><span class="n">getColumn</span><span class="p">(</span><span class="s1">&#39;energy&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span><span class="p">),</span>
                                        <span class="n">J</span><span class="o">.</span><span class="n">energyDependentWidths</span><span class="o">.</span><span class="n">getColumn</span><span class="p">(</span><span class="n">wid</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span><span class="p">)],</span>
                                        <span class="n">dataForm</span> <span class="o">=</span> <span class="s2">&quot;XsAndYs&quot;</span><span class="p">,</span> <span class="n">interpolation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">URR</span><span class="o">.</span><span class="n">interpolation</span> <span class="p">)</span>
                            <span class="n">widthsNow</span> <span class="o">=</span> <span class="p">[]</span>
                            <span class="k">for</span> <span class="n">en</span> <span class="ow">in</span> <span class="n">egrid</span><span class="p">:</span>
                                <span class="k">try</span><span class="p">:</span>
                                    <span class="n">widthsNow</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">interp</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">en</span><span class="p">)</span> <span class="p">)</span>
                                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                                    <span class="c1"># grrr... data contains invalid log-log or lin-log interpolation</span>
                                    <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;    WARNING: unresolved resonance widths contain an invalid interpolation!&quot;</span><span class="p">)</span>
                                    <span class="n">interp2</span> <span class="o">=</span> <span class="n">pointwiseXY_C</span><span class="o">.</span><span class="n">pointwiseXY_C</span><span class="p">(</span> <span class="n">interp</span><span class="o">.</span><span class="n">copyDataToXYs</span><span class="p">(),</span>
                                            <span class="n">interpolation</span> <span class="o">=</span> <span class="n">standardsModule</span><span class="o">.</span><span class="n">interpolation</span><span class="o">.</span><span class="n">linlinToken</span> <span class="p">)</span>
                                    <span class="n">widthsNow</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">interp2</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">en</span><span class="p">)</span> <span class="p">)</span>
                            <span class="n">column</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">widthsNow</span> <span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">column</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">J</span><span class="o">.</span><span class="n">energyDependentWidths</span><span class="o">.</span><span class="n">getColumn</span><span class="p">(</span><span class="n">wid</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span><span class="p">)</span> <span class="p">)</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">column</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">egrid</span><span class="p">):</span>
                                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Inconsistent energy arrays encountered in unresolved region!&quot;</span><span class="p">)</span>

                    <span class="c1"># Assign the column data to the right map &amp; set up the interpolated versions</span>
                    <span class="k">if</span> <span class="n">wid</span> <span class="o">==</span> <span class="s1">&#39;levelSpacing&#39;</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">levelSpacings</span><span class="p">[(</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span><span class="o">=</span><span class="n">column</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">levelSpacingFuncs</span><span class="p">[(</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span><span class="o">=</span>\
                            <span class="n">makeXYs</span><span class="p">(</span>
                                <span class="n">data</span><span class="o">=</span><span class="p">[</span> <span class="n">egrid</span><span class="p">,</span> <span class="n">column</span> <span class="p">],</span>
                                <span class="n">xLabel</span><span class="o">=</span><span class="s2">&quot;Ex&quot;</span><span class="p">,</span> <span class="n">yLabel</span><span class="o">=</span><span class="s2">&quot;D(Ex)&quot;</span><span class="p">,</span> <span class="n">yUnit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span><span class="p">,</span> <span class="n">dataForm</span><span class="o">=</span><span class="s2">&quot;xsandys&quot;</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">levelDensityFuncs</span><span class="p">[(</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span><span class="o">=</span>\
                            <span class="n">makeXYs</span><span class="p">(</span>
                                <span class="n">data</span><span class="o">=</span><span class="p">[</span><span class="n">egrid</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.0</span><span class="o">/</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">column</span><span class="p">]],</span>
                                <span class="n">xLabel</span><span class="o">=</span><span class="s2">&quot;Ex&quot;</span><span class="p">,</span> <span class="n">yLabel</span><span class="o">=</span><span class="s2">&quot;rho(Ex)&quot;</span><span class="p">,</span> <span class="n">yUnit</span><span class="o">=</span><span class="s2">&quot;1/&quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span><span class="p">,</span> <span class="n">dataForm</span><span class="o">=</span><span class="s2">&quot;xsandys&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">averageWidths</span><span class="p">[(</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">)][</span><span class="n">wid</span><span class="p">]</span><span class="o">=</span><span class="n">column</span>
                        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">column</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">float</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">column</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">averageWidthFuncs</span><span class="p">[(</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">)][</span><span class="n">wid</span><span class="p">]</span><span class="o">=</span>\
                                <span class="n">makeXYs</span><span class="p">(</span>
                                    <span class="n">data</span><span class="o">=</span><span class="p">[</span><span class="n">egrid</span><span class="p">,</span> <span class="n">column</span><span class="p">],</span>
                                    <span class="n">xLabel</span><span class="o">=</span><span class="s2">&quot;Ex&quot;</span><span class="p">,</span> <span class="n">yLabel</span><span class="o">=</span><span class="n">wid</span><span class="p">,</span> <span class="n">yUnit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span><span class="p">,</span> <span class="n">dataForm</span><span class="o">=</span><span class="s2">&quot;xsandys&quot;</span><span class="p">)</span>

                <span class="c1"># Do the degrees of freedom too</span>
                <span class="k">for</span> <span class="n">dof</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;neutronDOF&#39;</span><span class="p">,</span><span class="s1">&#39;fissionDOF&#39;</span><span class="p">,</span><span class="s1">&#39;competitiveDOF&#39;</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">DOFs</span><span class="p">[(</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">)][</span><span class="n">dof</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">dof</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>

                <span class="c1"># Save the final grid</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">egrid</span><span class="o">=</span><span class="n">egrid</span></div>

<div class="viewcode-block" id="URRcrossSection.rho"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.URRcrossSection.rho">[docs]</a>    <span class="k">def</span> <span class="nf">rho</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The dimensionless parameter rho::</span>

<span class="sd">            ..math::</span>
<span class="sd">                \rho = k(E) a</span>

<span class="sd">        We always calculate channel radius for unresolved region according to the ENDF manual</span>

<span class="sd">        :param E: the incident neutron energy</span>
<span class="sd">        :return: rho</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="mf">0.123</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">targetMass_amu</span><span class="o">**</span><span class="p">(</span> <span class="mf">1.</span> <span class="o">/</span> <span class="mf">3.</span> <span class="p">)</span> <span class="o">+</span> <span class="mf">0.08</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">*</span> <span class="n">a</span></div>

<div class="viewcode-block" id="URRcrossSection.getFluctuationIntegrals"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.URRcrossSection.getFluctuationIntegrals">[docs]</a>    <span class="k">def</span> <span class="nf">getFluctuationIntegrals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">widths</span><span class="p">,</span> <span class="n">DOF</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        From subroutine GNRL3 in RECENT. If possible, this will be replaced</span>
<span class="sd">        with more basic approach (rather than using lookup table)... not finding</span>
<span class="sd">        appropriate equations right now</span>

<span class="sd">        Comments from GNRL3 sourcecode::</span>

<span class="sd">              Calculate unresolved resonance fluctuation function</span>
<span class="sd">              (original coding from AVERAGE4 by Mulki Bhat)</span>
<span class="sd">              (new weighting scheme from MC^2-II)</span>

<span class="sd">              This routine has been modified to calculate elastic, capture</span>
<span class="sd">              and fission fluctuation functions all during one call (as</span>
<span class="sd">              opposed to the original version which calculated each reaction</span>
<span class="sd">              separately).</span>

<span class="sd">              GNX, GGX, GFX and GXX are the widths for elastic, capture,</span>
<span class="sd">              fission and competition. MUN, MUF and MUX are the number of</span>
<span class="sd">              degrees of freedom for elastic, fission and competition (infinite</span>
<span class="sd">              number of degrees assumed for capture). RN, RC and RF are the</span>
<span class="sd">              calculated fluctuation integrals for elastic, capture and fission</span>

<span class="sd">              The number of degrees of freedom for each distribution (elastic,</span>
<span class="sd">              fission or competition) may be 1 to 4. If the number of degrees</span>
<span class="sd">              of freedom for any distribution is less than 1 or more than 4</span>
<span class="sd">              it will be treated as an infinite number of degrees of freedom</span>
<span class="sd">              (which infers that the widths are not distributed, but are rather</span>
<span class="sd">              all equal to the average value). This last case is simulated by</span>
<span class="sd">              defining an additional 10 point quadrature in which the weight</span>
<span class="sd">              for one point is 1.0 and the weight for all other points is zero.</span>
<span class="sd">              for the one point of weight 1.0 the average width will be used.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">XX</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">3.0013465e-03</span><span class="p">,</span><span class="mf">1.3219203e-02</span><span class="p">,</span><span class="mf">1.0004488e-03</span><span class="p">,</span><span class="mf">1.3219203e-02</span><span class="p">,</span><span class="mf">1.0e+0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">7.8592886e-02</span><span class="p">,</span><span class="mf">7.2349624e-02</span><span class="p">,</span><span class="mf">2.6197629e-02</span><span class="p">,</span><span class="mf">7.2349624e-02</span><span class="p">,</span><span class="mf">0.0e+0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">4.3282415e-01</span><span class="p">,</span><span class="mf">1.9089473e-01</span><span class="p">,</span><span class="mf">1.4427472e-01</span><span class="p">,</span><span class="mf">1.9089473e-01</span><span class="p">,</span><span class="mf">0.0e+0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">1.3345267e+00</span><span class="p">,</span><span class="mf">3.9528842e-01</span><span class="p">,</span><span class="mf">4.4484223e-01</span><span class="p">,</span><span class="mf">3.9528842e-01</span><span class="p">,</span><span class="mf">0.0e+0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">3.0481846e+00</span><span class="p">,</span><span class="mf">7.4083443e-01</span><span class="p">,</span><span class="mf">1.0160615e+00</span><span class="p">,</span><span class="mf">7.4083443e-01</span><span class="p">,</span><span class="mf">0.0e+0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">5.8263198e+00</span><span class="p">,</span><span class="mf">1.3498293e+00</span><span class="p">,</span><span class="mf">1.9421066e+00</span><span class="p">,</span><span class="mf">1.3498293e+00</span><span class="p">,</span><span class="mf">0.0e+0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">9.9452656e+00</span><span class="p">,</span><span class="mf">2.5297983e+00</span><span class="p">,</span><span class="mf">3.3150885e+00</span><span class="p">,</span><span class="mf">2.5297983e+00</span><span class="p">,</span><span class="mf">0.0e+0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">1.5782128e+01</span><span class="p">,</span><span class="mf">5.2384894e+00</span><span class="p">,</span><span class="mf">5.2607092e+00</span><span class="p">,</span><span class="mf">5.2384894e+00</span><span class="p">,</span><span class="mf">0.0e+0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">2.3996824e+01</span><span class="p">,</span><span class="mf">1.3821772e+01</span><span class="p">,</span><span class="mf">7.9989414e+00</span><span class="p">,</span><span class="mf">1.3821772e+01</span><span class="p">,</span><span class="mf">0.0e+0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">3.6216208e+01</span><span class="p">,</span><span class="mf">7.5647525e+01</span><span class="p">,</span><span class="mf">1.2072069e+01</span><span class="p">,</span><span class="mf">7.5647525e+01</span><span class="p">,</span><span class="mf">0.0e+0</span><span class="p">],]</span>
        <span class="n">WW</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">1.1120413e-01</span><span class="p">,</span><span class="mf">3.3773418e-02</span><span class="p">,</span><span class="mf">3.3376214e-04</span><span class="p">,</span><span class="mf">1.7623788e-03</span><span class="p">,</span><span class="mf">1.0e+0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">2.3546798e-01</span><span class="p">,</span><span class="mf">7.9932171e-02</span><span class="p">,</span><span class="mf">1.8506108e-02</span><span class="p">,</span><span class="mf">2.1517749e-02</span><span class="p">,</span><span class="mf">0.0e+0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">2.8440987e-01</span><span class="p">,</span><span class="mf">1.2835937e-01</span><span class="p">,</span><span class="mf">1.2309946e-01</span><span class="p">,</span><span class="mf">8.0979849e-02</span><span class="p">,</span><span class="mf">0.0e+0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">2.2419127e-01</span><span class="p">,</span><span class="mf">1.7652616e-01</span><span class="p">,</span><span class="mf">2.9918923e-01</span><span class="p">,</span><span class="mf">1.8797998e-01</span><span class="p">,</span><span class="mf">0.0e+0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">1.0967668e-01</span><span class="p">,</span><span class="mf">2.1347043e-01</span><span class="p">,</span><span class="mf">3.3431475e-01</span><span class="p">,</span><span class="mf">3.0156335e-01</span><span class="p">,</span><span class="mf">0.0e+0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">3.0493789e-02</span><span class="p">,</span><span class="mf">2.1154965e-01</span><span class="p">,</span><span class="mf">1.7766657e-01</span><span class="p">,</span><span class="mf">2.9616091e-01</span><span class="p">,</span><span class="mf">0.0e+0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">4.2930874e-03</span><span class="p">,</span><span class="mf">1.3365186e-01</span><span class="p">,</span><span class="mf">4.2695894e-02</span><span class="p">,</span><span class="mf">1.0775649e-01</span><span class="p">,</span><span class="mf">0.0e+0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">2.5827047e-04</span><span class="p">,</span><span class="mf">2.2630659e-02</span><span class="p">,</span><span class="mf">4.0760575e-03</span><span class="p">,</span><span class="mf">2.5171914e-03</span><span class="p">,</span><span class="mf">0.0e+0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">4.9031965e-06</span><span class="p">,</span><span class="mf">1.6313638e-05</span><span class="p">,</span><span class="mf">1.1766115e-04</span><span class="p">,</span><span class="mf">8.9630388e-10</span><span class="p">,</span><span class="mf">0.0e+0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">1.4079206e-08</span><span class="p">,</span><span class="mf">0.0000000e+00</span><span class="p">,</span><span class="mf">5.0989546e-07</span><span class="p">,</span><span class="mf">0.0000000e+00</span><span class="p">,</span><span class="mf">0.0e+0</span><span class="p">],]</span>

        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">widths</span><span class="p">[</span><span class="s1">&#39;captureWidth&#39;</span><span class="p">]</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">widths</span><span class="p">[</span><span class="s1">&#39;neutronWidth&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">RN</span><span class="p">,</span><span class="n">RC</span><span class="p">,</span><span class="n">RF</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

        <span class="c1"># We may store non-integer DOF, but we just end up converting to int:</span>
        <span class="n">MUN</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span> <span class="n">DOF</span><span class="p">[</span><span class="s1">&#39;neutronDOF&#39;</span><span class="p">]</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">MUN</span><span class="o">&lt;</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">MUN</span><span class="o">&gt;</span><span class="mi">4</span><span class="p">:</span> <span class="n">MUN</span><span class="o">=</span><span class="mi">5</span>
        <span class="n">MUF</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span> <span class="n">DOF</span><span class="p">[</span><span class="s1">&#39;fissionDOF&#39;</span><span class="p">]</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">MUF</span><span class="o">&lt;</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">MUF</span><span class="o">&gt;</span><span class="mi">5</span><span class="p">:</span> <span class="n">MUF</span><span class="o">=</span><span class="mi">5</span>
        <span class="n">MUX</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span> <span class="n">DOF</span><span class="p">[</span><span class="s1">&#39;competitiveDOF&#39;</span><span class="p">]</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">MUX</span><span class="o">&lt;</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">MUX</span><span class="o">&gt;</span><span class="mi">4</span><span class="p">:</span> <span class="n">MUX</span><span class="o">=</span><span class="mi">5</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
            <span class="n">xj</span> <span class="o">=</span> <span class="n">XX</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">MUN</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">wj</span> <span class="o">=</span> <span class="n">WW</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">MUN</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">widths</span><span class="p">[</span><span class="s1">&#39;fissionWidthA&#39;</span><span class="p">])</span> <span class="ow">and</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">widths</span><span class="p">[</span><span class="s1">&#39;competitiveWidth&#39;</span><span class="p">]):</span>
                <span class="n">effj</span> <span class="o">=</span> <span class="n">widths</span><span class="p">[</span><span class="s1">&#39;neutronWidth&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">xj</span><span class="o">+</span><span class="n">widths</span><span class="p">[</span><span class="s1">&#39;captureWidth&#39;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
                    <span class="n">xk</span> <span class="o">=</span> <span class="n">XX</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">MUF</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">wk</span> <span class="o">=</span> <span class="n">WW</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">MUF</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">effjk</span> <span class="o">=</span> <span class="n">effj</span><span class="o">+</span><span class="n">widths</span><span class="p">[</span><span class="s1">&#39;fissionWidthA&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">xk</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
                        <span class="n">xi</span> <span class="o">=</span> <span class="n">XX</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">MUX</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">wi</span> <span class="o">=</span> <span class="n">WW</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">MUX</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">factor</span> <span class="o">=</span> <span class="n">wi</span><span class="o">*</span><span class="n">wk</span><span class="o">*</span><span class="n">wj</span><span class="o">*</span><span class="n">xj</span><span class="o">/</span><span class="p">(</span><span class="n">effjk</span><span class="o">+</span><span class="n">widths</span><span class="p">[</span><span class="s1">&#39;competitiveWidth&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">xi</span><span class="p">)</span>
                        <span class="n">RN</span> <span class="o">+=</span> <span class="n">xj</span><span class="o">*</span><span class="n">factor</span>
                        <span class="n">RC</span> <span class="o">+=</span> <span class="n">factor</span>
                        <span class="n">RF</span> <span class="o">+=</span> <span class="n">xk</span><span class="o">*</span><span class="n">factor</span>
            <span class="k">elif</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">widths</span><span class="p">[</span><span class="s1">&#39;fissionWidthA&#39;</span><span class="p">]):</span>
                <span class="n">effj</span> <span class="o">=</span> <span class="n">widths</span><span class="p">[</span><span class="s1">&#39;neutronWidth&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">xj</span><span class="o">+</span><span class="n">widths</span><span class="p">[</span><span class="s1">&#39;captureWidth&#39;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
                    <span class="n">xk</span> <span class="o">=</span> <span class="n">XX</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">MUF</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">wk</span> <span class="o">=</span> <span class="n">WW</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">MUF</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">factor</span> <span class="o">=</span> <span class="n">wk</span><span class="o">*</span><span class="n">wj</span><span class="o">*</span><span class="n">xj</span><span class="o">/</span><span class="p">(</span><span class="n">effj</span><span class="o">+</span><span class="n">widths</span><span class="p">[</span><span class="s1">&#39;fissionWidthA&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">xk</span><span class="p">)</span>
                    <span class="n">RN</span> <span class="o">+=</span> <span class="n">xj</span><span class="o">*</span><span class="n">factor</span>
                    <span class="n">RC</span> <span class="o">+=</span> <span class="n">factor</span>
                    <span class="n">RF</span> <span class="o">+=</span> <span class="n">xk</span><span class="o">*</span><span class="n">factor</span>
            <span class="k">elif</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">widths</span><span class="p">[</span><span class="s1">&#39;competitiveWidth&#39;</span><span class="p">]):</span>
                <span class="n">effj</span> <span class="o">=</span> <span class="n">widths</span><span class="p">[</span><span class="s1">&#39;neutronWidth&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">xj</span> <span class="o">+</span> <span class="n">widths</span><span class="p">[</span><span class="s1">&#39;captureWidth&#39;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
                    <span class="n">xk</span> <span class="o">=</span> <span class="n">XX</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">MUX</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">wk</span> <span class="o">=</span> <span class="n">WW</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">MUX</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">factor</span> <span class="o">=</span> <span class="n">wk</span><span class="o">*</span><span class="n">wj</span><span class="o">*</span><span class="n">xj</span><span class="o">/</span><span class="p">(</span><span class="n">effj</span><span class="o">+</span><span class="n">widths</span><span class="p">[</span><span class="s1">&#39;competitiveWidth&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">xk</span><span class="p">)</span>
                    <span class="n">RN</span> <span class="o">+=</span> <span class="n">xj</span><span class="o">*</span><span class="n">factor</span>
                    <span class="n">RC</span> <span class="o">+=</span> <span class="n">factor</span>
            <span class="k">else</span><span class="p">:</span>   <span class="c1"># only neutron and capture widths:</span>
                <span class="n">factor</span> <span class="o">=</span> <span class="n">wj</span><span class="o">*</span><span class="n">xj</span><span class="o">/</span><span class="p">(</span><span class="n">widths</span><span class="p">[</span><span class="s1">&#39;neutronWidth&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">xj</span><span class="o">+</span><span class="n">widths</span><span class="p">[</span><span class="s1">&#39;captureWidth&#39;</span><span class="p">])</span>
                <span class="n">RN</span> <span class="o">+=</span> <span class="n">xj</span><span class="o">*</span><span class="n">factor</span>
                <span class="n">RC</span> <span class="o">+=</span> <span class="n">factor</span>
        <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="p">(</span><span class="n">RN</span><span class="p">,</span><span class="n">RC</span><span class="p">,</span><span class="n">RF</span><span class="p">):</span>
            <span class="n">arr</span><span class="p">[</span> <span class="n">widths</span><span class="p">[</span><span class="s1">&#39;neutronWidth&#39;</span><span class="p">]</span><span class="o">&lt;=</span><span class="mi">0</span> <span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">RN</span><span class="p">,</span><span class="n">RC</span><span class="p">,</span><span class="n">RF</span></div>

<div class="viewcode-block" id="URRcrossSection.generateEnergyGrid"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.URRcrossSection.generateEnergyGrid">[docs]</a>    <span class="k">def</span> <span class="nf">generateEnergyGrid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interpolateWidths</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the energy grid for reconstructing unresolved resonances. Usually this is just the energy grid</span>
<span class="sd">        chosen by the evaluator for storing energy-dependent widths.</span>

<span class="sd">        Now, ENDF says to interpolate on the reconstructed average cross section.</span>
<span class="sd">        This is stupid (see Red&#39;s rant in D.E. Cullen &quot;A Short History of ENDF/B Unresolved Resonance Parameters&quot;,</span>
<span class="sd">        LLNL Report LLNL-TR-461199, ENDF Report ENDF-369 (2010)).  Better is to interpolate on the model inputs</span>
<span class="sd">        (the average widths in the case of URR) and refine the reconstructed cross section to the desired accuracy.</span>
<span class="sd">        This is what the interpolateWidths flag controls.</span>

<span class="sd">        :param interpolateWidths: if True, interpolate the average widths</span>
<span class="sd">        :return: a tuple containing the grid and the interpolate flag</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">egrid</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">URR</span><span class="o">.</span><span class="n">L_values</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">J</span> <span class="ow">in</span> <span class="n">L</span><span class="o">.</span><span class="n">J_values</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span> <span class="n">egrid</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="n">J</span><span class="o">.</span><span class="n">energyDependentWidths</span><span class="o">.</span><span class="n">getColumn</span><span class="p">(</span><span class="s1">&#39;energy&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span><span class="p">)</span> <span class="p">)</span>
                <span class="k">except</span><span class="p">:</span> <span class="n">egrid</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">lowerBound</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">upperBound</span><span class="p">]</span> <span class="p">)</span>
        <span class="n">egrid</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span> <span class="n">egrid</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">egrid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">lowerBound</span> <span class="ow">or</span> <span class="n">egrid</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">upperBound</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Energy grid in unresolved region doesn&#39;t span stated energy range:&quot;</span> <span class="o">+</span>
                    <span class="s2">&quot; (</span><span class="si">%e</span><span class="s2"> - </span><span class="si">%e</span><span class="s2">) vs (</span><span class="si">%e</span><span class="s2"> - </span><span class="si">%e</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">egrid</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">egrid</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">lowerBound</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">upperBound</span><span class="p">)</span> <span class="p">)</span>
        <span class="n">egrid</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">egrid</span><span class="p">)</span>

        <span class="c1"># below is a nasty hack since some ENDF files don&#39;t supply a dense enough energy grid in the URR.</span>
        <span class="c1"># These files should be fixed, but in the meantime add extra points and interpolate the widths:</span>
        <span class="n">energyGridGaps</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span> <span class="n">egrid</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">/</span> <span class="n">egrid</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="n">energyGridGaps</span> <span class="p">):</span>
            <span class="kn">import</span> <span class="nn">math</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;WARNING: filling large gaps in unresolved energy grid!&quot;</span><span class="p">)</span>
            <span class="n">e_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span> <span class="n">egrid</span> <span class="p">)</span>
            <span class="n">fixGrid</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.25</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">1.7</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">6.0</span><span class="p">,</span> <span class="mf">7.2</span><span class="p">,</span> <span class="mf">8.5</span><span class="p">]</span> <span class="p">)</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">energyGridGaps</span><span class="p">:</span>
                <span class="n">lowend</span><span class="p">,</span> <span class="n">highend</span> <span class="o">=</span> <span class="n">egrid</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">egrid</span><span class="p">[</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">lowPow</span><span class="p">,</span> <span class="n">highPow</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span> <span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span> <span class="n">lowend</span> <span class="p">)</span> <span class="p">),</span> <span class="nb">int</span><span class="p">(</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span> <span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span> <span class="n">highend</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span> <span class="n">lowPow</span><span class="p">,</span> <span class="n">highPow</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">):</span>
                    <span class="n">points_to_add</span> <span class="o">=</span> <span class="p">[</span><span class="n">point</span> <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="mi">10</span><span class="o">**</span><span class="n">i</span> <span class="o">*</span> <span class="n">fixGrid</span> <span class="k">if</span> <span class="n">lowend</span> <span class="o">&lt;</span> <span class="n">point</span> <span class="o">&lt;</span> <span class="n">highend</span><span class="p">]</span>
                    <span class="n">e_set</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="n">points_to_add</span> <span class="p">)</span>
            <span class="n">interpolateWidths</span><span class="o">=</span><span class="kc">True</span>
            <span class="n">egrid</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="nb">sorted</span><span class="p">(</span> <span class="n">e_set</span> <span class="p">)</span> <span class="p">)</span>
        <span class="c1"># end of nasty hack</span>

        <span class="k">return</span> <span class="n">egrid</span><span class="p">,</span> <span class="n">interpolateWidths</span></div>

<div class="viewcode-block" id="URRcrossSection.getCrossSection"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.URRcrossSection.getCrossSection">[docs]</a>    <span class="k">def</span> <span class="nf">getCrossSection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interpolateWidths</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get unresolved region cross section for each incident energy in E.</span>
<span class="sd">        By default, calculate on the energy grid supplied and then interpolate the resulting cross section.</span>

<span class="sd">        If interpolateWidths==True, interpolate the average widths during reconstruction instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Initialize the energy grid and, if needed, the widths, DOFs and level spacings</span>
        <span class="n">E</span><span class="p">,</span> <span class="n">interpolateWidths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generateEnergyGrid</span><span class="p">(</span><span class="n">interpolateWidths</span><span class="o">=</span><span class="n">interpolateWidths</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">levelSpacings</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">getWidthsAndSpacings</span><span class="p">(</span> <span class="n">E</span><span class="p">,</span> <span class="n">interpolateWidths</span><span class="o">=</span><span class="n">interpolateWidths</span> <span class="p">)</span>

        <span class="c1"># Integrate to get the average cross section, the ENDF way.  Assumes resonances are SLBW ones (ugh)</span>
        <span class="n">captureSum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">elasticSum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">fissionSum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
        <span class="n">rhohat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">URR</span><span class="o">.</span><span class="n">scatteringRadius</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s1">&#39;10*fm&#39;</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">URR</span><span class="o">.</span><span class="n">L_values</span><span class="p">:</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">L</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">rhohat</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">J</span> <span class="ow">in</span> <span class="n">L</span><span class="o">.</span><span class="n">J_values</span><span class="p">:</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">J</span><span class="o">.</span><span class="n">J</span>
                <span class="n">gfactor</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">projectileSpin</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">targetSpin</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>

                <span class="c1"># Because the neutron width is really a reduced width in ENDF, we have to convert it to a &quot;regular&quot; width.</span>
                <span class="c1"># Save all the widths in a new widths container to simplify coding in the fluctuating integral widget</span>
                <span class="n">VL</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">DOFs</span><span class="p">[(</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">)][</span><span class="s1">&#39;neutronDOF&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactor</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">rho</span><span class="p">)</span> <span class="o">/</span> <span class="n">rho</span>
                <span class="n">widths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">averageWidths</span><span class="p">[(</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span>
                <span class="n">widths</span><span class="p">[</span><span class="s1">&#39;neutronWidth&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">VL</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">E</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">averageWidths</span><span class="p">[(</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">)][</span><span class="s1">&#39;neutronWidth&#39;</span><span class="p">]</span>

                <span class="n">RN</span><span class="p">,</span><span class="n">RC</span><span class="p">,</span><span class="n">RF</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFluctuationIntegrals</span><span class="p">(</span><span class="n">widths</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">DOFs</span><span class="p">[(</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">)])</span>

                <span class="c1"># common factor for all reactions:</span>
                <span class="n">comfac</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">gfactor</span><span class="o">*</span><span class="n">widths</span><span class="p">[</span><span class="s1">&#39;neutronWidth&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">levelSpacings</span><span class="p">[(</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span>

                <span class="n">captureSum</span> <span class="o">+=</span> <span class="n">RC</span> <span class="o">*</span> <span class="n">widths</span><span class="p">[</span><span class="s1">&#39;captureWidth&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">comfac</span>
                <span class="n">fissionSum</span> <span class="o">+=</span> <span class="n">RF</span> <span class="o">*</span> <span class="n">widths</span><span class="p">[</span><span class="s1">&#39;fissionWidthA&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">comfac</span>
                <span class="n">elasticSum</span> <span class="o">+=</span> <span class="p">(</span><span class="n">RN</span> <span class="o">*</span> <span class="n">widths</span><span class="p">[</span><span class="s1">&#39;neutronWidth&#39;</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">comfac</span>

            <span class="n">elasticSum</span> <span class="o">+=</span> <span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>

        <span class="c1"># common factor &#39;beta&#39; as row vector:</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">(</span><span class="n">E</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">capture</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">captureSum</span>
        <span class="n">elastic</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">elasticSum</span>
        <span class="n">fission</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">fissionSum</span>
        <span class="k">for</span> <span class="n">reaction</span> <span class="ow">in</span> <span class="p">(</span><span class="n">capture</span><span class="p">,</span><span class="n">elastic</span><span class="p">,</span><span class="n">fission</span><span class="p">):</span>
            <span class="n">reaction</span><span class="p">[</span> <span class="n">reaction</span><span class="o">&lt;=</span><span class="mi">0</span> <span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">total</span> <span class="o">=</span> <span class="n">elastic</span> <span class="o">+</span> <span class="n">capture</span> <span class="o">+</span> <span class="n">fission</span>
        <span class="n">nonelastic</span> <span class="o">=</span> <span class="n">capture</span> <span class="o">+</span> <span class="n">fission</span>

        <span class="n">xscs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;total&#39;</span><span class="p">:</span><span class="n">total</span><span class="p">,</span> <span class="s1">&#39;elastic&#39;</span><span class="p">:</span><span class="n">elastic</span><span class="p">,</span> <span class="s1">&#39;capture&#39;</span><span class="p">:</span><span class="n">capture</span><span class="p">,</span> <span class="s1">&#39;fission&#39;</span><span class="p">:</span><span class="n">fission</span><span class="p">,</span> <span class="s1">&#39;nonelastic&#39;</span><span class="p">:</span><span class="n">nonelastic</span><span class="p">}</span>

        <span class="c1"># convert to crossSection.pointwise instances, using interpolation specified in the evaluation:</span>
        <span class="n">crossSectionAxes</span> <span class="o">=</span> <span class="n">crossSection</span><span class="o">.</span><span class="n">defaultAxes</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">xscs</span><span class="p">:</span>
            <span class="n">xscs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">crossSection</span><span class="o">.</span><span class="n">XYs1d</span><span class="p">(</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">crossSectionAxes</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="nb">zip</span><span class="p">(</span><span class="n">E</span><span class="p">,</span><span class="n">xscs</span><span class="p">[</span><span class="n">key</span><span class="p">]),</span> <span class="n">interpolation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">URR</span><span class="o">.</span><span class="n">interpolation</span> <span class="p">)</span>
            <span class="n">xscs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">xscs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">domainSlice</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">lowerBound</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">upperBound</span> <span class="p">)</span>

        <span class="k">return</span> <span class="n">xscs</span></div>

<div class="viewcode-block" id="URRcrossSection.sampleRR"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.URRcrossSection.sampleRR">[docs]</a>    <span class="k">def</span> <span class="nf">sampleRR</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lastResonanceEnergies</span><span class="p">,</span> <span class="n">lowerBound</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">upperBound</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="s1">&#39;goe&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a sample of a resolved resonant set using the average URR parameters</span>

<span class="sd">        :param lastResonanceEnergies: the energy of the last energy from the RRR</span>
<span class="sd">        :param verbose: turn on verbose output</span>
<span class="sd">        :return: the resonance set as a fudge.core.math.table</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">blurr.resonance_generator</span>
        <span class="kn">from</span> <span class="nn">xData.table</span> <span class="k">import</span> <span class="n">table</span> <span class="k">as</span> <span class="n">gndTable</span><span class="p">,</span> <span class="n">columnHeader</span> <span class="k">as</span> <span class="n">gndColumnId</span>
        <span class="n">fakeRRR</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">if</span> <span class="n">lowerBound</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">lowerBound</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lowerBound</span>
        <span class="k">if</span> <span class="n">upperBound</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">upperBound</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">upperBound</span>

        <span class="c1"># WARNING: be very careful that the columns defined in getFakeResonanceSet match</span>
        <span class="c1">#          in both name and order with those defined below</span>
        <span class="k">for</span> <span class="n">lj</span> <span class="ow">in</span> <span class="n">lastResonanceEnergies</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">fakeRRR</span><span class="o">+=</span><span class="n">blurr</span><span class="o">.</span><span class="n">resonance_generator</span><span class="o">.</span><span class="n">getFakeResonanceSet</span><span class="p">(</span>
                <span class="n">E0</span><span class="o">=</span><span class="n">lastResonanceEnergies</span><span class="p">[</span><span class="n">lj</span><span class="p">],</span>
                <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">,</span>
                <span class="n">L</span><span class="o">=</span><span class="n">lj</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">J</span><span class="o">=</span><span class="n">lj</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">levelDensity</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">levelDensityFuncs</span><span class="p">[</span><span class="n">lj</span><span class="p">],</span>
                <span class="n">aveWidthFuncs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">averageWidthFuncs</span><span class="p">[</span><span class="n">lj</span><span class="p">],</span>
                <span class="n">DOFs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">DOFs</span><span class="p">[</span><span class="n">lj</span><span class="p">],</span>
                <span class="n">lowerBound</span><span class="o">=</span><span class="n">lowerBound</span><span class="p">,</span>
                <span class="n">upperBound</span><span class="o">=</span><span class="n">upperBound</span><span class="p">,</span>
                <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">gndTable</span><span class="p">(</span> <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">gndColumnId</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;energy&quot;</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;eV&quot;</span> <span class="p">),</span>
                <span class="n">gndColumnId</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;L&quot;</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;&quot;</span> <span class="p">),</span>
                <span class="n">gndColumnId</span><span class="p">(</span> <span class="mi">2</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;J&quot;</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;&quot;</span> <span class="p">),</span>
                <span class="n">gndColumnId</span><span class="p">(</span> <span class="mi">3</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;totalWidth&quot;</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;eV&quot;</span> <span class="p">),</span>
                <span class="n">gndColumnId</span><span class="p">(</span> <span class="mi">4</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;neutronWidth&quot;</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;eV&quot;</span> <span class="p">),</span>
                <span class="n">gndColumnId</span><span class="p">(</span> <span class="mi">5</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;captureWidth&quot;</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;eV&quot;</span> <span class="p">),</span>
                <span class="n">gndColumnId</span><span class="p">(</span> <span class="mi">6</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;fissionWidthA&quot;</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;eV&quot;</span> <span class="p">),</span>
                <span class="n">gndColumnId</span><span class="p">(</span> <span class="mi">6</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;competitiveWidth&quot;</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;eV&quot;</span> <span class="p">)],</span>
                <span class="n">data</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span> <span class="n">fakeRRR</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span><span class="p">(</span><span class="n">res</span><span class="p">):</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">)</span>   <span class="c1"># sort by energy only</span>
        <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;totalWidth&quot;</span><span class="p">,</span><span class="s2">&quot;fissionWidthA&quot;</span><span class="p">,</span><span class="s2">&quot;competitiveWidth&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span> <span class="n">result</span><span class="o">.</span><span class="n">getColumn</span><span class="p">(</span><span class="n">column</span><span class="p">)</span> <span class="p">):</span>
                <span class="n">result</span><span class="o">.</span><span class="n">removeColumn</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="URRcrossSection.getURRPDF"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.URRcrossSection.getURRPDF">[docs]</a>    <span class="k">def</span> <span class="nf">getURRPDF</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resClass</span><span class="p">,</span> <span class="n">nSamples</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="s1">&#39;goe&#39;</span><span class="p">,</span> <span class="n">interpolateWidths</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                  <span class="n">NE</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">ELowerBound</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">EUpperBound</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">NXS</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">XSLowerBound</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">XSUpperBound</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">restart</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">timing</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">memory</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        About restart files: they json dumps of the URR PDF, but before being renomalized.  In other words, they are pure histograms</span>
<span class="sd">            of number of points of the cross section curve in an energy/cross section voxel.  This is a poor-mans path-length in the</span>
<span class="sd">            voxel.</span>

<span class="sd">        At end of the run, the URR PDF (which, as I said, is still just a histogram) is normalized properly, turning it into a true PDF.</span>

<span class="sd">        :param resClass: The class instance to use for reconstructing realizations of the cross section set.</span>
<span class="sd">        :param nSamples:</span>
<span class="sd">        :param style: not the GND style, rather the style of resonance generation (see sampleRR)</span>
<span class="sd">        :param interpolateWidths: interpolate the URR widths or not (just say &quot;True&quot;)</span>
<span class="sd">        :param NE: number of energy bins in the PDF (# bin boundaries is NE+1)</span>
<span class="sd">        :param ELowerBound:</span>
<span class="sd">        :param EUpperBound:</span>
<span class="sd">        :param NXS: number of cross section bins in the PDF (# bin boundaries is NXS+1)</span>
<span class="sd">        :param XSLowerBound:</span>
<span class="sd">        :param XSUpperBound:</span>
<span class="sd">        :param verbose: enable verbose output</span>
<span class="sd">        :param restart: enable restart capability</span>
<span class="sd">        :param timing: enable printing out timings</span>
<span class="sd">        :param memory: enable printing out memory usage of the resonance data structure</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Imports for this function</span>
        <span class="kn">import</span> <span class="nn">os</span>
        <span class="k">if</span> <span class="n">timing</span><span class="p">:</span> <span class="kn">import</span> <span class="nn">datetime</span>
        <span class="k">if</span> <span class="n">memory</span><span class="p">:</span> <span class="kn">from</span> <span class="nn">sys</span> <span class="k">import</span> <span class="n">getsizeof</span>

        <span class="k">if</span> <span class="n">NE</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Requested energy grid must have at least two point, so you need at least one bin&quot;</span><span class="p">)</span>

        <span class="c1"># Fine-grained restart controls</span>
        <span class="n">save_restart_every_x_runs</span><span class="o">=</span><span class="mi">100</span>

        <span class="c1"># Start time</span>
        <span class="k">if</span> <span class="n">timing</span><span class="p">:</span> <span class="n">lastTime</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>

        <span class="c1"># Helper functions for setting up bins in cross section and energy</span>
        <span class="k">def</span> <span class="nf">equal_lethargy_bins</span><span class="p">(</span><span class="n">numBins</span><span class="p">,</span> <span class="n">domainMin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">domainMax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">reverse</span><span class="p">:</span> <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">domainMax</span><span class="p">),</span> <span class="n">stop</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">domainMin</span><span class="p">),</span> <span class="n">num</span><span class="o">=</span><span class="n">numBins</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">domainMin</span><span class="p">),</span> <span class="n">stop</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">domainMax</span><span class="p">),</span> <span class="n">num</span><span class="o">=</span><span class="n">numBins</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">equal_bins</span><span class="p">(</span><span class="n">numBins</span><span class="p">,</span> <span class="n">domainMin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">domainMax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">reverse</span><span class="p">:</span> <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">domainMax</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">domainMin</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">numBins</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">domainMin</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">domainMax</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">numBins</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Initialize the widths, DOFs and level spacings.</span>
        <span class="c1"># Also setup the main egrid for cross section reconstruction.</span>
        <span class="c1"># This is the main grid that spans the whole URR.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">levelSpacings</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">egrid</span><span class="p">,</span> <span class="n">interpolateWidths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generateEnergyGrid</span><span class="p">(</span><span class="n">interpolateWidths</span><span class="o">=</span><span class="n">interpolateWidths</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getWidthsAndSpacings</span><span class="p">(</span><span class="n">egrid</span><span class="p">,</span> <span class="n">interpolateWidths</span><span class="o">=</span><span class="n">interpolateWidths</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="n">egrid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">egrid</span>

        <span class="c1"># Get the upper most resonances</span>
        <span class="n">lastResonances</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">levelSpacingFuncs</span><span class="p">:</span> <span class="n">lastResonances</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getLastResolvedResonanceEnergy</span><span class="p">(</span><span class="n">l</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">j</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># Create or read the restart of the binned PDF</span>
        <span class="n">thisRRSample</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getLastResolvedResonanceRegion</span><span class="p">())</span>
        <span class="n">oldNRes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">thisRRSample</span><span class="o">.</span><span class="n">resonanceParameters</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="n">thePDFs</span><span class="o">=</span><span class="n">URRPDFTable</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">timing</span><span class="p">:</span>
            <span class="n">thisTime</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
            <span class="nb">print</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">TIMING/setup:&#39;</span><span class="p">,</span> <span class="n">thisTime</span> <span class="o">-</span> <span class="n">lastTime</span>
            <span class="n">lastTime</span> <span class="o">=</span> <span class="n">thisTime</span>
        <span class="k">if</span> <span class="n">memory</span><span class="p">:</span>
            <span class="nb">print</span> <span class="s1">&#39;MEMORY/thisRRSample before (&#39;</span><span class="p">,</span>\
                <span class="s1">&#39;type:&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">thisRRSample</span><span class="o">.</span><span class="n">resonanceParameters</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">data</span><span class="p">),</span>\
                <span class="s1">&#39;size:&#39;</span><span class="p">,</span> <span class="n">getsizeof</span><span class="p">(</span><span class="n">thisRRSample</span><span class="o">.</span><span class="n">resonanceParameters</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">data</span><span class="p">),</span><span class="s1">&#39;)&#39;</span>
        <span class="k">if</span> <span class="n">restart</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">glob</span>
            <span class="n">restartFiles</span><span class="o">=</span><span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s1">&#39;restart*.txt&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">restartFiles</span><span class="p">:</span>
                <span class="n">lastSample</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,[</span><span class="n">x</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;restart&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.txt&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">restartFiles</span><span class="p">]))</span>
                <span class="n">restartFile</span> <span class="o">=</span> <span class="s1">&#39;restart</span><span class="si">%i</span><span class="s1">.txt&#39;</span><span class="o">%</span><span class="n">lastSample</span>
                <span class="n">iSampleStart</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">restartFile</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;restart&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.txt&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">))</span><span class="o">+</span><span class="mi">1</span>
                <span class="nb">print</span> <span class="s1">&#39;Loading results after sample #</span><span class="si">%i</span><span class="s1"> from&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">iSampleStart</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">restartFile</span>
                <span class="n">thePDFs</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">restartFile</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="n">restart</span><span class="o">=</span><span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">restart</span><span class="p">:</span>
            <span class="c1"># Set up domains for energy, cross section</span>
            <span class="k">if</span> <span class="n">ELowerBound</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">ELowerBound</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lowerBound</span>
            <span class="k">if</span> <span class="n">EUpperBound</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">EUpperBound</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">upperBound</span>
            <span class="k">if</span> <span class="n">XSLowerBound</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">XSLowerBound</span><span class="o">=</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">10</span>
            <span class="k">if</span> <span class="n">XSUpperBound</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">XSUpperBound</span><span class="o">=</span><span class="mf">15.5</span>
            <span class="n">iSampleStart</span><span class="o">=</span><span class="mi">0</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;total&#39;</span><span class="p">,</span><span class="s1">&#39;elastic&#39;</span><span class="p">,</span><span class="s1">&#39;capture&#39;</span><span class="p">,</span><span class="s1">&#39;fission&#39;</span><span class="p">,</span><span class="s1">&#39;nonelastic&#39;</span><span class="p">]:</span>
                <span class="n">thePDFs</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">NE</span><span class="p">,</span><span class="n">NXS</span><span class="p">))</span> <span class="c1"># This is where we analyze the accumulated moments to generate the PDF</span>
            <span class="c1"># Sets up the bins for the PDF histogram.  There is a low value logrithmic grid to</span>
            <span class="c1"># handle capture and a high value linear grid to handle total and elastic</span>
            <span class="n">thePDFs</span><span class="o">.</span><span class="n">eBins</span> <span class="o">=</span> <span class="n">equal_bins</span><span class="p">(</span><span class="n">NE</span><span class="p">,</span> <span class="n">domainMin</span><span class="o">=</span><span class="n">ELowerBound</span><span class="p">,</span> <span class="n">domainMax</span><span class="o">=</span><span class="n">EUpperBound</span><span class="p">)</span>
            <span class="n">nXSlow</span><span class="o">=</span><span class="nb">int</span><span class="p">((</span><span class="n">NXS</span><span class="o">-</span><span class="mi">5</span><span class="p">)</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">nXShi</span><span class="o">=</span><span class="n">NXS</span><span class="o">-</span><span class="mi">5</span><span class="o">-</span><span class="n">nXSlow</span>
            <span class="n">thePDFs</span><span class="o">.</span><span class="n">xsBins</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">]</span><span class="o">+</span> \
                             <span class="nb">list</span><span class="p">(</span><span class="n">equal_lethargy_bins</span><span class="p">(</span><span class="n">nXSlow</span><span class="p">,</span> <span class="n">domainMin</span><span class="o">=</span><span class="n">XSLowerBound</span><span class="p">,</span> <span class="n">domainMax</span><span class="o">=</span><span class="mf">0.1</span><span class="p">))[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span> \
                             <span class="nb">list</span><span class="p">(</span><span class="n">equal_bins</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">domainMin</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">domainMax</span><span class="o">=</span><span class="mf">0.5</span><span class="p">))[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span> \
                             <span class="nb">list</span><span class="p">(</span><span class="n">equal_bins</span><span class="p">(</span><span class="n">nXShi</span><span class="p">,</span> <span class="n">domainMin</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">domainMax</span><span class="o">=</span><span class="n">XSUpperBound</span><span class="p">)))</span>

        <span class="c1"># Loop through the samples to (continue) build(ing) the PDFs</span>
        <span class="n">iSamples</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="n">iSampleStart</span><span class="p">,</span><span class="n">nSamples</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">iSample</span> <span class="ow">in</span> <span class="n">iSamples</span><span class="p">:</span>
            <span class="n">rfname</span> <span class="o">=</span> <span class="s1">&#39;restart</span><span class="si">%i</span><span class="s1">.txt&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">iSample</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">timing</span><span class="p">:</span> <span class="n">sampleTime</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;---- you can interupt now and you won&#39;t trash a sample&quot;</span><span class="p">)</span>
                <span class="c1"># Splitting and adding the tables this way (with the slice action below)</span>
                <span class="c1"># avoids a memory leak in the Python list() implementation</span>
                <span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getLastResolvedResonanceRegion</span><span class="p">()</span><span class="o">.</span><span class="n">resonanceParameters</span><span class="o">.</span><span class="n">table</span>
                <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sampleRR</span><span class="p">(</span><span class="n">lastResonances</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span> <span class="o">!=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">b</span><span class="o">.</span><span class="n">columns</span><span class="p">]:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;columns don&#39;t match </span><span class="si">%s</span><span class="s2"> vs. </span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="nb">str</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">columns</span><span class="p">]),</span>
                                                                      <span class="nb">str</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">b</span><span class="o">.</span><span class="n">columns</span><span class="p">])))</span>
                <span class="n">thisRRSample</span><span class="o">.</span><span class="n">resonanceParameters</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">data</span><span class="p">[:</span><span class="n">oldNRes</span><span class="p">])</span><span class="o">+</span><span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;---- you can&#39;t interupt for a while without trashing the sample in progress&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyboardInterrupt</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">iSample</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">rfname</span><span class="p">):</span>
                    <span class="nb">print</span> <span class="s1">&#39;Interupt... Saving restart file&#39;</span><span class="p">,</span> <span class="n">rfname</span>
                    <span class="n">thePDFs</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">rfname</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">exit</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">restart</span> <span class="ow">and</span> <span class="n">iSample</span><span class="o">%</span><span class="n">save_restart_every_x_runs</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span> <span class="s1">&#39;Saving restart file&#39;</span><span class="p">,</span> <span class="n">rfname</span>
                <span class="n">thePDFs</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">rfname</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">memory</span><span class="p">:</span>
                <span class="nb">print</span> <span class="s1">&#39;MEMORY/thisRRSample sample #</span><span class="si">%i</span><span class="s1"> (&#39;</span> <span class="o">%</span> <span class="n">iSample</span><span class="p">,</span>\
                    <span class="s1">&#39;parent type:&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">thisRRSample</span><span class="o">.</span><span class="n">resonanceParameters</span><span class="o">.</span><span class="n">table</span><span class="p">),</span>\
                    <span class="s1">&#39;table type:&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">thisRRSample</span><span class="o">.</span><span class="n">resonanceParameters</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">data</span><span class="p">),</span>\
                    <span class="s1">&#39;final RR size:&#39;</span><span class="p">,</span> <span class="n">getsizeof</span><span class="p">(</span><span class="n">thisRRSample</span><span class="o">.</span><span class="n">resonanceParameters</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">data</span><span class="p">),</span>\
                    <span class="s1">&#39;base RR size:&#39;</span><span class="p">,</span> <span class="n">getsizeof</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">data</span><span class="p">[:</span><span class="n">oldNRes</span><span class="p">]),</span>\
                    <span class="s1">&#39;sampled RR size:&#39;</span><span class="p">,</span> <span class="n">getsizeof</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">data</span><span class="p">),</span> <span class="s1">&#39;)&#39;</span>
            <span class="k">for</span> <span class="n">iE</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NE</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">timing</span><span class="p">:</span>
                    <span class="n">thisTime</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
                    <span class="nb">print</span> <span class="s1">&#39;TIMING/    iE=</span><span class="si">%i</span><span class="s1">:&#39;</span><span class="o">%</span><span class="n">iE</span><span class="p">,</span> <span class="n">thisTime</span> <span class="o">-</span> <span class="n">lastTime</span><span class="p">,</span> <span class="n">thisTime</span><span class="o">-</span><span class="n">sampleTime</span>
                    <span class="n">lastTime</span> <span class="o">=</span> <span class="n">thisTime</span>

                <span class="c1"># Setup the reconstruction class</span>
                <span class="n">resonanceGenerator</span> <span class="o">=</span> <span class="n">resClass</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">reactionSuite</span><span class="p">,</span>
                    <span class="n">RR</span><span class="o">=</span><span class="n">thisRRSample</span><span class="p">,</span>
                    <span class="n">lowerBound</span><span class="o">=</span><span class="n">egrid</span><span class="p">[</span><span class="n">iE</span><span class="p">],</span> <span class="c1">#ELowerBound,</span>
                    <span class="n">upperBound</span><span class="o">=</span><span class="n">egrid</span><span class="p">[</span><span class="n">iE</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="c1">#EUpperBound,</span>
                    <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">,</span>
                    <span class="n">enableAngDists</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">subEGrid</span> <span class="o">=</span> <span class="n">resonanceGenerator</span><span class="o">.</span><span class="n">generateEnergyGrid</span><span class="p">()</span> <span class="c1"># the grid within this bin</span>

                <span class="c1"># Compute the cross section for this realization</span>
                <span class="c1"># TODO: add in RRR tails from below URR and background R-matrix from above URR</span>
                <span class="n">thisXSSample</span> <span class="o">=</span> <span class="n">resonanceGenerator</span><span class="o">.</span><span class="n">getCrossSection</span><span class="p">(</span><span class="n">subEGrid</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">rxn</span> <span class="ow">in</span> <span class="n">thePDFs</span><span class="p">:</span>
                    <span class="c1"># This is stupid simple.  We made bins in the energy direction (eBins) and the</span>
                    <span class="c1"># cross section direction (xsBins).  We then histogram the data in this 2D grid.</span>
                    <span class="c1"># To turn it into the PDF P(xs|E), we divide all xs bins with the same energy bin</span>
                    <span class="c1"># by the total number of points in that energy bin.  We do have to loop through</span>
                    <span class="c1"># all the xs points in the subEGrid.  This way, if there is a lot of wiggles in the</span>
                    <span class="c1"># cross section within the bin, all the wiggles get counted equally.</span>
                    <span class="k">for</span> <span class="n">xs</span> <span class="ow">in</span> <span class="n">thisXSSample</span><span class="p">[</span><span class="n">rxn</span><span class="p">]:</span>
                        <span class="n">iXS</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">thePDFs</span><span class="o">.</span><span class="n">xsBins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">NXS</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">ee</span> <span class="ow">in</span> <span class="n">subEGrid</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">ee</span> <span class="o">&gt;=</span> <span class="n">egrid</span><span class="p">[</span><span class="n">iE</span><span class="p">]</span> <span class="ow">and</span> <span class="n">ee</span> <span class="o">&lt;=</span> <span class="n">egrid</span><span class="p">[</span><span class="n">iE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                                <span class="n">thePDFs</span><span class="p">[</span><span class="n">rxn</span><span class="p">][</span><span class="n">iE</span><span class="p">,</span> <span class="n">iXS</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">1.0</span>
            <span class="k">if</span> <span class="n">timing</span><span class="p">:</span>
                <span class="n">thisTime</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
                <span class="nb">print</span> <span class="s1">&#39;TIMING/sample #</span><span class="si">%i</span><span class="s1">:&#39;</span><span class="o">%</span><span class="n">iSample</span><span class="p">,</span> <span class="n">thisTime</span> <span class="o">-</span> <span class="n">lastTime</span>
                <span class="n">lastTime</span> <span class="o">=</span> <span class="n">thisTime</span>

        <span class="c1"># All done, normalize the result</span>
        <span class="n">thePDFs</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">timing</span><span class="p">:</span>
            <span class="n">thisTime</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
            <span class="nb">print</span> <span class="s1">&#39;TIMING/normalization:&#39;</span><span class="p">,</span> <span class="n">thisTime</span> <span class="o">-</span> <span class="n">lastTime</span>
            <span class="n">lastTime</span> <span class="o">=</span> <span class="n">thisTime</span>

        <span class="k">return</span> <span class="n">thePDFs</span></div>

<div class="viewcode-block" id="URRcrossSection.getTransmissionCoefficientsFromSumRule"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.URRcrossSection.getTransmissionCoefficientsFromSumRule">[docs]</a>    <span class="k">def</span> <span class="nf">getTransmissionCoefficientsFromSumRule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">skipFission</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use Moldauer&#39;s sum rule to extract the transmission coefficients directly from the URR tables</span>
<span class="sd">            P.A. Moldauer Phys. Rev. Lett. 19, 1047-1048 (1967)</span>

<span class="sd">        :param skipFission: flag to skip fission, what else?</span>
<span class="sd">        :return: a dictionary of results, sorted by channel</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize the reduced width factors for the elastic channel</span>
        <span class="n">redWidthFactor</span><span class="o">=</span><span class="p">{}</span>
        <span class="k">for</span> <span class="n">lj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">averageWidthFuncs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">lj</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">redWidthFactor</span><span class="p">:</span>
                <span class="n">redWidthFactor</span><span class="p">[</span><span class="n">lj</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">=</span><span class="n">XYsModule</span><span class="o">.</span><span class="n">XYs1d</span><span class="o">.</span><span class="n">createFromFunction</span><span class="p">(</span>
                    <span class="n">XYsModule</span><span class="o">.</span><span class="n">XYs1d</span><span class="o">.</span><span class="n">defaultAxes</span><span class="p">(</span>\
                        <span class="n">labelsUnits</span><span class="o">=</span><span class="p">{</span> \
                            <span class="n">XYsModule</span><span class="o">.</span><span class="n">yAxisIndex</span> <span class="p">:</span> <span class="p">(</span> <span class="s1">&#39;gamma&#39;</span> <span class="p">,</span> <span class="s1">&#39;&#39;</span> <span class="p">),</span> \
                            <span class="n">XYsModule</span><span class="o">.</span><span class="n">xAxisIndex</span> <span class="p">:</span> <span class="p">(</span> <span class="s1">&#39;Ex&#39;</span><span class="p">,</span> <span class="s1">&#39;eV&#39;</span> <span class="p">)</span> <span class="p">}),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">averageWidthFuncs</span><span class="p">[</span><span class="n">lj</span><span class="p">][</span><span class="s1">&#39;neutronWidth&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">domain</span><span class="p">(),</span>
                    <span class="k">lambda</span> <span class="n">E</span><span class="p">,</span><span class="n">nope</span><span class="p">:</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">E</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactor</span><span class="p">(</span> <span class="n">lj</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span><span class="n">E</span><span class="p">),</span>
                    <span class="p">{},</span>
                    <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span>
                    <span class="mi">100</span><span class="p">)</span>

        <span class="c1"># Now compute the Tc&#39;s</span>
        <span class="n">Tc</span><span class="o">=</span><span class="p">{}</span>
        <span class="n">widNames</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;capture&#39;</span><span class="p">:</span><span class="s1">&#39;captureWidth&#39;</span><span class="p">,</span><span class="s1">&#39;elastic&#39;</span><span class="p">:</span><span class="s1">&#39;neutronWidth&#39;</span><span class="p">,</span><span class="s1">&#39;fission&#39;</span><span class="p">:</span><span class="s1">&#39;fissionWidthA&#39;</span><span class="p">}</span>
        <span class="n">channelClass</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;capture&#39;</span><span class="p">:</span><span class="n">GAMMACHANNEL</span><span class="p">,</span><span class="s1">&#39;elastic&#39;</span><span class="p">:</span><span class="n">NEUTRONCHANNEL</span><span class="p">,</span><span class="s1">&#39;fission&#39;</span><span class="p">:</span><span class="n">FISSIONCHANNEL</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">rxn</span> <span class="ow">in</span> <span class="n">widNames</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">lj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">averageWidthFuncs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">rxn</span><span class="o">==</span><span class="s1">&#39;elastic&#39;</span><span class="p">:</span>
                    <span class="n">eta</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">redWidthFactor</span><span class="p">[</span><span class="n">lj</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">averageWidthFuncs</span><span class="p">[</span><span class="n">lj</span><span class="p">][</span><span class="n">widNames</span><span class="p">[</span><span class="n">rxn</span><span class="p">]]</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">levelSpacingFuncs</span><span class="p">[</span><span class="n">lj</span><span class="p">]</span> <span class="c1">#*self.levelDensityFuncs[lj]</span>
                <span class="k">elif</span> <span class="n">rxn</span><span class="o">==</span><span class="s1">&#39;fission&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">skipFission</span><span class="p">:</span> <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">widNames</span><span class="p">[</span><span class="n">rxn</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">averageWidthFuncs</span><span class="p">[</span><span class="n">lj</span><span class="p">]:</span> <span class="k">continue</span>
                    <span class="n">eta</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">averageWidthFuncs</span><span class="p">[</span><span class="n">lj</span><span class="p">][</span><span class="n">widNames</span><span class="p">[</span><span class="n">rxn</span><span class="p">]]</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">levelSpacingFuncs</span><span class="p">[</span><span class="n">lj</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">eta</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">averageWidthFuncs</span><span class="p">[</span><span class="n">lj</span><span class="p">][</span><span class="n">widNames</span><span class="p">[</span><span class="n">rxn</span><span class="p">]]</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">levelSpacingFuncs</span><span class="p">[</span><span class="n">lj</span><span class="p">]</span> <span class="c1">#*self.levelDensityFuncs[lj]</span>
                <span class="n">etasqr</span><span class="o">=</span><span class="n">eta</span><span class="o">*</span><span class="n">eta</span>
                <span class="n">c</span><span class="o">=</span><span class="n">ChannelDesignator</span><span class="p">(</span><span class="n">lj</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">lj</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">rxn</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">Tc</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">lj</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">lj</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="n">gfact</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">particleA</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">particleB</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">isElastic</span><span class="o">=</span><span class="p">(</span><span class="n">rxn</span><span class="o">==</span><span class="s1">&#39;elastic&#39;</span><span class="p">),</span> <span class="n">channelClass</span><span class="o">=</span><span class="n">channelClass</span><span class="p">[</span><span class="n">rxn</span><span class="p">],</span> <span class="n">useRelativistic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">eliminated</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">Tc</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">=</span><span class="mf">2.0</span><span class="o">*</span><span class="n">etasqr</span><span class="o">*</span><span class="p">((</span><span class="mf">1.0</span><span class="o">+</span><span class="mf">1.0</span><span class="o">/</span><span class="n">etasqr</span><span class="p">)</span><span class="o">.</span><span class="n">applyFunction</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="kc">None</span><span class="p">)</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Tc</span></div></div>

<span class="n">RRClassMap</span><span class="o">=</span><span class="p">{</span>
    <span class="n">fudge</span><span class="o">.</span><span class="n">gnd</span><span class="o">.</span><span class="n">resonances</span><span class="o">.</span><span class="n">SLBW</span><span class="o">.</span><span class="n">moniker</span><span class="p">:{</span><span class="s1">&#39;gnd&#39;</span><span class="p">:</span><span class="n">fudge</span><span class="o">.</span><span class="n">gnd</span><span class="o">.</span><span class="n">resonances</span><span class="o">.</span><span class="n">SLBW</span><span class="p">,</span><span class="s1">&#39;proc&#39;</span><span class="p">:</span><span class="n">SLBWcrossSection</span><span class="p">},</span>
    <span class="n">fudge</span><span class="o">.</span><span class="n">gnd</span><span class="o">.</span><span class="n">resonances</span><span class="o">.</span><span class="n">MLBW</span><span class="o">.</span><span class="n">moniker</span><span class="p">:{</span><span class="s1">&#39;gnd&#39;</span><span class="p">:</span><span class="n">fudge</span><span class="o">.</span><span class="n">gnd</span><span class="o">.</span><span class="n">resonances</span><span class="o">.</span><span class="n">MLBW</span><span class="p">,</span><span class="s1">&#39;proc&#39;</span><span class="p">:</span><span class="n">MLBWcrossSection</span><span class="p">},</span>
    <span class="n">fudge</span><span class="o">.</span><span class="n">gnd</span><span class="o">.</span><span class="n">resonances</span><span class="o">.</span><span class="n">RM</span><span class="o">.</span><span class="n">moniker</span><span class="p">:{</span><span class="s1">&#39;gnd&#39;</span><span class="p">:</span><span class="n">fudge</span><span class="o">.</span><span class="n">gnd</span><span class="o">.</span><span class="n">resonances</span><span class="o">.</span><span class="n">RM</span><span class="p">,</span><span class="s1">&#39;proc&#39;</span><span class="p">:</span><span class="n">RMcrossSection</span><span class="p">},</span>
    <span class="n">fudge</span><span class="o">.</span><span class="n">gnd</span><span class="o">.</span><span class="n">resonances</span><span class="o">.</span><span class="n">RMatrix</span><span class="o">.</span><span class="n">moniker</span><span class="p">:{</span><span class="s1">&#39;gnd&#39;</span><span class="p">:</span><span class="n">fudge</span><span class="o">.</span><span class="n">gnd</span><span class="o">.</span><span class="n">resonances</span><span class="o">.</span><span class="n">RMatrix</span><span class="p">,</span><span class="s1">&#39;proc&#39;</span><span class="p">:</span><span class="n">RMatrixLimitedcrossSection</span><span class="p">}}</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../../index.html">
              <img class="logo" src="../../../../_static/gnd.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">Fudge and GND 4.2.2 beta documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2012, B.Beck, D. Brown, C. Mattoon, N. Patel, N. Summers.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.1.
    </div>
  </body>
</html>